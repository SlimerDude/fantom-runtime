<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>web::WebUtil</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>web</a></li>
  <li>&gt;</li>
  <li><a href='WebUtil.html'>WebUtil</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>web::WebUtil</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  web::WebUtil</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2007, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   27 Jun 07  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** WebUtil encapsulates several useful utility web methods.</span>
<span class='z'>** Also see `sys::MimeType` and its utility methods.</span>
<span class='z'>**</span>
@Js
<span class='k'>class</span> WebUtil
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Chars</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if the specified string is a valid HTTP token production</span>
  <span class='z'>** which is any ASCII character which is not a control char or a</span>
  <span class='z'>** separator.  The separators characters are:</span>
  <span class='z'>**   "(" | ")" | "&lt;" | "&gt;" | "@" |</span>
  <span class='z'>**   "," | ";" | ":" | "\" | &lt;"&gt; |</span>
  <span class='z'>**   "/" | "[" | "]" | "?" | "=" |</span>
  <span class='z'>**   "{" | "}" | SP | HT</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Bool <span id='isToken'>isToken</span><span class='b'>(</span>Str s<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>s.isEmpty<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    <span class='k'>return</span> s.all |Int c-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> c &lt; 127 &amp;&amp; tokenChars<span class='b'>[</span>c<span class='b'>]</span> <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> <span class='k'>const</span> Bool<span class='b'>[]</span> <span id='tokenChars'>tokenChars</span>
  <span class='k'>static</span>
  <span class='b'>{</span>
    m := Bool<span class='b'>[</span>,<span class='b'>]</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;127; ++i<span class='b'>)</span> m.add<span class='b'>(</span>i &gt; 0x20<span class='b'>)</span>
    m<span class='b'>[</span><span class='s'>'('</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>')'</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'&lt;'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'&gt;'</span><span class='b'>]</span> = <span class='k'>false</span>
    m<span class='b'>[</span><span class='s'>'@'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>','</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>';'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>':'</span><span class='b'>]</span> = <span class='k'>false</span>
    m<span class='b'>[</span><span class='s'>'\\'</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'"'</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'/'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'['</span><span class='b'>]</span> = <span class='k'>false</span>
    m<span class='b'>[</span><span class='s'>']'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'?'</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'='</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'{'</span><span class='b'>]</span> = <span class='k'>false</span>
    m<span class='b'>[</span><span class='s'>'}'</span><span class='b'>]</span>  = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>' '</span><span class='b'>]</span> = <span class='k'>false</span>;  m<span class='b'>[</span><span class='s'>'\t'</span><span class='b'>]</span> = <span class='k'>false</span>;
    tokenChars = m
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return the specified string as a HTTP quoted string according</span>
  <span class='z'>** to RFC 2616 Section 2.2.  The result is wrapped in quotes.  Throw</span>
  <span class='z'>** ArgErr if any character is outside of the ASCII range of 0x20</span>
  <span class='z'>** to 0x7e.  The quote char itself is backslash escaped.</span>
  <span class='z'>** See `fromQuotedStr`.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Str <span id='toQuotedStr'>toQuotedStr</span><span class='b'>(</span>Str s<span class='b'>)</span>
  <span class='b'>{</span>
    buf := StrBuf<span class='b'>()</span>
    buf.addChar<span class='b'>(</span><span class='s'>'"'</span><span class='b'>)</span>
    s.each |Int c|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>c &lt; 0x20 || c &gt; 0x7e<span class='b'>)</span> <span class='k'>throw</span> ArgErr<span class='b'>(</span><span class='s'>"Invalid quoted str chars: $s"</span><span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>c == <span class='s'>'"'</span><span class='b'>)</span> buf.addChar<span class='b'>(</span><span class='s'>'\\'</span><span class='b'>)</span>
      buf.addChar<span class='b'>(</span>c<span class='b'>)</span>
    <span class='b'>}</span>
    buf.addChar<span class='b'>(</span><span class='s'>'"'</span><span class='b'>)</span>
    <span class='k'>return</span> buf.toStr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Decode a HTTP quoted string according to RFC 2616 Section 2.2.</span>
  <span class='z'>** The given string must be wrapped in quotes.  See `toQuotedStr`.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Str <span id='fromQuotedStr'>fromQuotedStr</span><span class='b'>(</span>Str s<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>s.size &lt; 2 || s<span class='b'>[</span>0<span class='b'>]</span> != <span class='s'>'"'</span> || s<span class='b'>[</span>-1<span class='b'>]</span> != <span class='s'>'"'</span><span class='b'>)</span>
      <span class='k'>throw</span> ArgErr<span class='b'>(</span><span class='s'>"Not quoted str: $s"</span><span class='b'>)</span>
    <span class='k'>return</span> s<span class='b'>[</span>1..-2<span class='b'>]</span>.replace<span class='b'>(</span><span class='s'>"\\\""</span>, <span class='s'>"\""</span><span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Parsing</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Parse a list of comma separated tokens.  Any leading</span>
  <span class='z'>** or trailing whitespace is trimmed from the list of tokens.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Str<span class='b'>[]</span> <span id='parseList'>parseList</span><span class='b'>(</span>Str s<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> s.split<span class='b'>(</span><span class='s'>','</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Parse a series of HTTP headers according to RFC 2616 section</span>
  <span class='z'>** 4.2.  The final CRLF which terminates headers is consumed with</span>
  <span class='z'>** the stream positioned immediately following.  The headers are</span>
  <span class='z'>** returned as a [case insensitive]`sys::Map.caseInsensitive` map.</span>
  <span class='z'>** Throw ParseErr if headers are malformed.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Str:Str <span id='parseHeaders'>parseHeaders</span><span class='b'>(</span>InStream in<span class='b'>)</span>
  <span class='b'>{</span>
    headers := Str:Str<span class='b'>[</span>:<span class='b'>]</span>
    headers.caseInsensitive = <span class='k'>true</span>
    Str? last := <span class='k'>null</span>

    <span class='y'>// read headers into map</span>
    <span class='k'>while</span> <span class='b'>(</span><span class='k'>true</span><span class='b'>)</span>
    <span class='b'>{</span>
      peek := in.peek

      <span class='y'>// CRLF is end of headers</span>
      <span class='k'>if</span> <span class='b'>(</span>peek == CR<span class='b'>)</span> <span class='k'>break</span>

      <span class='y'>// if line starts with space it is</span>
      <span class='y'>// continuation of last header field</span>
      <span class='k'>if</span> <span class='b'>(</span>peek.isSpace &amp;&amp; last != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        headers<span class='b'>[</span>last<span class='b'>]</span> += <span class='s'>" "</span> + in.readLine.trim
        <span class='k'>continue</span>
      <span class='b'>}</span>

      <span class='y'>// key/value pair</span>
      key := token<span class='b'>(</span>in, <span class='s'>':'</span><span class='b'>)</span>.trim
      val := token<span class='b'>(</span>in, CR<span class='b'>)</span>.trim
      <span class='k'>if</span> <span class='b'>(</span>in.read != LF<span class='b'>)</span>
        <span class='k'>throw</span> ParseErr<span class='b'>(</span><span class='s'>"Invalid CRLF line ending"</span><span class='b'>)</span>

      <span class='y'>// check if key already defined in which case</span>
      <span class='y'>// this is an append, otherwise its a new pair</span>
      dup := headers<span class='b'>[</span>key<span class='b'>]</span>
      <span class='k'>if</span> <span class='b'>(</span>dup == <span class='k'>null</span><span class='b'>)</span>
        headers<span class='b'>[</span>key<span class='b'>]</span> = val
      <span class='k'>else</span>
        headers<span class='b'>[</span>key<span class='b'>]</span> = dup + <span class='s'>","</span> + val
      last = key
    <span class='b'>}</span>

    <span class='y'>// consume final CRLF</span>
    <span class='k'>if</span> <span class='b'>(</span>in.read != CR || in.read != LF<span class='b'>)</span>
      <span class='k'>throw</span> ParseErr<span class='b'>(</span><span class='s'>"Invalid CRLF headers ending"</span><span class='b'>)</span>

    <span class='k'>return</span> headers
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Read the next token from the stream up to the specified</span>
  <span class='z'>** separator. We place a limit of 512 bytes on a single token.</span>
  <span class='z'>** Consume the separate char too.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> <span class='k'>static</span> Str <span id='token'>token</span><span class='b'>(</span>InStream in, Int sep<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// read up to separator</span>
    tok := in.readStrToken<span class='b'>(</span>maxTokenSize<span class='b'>)</span> |Int ch-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> ch == sep <span class='b'>}</span>

    <span class='y'>// sanity checking</span>
    <span class='k'>if</span> <span class='b'>(</span>tok == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Unexpected end of stream"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>tok.size &gt;= maxTokenSize<span class='b'>)</span> <span class='k'>throw</span> ParseErr<span class='b'>(</span><span class='s'>"Token too big"</span><span class='b'>)</span>

    <span class='y'>// read separator</span>
    in.read

    <span class='k'>return</span> tok
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// IO</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Given a set of headers, wrap the specified input stream</span>
  <span class='z'>** to read the content body:</span>
  <span class='z'>**   1. If Content-Length then `makeFixedInStream`</span>
  <span class='z'>**   2. If Transfer-Encoding is chunked then `makeChunkedInStream`</span>
  <span class='z'>**   3. If Content-Type assume non-pipelined connection and</span>
  <span class='z'>**      return 'in' directly</span>
  <span class='z'>**   4. Assume no content and return null</span>
  <span class='z'>**</span>
  <span class='z'>** If a stream is returned, then it is automatically configured</span>
  <span class='z'>** with the correct content encoding based on the Content-Type.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> InStream? <span id='makeContentInStream'>makeContentInStream</span><span class='b'>(</span>Str:Str headers, InStream in<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// map the "Content-Type" response header to the</span>
    <span class='y'>// appropiate charset or default to UTF-8.</span>
    Charset cs := Charset.utf8
    ct := headers<span class='b'>[</span><span class='s'>"Content-Type"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>ct != <span class='k'>null</span><span class='b'>)</span> cs = MimeType<span class='b'>(</span>ct<span class='b'>)</span>.charset

    <span class='y'>// check for fixed content length</span>
    len := headers<span class='b'>[</span><span class='s'>"Content-Length"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>len != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> makeFixedInStream<span class='b'>(</span>in, len.toInt<span class='b'>)</span> <span class='b'>{</span> charset = cs <span class='b'>}</span>

    <span class='y'>// check for chunked transfer encoding</span>
    <span class='k'>if</span> <span class='b'>(</span>headers.get<span class='b'>(</span><span class='s'>"Transfer-Encoding"</span>, <span class='s'>""</span><span class='b'>)</span>.lower.contains<span class='b'>(</span><span class='s'>"chunked"</span><span class='b'>))</span>
      <span class='k'>return</span> makeChunkedInStream<span class='b'>(</span>in<span class='b'>)</span> <span class='b'>{</span> charset = cs <span class='b'>}</span>

    <span class='y'>// if content-type is specified assume open ended content until close</span>
    <span class='k'>if</span> <span class='b'>(</span>ct != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> in

    <span class='y'>// no content in response</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Given a set of headers, wrap the specified output stream</span>
  <span class='z'>** to write the content body:</span>
  <span class='z'>**   1. If Content-Length then `makeFixedOutStream`</span>
  <span class='z'>**   2. If Content-Type then set Transfer-Encoding header to</span>
  <span class='z'>**      chunked and return `makeChunkedOutStream`</span>
  <span class='z'>**   3. Assume no content and return null</span>
  <span class='z'>**</span>
  <span class='z'>** If a stream is returned, then it is automatically configured</span>
  <span class='z'>** with the correct content encoding based on the Content-Type.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> OutStream? <span id='makeContentOutStream'>makeContentOutStream</span><span class='b'>(</span>Str:Str headers, OutStream out<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// map the "Content-Type" response header to the</span>
    <span class='y'>// appropiate charset or default to UTF-8.</span>
    Charset cs := Charset.utf8
    ct := headers<span class='b'>[</span><span class='s'>"Content-Type"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>ct != <span class='k'>null</span><span class='b'>)</span> cs = MimeType<span class='b'>(</span>ct<span class='b'>)</span>.charset

    <span class='y'>// check for fixed content length</span>
    len := headers<span class='b'>[</span><span class='s'>"Content-Length"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>len != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> makeFixedOutStream<span class='b'>(</span>out, len.toInt<span class='b'>)</span> <span class='b'>{</span> charset = cs <span class='b'>}</span>

    <span class='y'>// if content-type then assumed chunked output</span>
    <span class='k'>if</span> <span class='b'>(</span>ct != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      headers<span class='b'>[</span><span class='s'>"Transfer-Encoding"</span><span class='b'>]</span> = <span class='s'>"chunked"</span>
      <span class='k'>return</span> makeChunkedOutStream<span class='b'>(</span>out<span class='b'>)</span> <span class='b'>{</span> charset = cs <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// no content</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Wrap the given input stream to read a fixed number of bytes.</span>
  <span class='z'>** Once 'fixed' bytes have been read from the underlying input</span>
  <span class='z'>** stream, the wrapped stream will return end-of-stream.  Closing</span>
  <span class='z'>** the wrapper stream does not close the underlying stream.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> InStream <span id='makeFixedInStream'>makeFixedInStream</span><span class='b'>(</span>InStream in, Int fixed<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> ChunkInStream<span class='b'>(</span>in, fixed<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Wrap the given input stream to read bytes using a HTTP</span>
  <span class='z'>** chunked transfer encoding.  The wrapped streams provides</span>
  <span class='z'>** a contiguous stream of bytes until the last chunk is read.</span>
  <span class='z'>** Closing the wrapper stream does not close the underlying stream.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> InStream <span id='makeChunkedInStream'>makeChunkedInStream</span><span class='b'>(</span>InStream in<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> ChunkInStream<span class='b'>(</span>in, <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Wrap the given output stream to write a fixed number of bytes.</span>
  <span class='z'>** Once 'fixed' bytes have been written, attempting to further</span>
  <span class='z'>** bytes will throw IOErr.  Closing the wrapper stream does not</span>
  <span class='z'>** close the underlying stream.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> OutStream <span id='makeFixedOutStream'>makeFixedOutStream</span><span class='b'>(</span>OutStream out, Int fixed<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> FixedOutStream<span class='b'>(</span>out, fixed<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Wrap the given output stream to write bytes using a HTTP</span>
  <span class='z'>** chunked transfer encoding.  Closing the wrapper stream</span>
  <span class='z'>** terminates the chunking, but does not close the underlying</span>
  <span class='z'>** stream.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> OutStream <span id='makeChunkedOutStream'>makeChunkedOutStream</span><span class='b'>(</span>OutStream out<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> ChunkOutStream<span class='b'>(</span>out<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Multi-Part Forms</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Parse a multipart/form-data input stream.  For each part in the</span>
  <span class='z'>** stream call the given callback function with the part's headers</span>
  <span class='z'>** and an input stream used to read the part's body.  Each callback</span>
  <span class='z'>** must completely drain the input stream to prepare for the next</span>
  <span class='z'>** part.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Void <span id='parseMultiPart'>parseMultiPart</span><span class='b'>(</span>InStream in, Str boundary, |Str:Str headers, InStream in| cb<span class='b'>)</span>
  <span class='b'>{</span>
    boundary = <span class='s'>"--"</span> + boundary
    line := in.readLine
    <span class='k'>if</span> <span class='b'>(</span>line == boundary + <span class='s'>"--"</span><span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>line != boundary<span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Expecting boundry line $boundary.toCode"</span><span class='b'>)</span>
    <span class='k'>while</span> <span class='b'>(</span><span class='k'>true</span><span class='b'>)</span>
    <span class='b'>{</span>
      headers := parseHeaders<span class='b'>(</span>in<span class='b'>)</span>
      partIn := MultiPartInStream<span class='b'>(</span>in, boundary<span class='b'>)</span>
      cb<span class='b'>(</span>headers, partIn<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>partIn.endOfParts<span class='b'>)</span> <span class='k'>break</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// JsMain</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Generate the method invocation code used to boostrap into</span>
  <span class='z'>** JavaScript from a webpage.  This *must* be called inside the</span>
  <span class='z'>** '&lt;head&gt;' tag for the page.  The main method will be invoked</span>
  <span class='z'>** using the 'onLoad' DOM event.</span>
  <span class='z'>**</span>
  <span class='z'>** The 'main' argument can be either a type or method.  If no</span>
  <span class='z'>** method is specified, 'main' is used.  If the method is not</span>
  <span class='z'>** static, a new instance of type is created:</span>
  <span class='z'>**</span>
  <span class='z'>**   "foo::Instance"     =&gt;  Instance().main()</span>
  <span class='z'>**   "foo::Instance.bar" =&gt;  Instance().bar()</span>
  <span class='z'>**   "foo::Static"       =&gt;  Static.main()</span>
  <span class='z'>**   "foo::Static.bar"   =&gt;  Static.bar()</span>
  <span class='z'>**</span>
  <span class='z'>** If 'env' is specified, then vars will be added to and available</span>
  <span class='z'>** from `sys::Env.vars` on client-side.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Void <span id='jsMain'>jsMain</span><span class='b'>(</span>OutStream out, Str main, <span class='b'>[</span>Str:Str<span class='b'>]</span>? env := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    envStr := StrBuf<span class='b'>()</span>
    <span class='k'>if</span> <span class='b'>(</span>env?.size &gt; 0<span class='b'>)</span>
    <span class='b'>{</span>
      envStr.add<span class='b'>(</span><span class='s'>"var env = fan.sys.Map.make(fan.sys.Str.\$type, fan.sys.Str.\$type);\n"</span><span class='b'>)</span>
      envStr.add<span class='b'>(</span><span class='s'>"env.caseInsensitive\$(true);\n"</span><span class='b'>)</span>
      env.each |v,k|
      <span class='b'>{</span>
        envStr.add<span class='b'>(</span><span class='s'>"  "</span><span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>k == <span class='s'>"sys.uriPodBase"</span><span class='b'>)</span>
          envStr.add<span class='b'>(</span><span class='s'>"fan.sys.UriPodBase = '$v';\n"</span><span class='b'>)</span>
        <span class='k'>else</span>
          envStr.add<span class='b'>(</span><span class='s'>"env.set('$k', '$v');\n"</span><span class='b'>)</span>
      <span class='b'>}</span>
      envStr.add<span class='b'>(</span><span class='s'>"fan.sys.Env.cur().\$setVars(env);\n"</span><span class='b'>)</span>
    <span class='b'>}</span>

    out.printLine<span class='b'>(</span>
     <span class='s'>"&lt;script type='text/javascript'&gt;
      //&lt;![CDATA[
      var webJsMain_hasRun = false;
      var doLoad = function()
      {
        // safari appears to have a problem calling this event
        // twice, so make sure we short-circuit if already run
        if (webJsMain_hasRun) return;
        webJsMain_hasRun = true;

        // inject env vars
        $envStr.toStr

        // find main
        var qname = '$main';
        var dot = qname.indexOf('.');
        if (dot &lt; 0) qname += '.main';
        var main = fan.sys.Slot.findMethod(qname);

        // invoke main
        if (main.isStatic()) main.call();
        else main.callOn(main.parent().make());
      }
      if (window.addEventListener)
        window.addEventListener('load', doLoad, false);
      else
        window.attachEvent('onload', doLoad);
      //]]&gt;
      &lt;/script&gt;"</span><span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='CR'>CR</span>  := <span class='s'>'\r'</span>
  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='LF'>LF</span>  := <span class='s'>'\n'</span>
  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='HT'>HT</span>  := <span class='s'>'\t'</span>
  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='SP'>SP</span>  := <span class='s'>' '</span>
  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='maxTokenSize'>maxTokenSize</span> := 4096

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ChunkInStream</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> ChunkInStream : InStream
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>InStream in, Int? fixed := <span class='k'>null</span><span class='b'>)</span> : <span class='k'>super</span><span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.in = in
    <span class='k'>this</span>.isFixed  = <span class='b'>(</span>fixed != <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>this</span>.chunkRem = <span class='b'>(</span>fixed != <span class='k'>null</span><span class='b'>)</span> ? fixed : -1
  <span class='b'>}</span>

  <span class='k'>override</span> Int? read<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback != <span class='k'>null</span> &amp;&amp; !pushback.isEmpty<span class='b'>)</span> <span class='k'>return</span> pushback.pop
    <span class='k'>if</span> <span class='b'>(</span>!checkChunk<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    chunkRem -= 1
    <span class='k'>return</span> in.read
  <span class='b'>}</span>

  <span class='k'>override</span> Int? readBuf<span class='b'>(</span>Buf buf, Int n<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback != <span class='k'>null</span> &amp;&amp; !pushback.isEmpty &amp;&amp; n &gt; 0<span class='b'>)</span>
    <span class='b'>{</span>
      buf.write<span class='b'>(</span>pushback.pop<span class='b'>)</span>
      <span class='k'>return</span> 1
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>!checkChunk<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    numRead := in.readBuf<span class='b'>(</span>buf, chunkRem.min<span class='b'>(</span>n<span class='b'>))</span>
    chunkRem -= numRead
    <span class='k'>return</span> numRead
  <span class='b'>}</span>

  <span class='k'>override</span> This unread<span class='b'>(</span>Int b<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback == <span class='k'>null</span><span class='b'>)</span> pushback = Int<span class='b'>[</span>,<span class='b'>]</span>
    pushback.push<span class='b'>(</span>b<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Bool checkChunk<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='y'>// if we have bytes remaining in this chunk return true</span>
      <span class='k'>if</span> <span class='b'>(</span>chunkRem &gt; 0<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

      <span class='y'>// if this is a single fixed "chunk" we are at end of stream</span>
      <span class='k'>if</span> <span class='b'>(</span>isFixed<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

      <span class='y'>// we expect \r\n unless this is first chunk</span>
      <span class='k'>if</span> <span class='b'>(</span>chunkRem != -1 &amp;&amp; !in.readLine.isEmpty<span class='b'>)</span> <span class='k'>throw</span> Err<span class='b'>()</span>

      <span class='y'>// read the next chunk status line</span>
      line := in.readLine
      semi := line.index<span class='b'>(</span><span class='s'>";"</span><span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>semi != <span class='k'>null</span><span class='b'>)</span> line = line<span class='b'>[</span>0..semi<span class='b'>]</span>
      chunkRem = line.toInt<span class='b'>(</span>16<span class='b'>)</span>

      <span class='y'>// if we have more chunks keep chugging,</span>
      <span class='y'>// otherwise read any trailing headers</span>
      <span class='k'>if</span> <span class='b'>(</span>chunkRem &gt; 0<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>
      WebUtil.parseHeaders<span class='b'>(</span>in<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Invalid format for HTTP chunked transfer encoding"</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"${Type.of(this).qname} { isFixed=$isFixed chunkRem=$chunkRem pushback=$pushback }"</span> <span class='b'>}</span>

  InStream in         <span class='y'>// underlying input stream</span>
  Bool isFixed        <span class='y'>// if non-null, then we're using as one fixed chunk</span>
  Int chunkRem        <span class='y'>// remaining bytes in current chunk (-1 for first chunk)</span>
  Int<span class='b'>[]</span>? pushback     <span class='y'>// stack for unread</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** FixedOutStream</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> FixedOutStream : OutStream
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>OutStream out, Int fixed<span class='b'>)</span> : <span class='k'>super</span><span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.out = out
    <span class='k'>this</span>.fixed = fixed
  <span class='b'>}</span>

  <span class='k'>override</span> This write<span class='b'>(</span>Int b<span class='b'>)</span>
  <span class='b'>{</span>
    checkChunk<span class='b'>(</span>1<span class='b'>)</span>
    out.write<span class='b'>(</span>b<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> This writeBuf<span class='b'>(</span>Buf buf, Int n := buf.remaining<span class='b'>)</span>
  <span class='b'>{</span>
    checkChunk<span class='b'>(</span>n<span class='b'>)</span>
    out.writeBuf<span class='b'>(</span>buf, n<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> This flush<span class='b'>()</span>
  <span class='b'>{</span>
    out.flush
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool close<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.flush
      <span class='k'>return</span> <span class='k'>true</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='b'>(</span>Err e<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void checkChunk<span class='b'>(</span>Int n<span class='b'>)</span>
  <span class='b'>{</span>
    written += n
    <span class='k'>if</span> <span class='b'>(</span>written &gt; fixed<span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Attempt to write more than Content-Length: $fixed"</span><span class='b'>)</span>
  <span class='b'>}</span>

  OutStream out      <span class='y'>// underlying output stream</span>
  Int? fixed         <span class='y'>// if non-null, then we're using as one fixed chunk</span>
  Int written        <span class='y'>// number of bytes written in this chunk</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ChunkOutStream</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> ChunkOutStream : OutStream
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>OutStream out<span class='b'>)</span> : <span class='k'>super</span><span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.out = out
    <span class='k'>this</span>.buffer = Buf<span class='b'>(</span>chunkSize + 256<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> This write<span class='b'>(</span>Int b<span class='b'>)</span>
  <span class='b'>{</span>
    buffer.write<span class='b'>(</span>b<span class='b'>)</span>
    checkChunk
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> This writeBuf<span class='b'>(</span>Buf buf, Int n := buf.remaining<span class='b'>)</span>
  <span class='b'>{</span>
    buffer.writeBuf<span class='b'>(</span>buf, n<span class='b'>)</span>
    checkChunk
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> This flush<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>closed<span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"ChunkOutStream is closed"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>buffer.size &gt; 0<span class='b'>)</span>
    <span class='b'>{</span>
      out.print<span class='b'>(</span>buffer.size.toHex<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span>
      out.writeBuf<span class='b'>(</span>buffer.flip, buffer.remaining<span class='b'>)</span>
      out.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span>.flush
      buffer.clear
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool close<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// never write end of chunk more than once</span>
    <span class='k'>if</span> <span class='b'>(</span>closed<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.flush
      closed = <span class='k'>true</span>
      out.print<span class='b'>(</span><span class='s'>"0\r\n\r\n"</span><span class='b'>)</span>.flush
      <span class='k'>return</span> <span class='k'>true</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void checkChunk<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>buffer.size &gt;= chunkSize<span class='b'>)</span> flush
  <span class='b'>}</span>

  <span class='k'>const</span> <span class='k'>static</span> Int chunkSize := 1024

  OutStream out    <span class='y'>// underlying output stream</span>
  Buf? buffer      <span class='y'>// buffer for bytes</span>
  Bool closed      <span class='y'>// have we written final close chunk?</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** MultiPartInStream</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> MultiPartInStream : InStream
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>InStream in, Str boundary<span class='b'>)</span> : <span class='k'>super</span><span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.in = in
    <span class='k'>this</span>.boundary = boundary
    <span class='k'>this</span>.curLine = Buf<span class='b'>(</span>1024<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Int? read<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback != <span class='k'>null</span> &amp;&amp; !pushback.isEmpty<span class='b'>)</span> <span class='k'>return</span> pushback.pop
    <span class='k'>if</span> <span class='b'>(</span>!checkLine<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    numRead += 1
    <span class='k'>return</span> curLine.read
  <span class='b'>}</span>

  <span class='k'>override</span> Int? readBuf<span class='b'>(</span>Buf buf, Int n<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback != <span class='k'>null</span> &amp;&amp; !pushback.isEmpty &amp;&amp; n &gt; 0<span class='b'>)</span>
    <span class='b'>{</span>
      buf.write<span class='b'>(</span>pushback.pop<span class='b'>)</span>
      numRead += 1
      <span class='k'>return</span> 1
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>!checkLine<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    actualRead := curLine.readBuf<span class='b'>(</span>buf, n<span class='b'>)</span>
    numRead += actualRead
    <span class='k'>return</span> actualRead
  <span class='b'>}</span>

  <span class='k'>override</span> This unread<span class='b'>(</span>Int b<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>pushback == <span class='k'>null</span><span class='b'>)</span> pushback = Int<span class='b'>[</span>,<span class='b'>]</span>
    pushback.push<span class='b'>(</span>b<span class='b'>)</span>
    numRead -= 1
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Bool checkLine<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// if we have bytes remaining in this line return true</span>
    <span class='k'>if</span> <span class='b'>(</span>curLine.remaining &gt; 0<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// if we have read boundary, then this part is complete</span>
    <span class='k'>if</span> <span class='b'>(</span>endOfPart<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// read the next line or 1000 bytes into curLine buf</span>
    curLine.clear
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;1024; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      c := in.readU1
      curLine.write<span class='b'>(</span>c<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>c == <span class='s'>'\n'</span><span class='b'>)</span> <span class='k'>break</span>
    <span class='b'>}</span>

    <span class='y'>// if not a property \r\n newline then keep chugging</span>
    <span class='k'>if</span> <span class='b'>(</span>curLine.size &lt; 2 || curLine<span class='b'>[</span>-2<span class='b'>]</span> != <span class='s'>'\r'</span><span class='b'>)</span> <span class='b'>{</span> curLine.seek<span class='b'>(</span>0<span class='b'>)</span>; <span class='k'>return</span> <span class='k'>true</span> <span class='b'>}</span>

    <span class='y'>// go ahead and keep reading as long as we have boundary match</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;boundary.size; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      c := in.readU1
      <span class='k'>if</span> <span class='b'>(</span>c != boundary<span class='b'>[</span>i<span class='b'>])</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>c == <span class='s'>'\r'</span><span class='b'>)</span> in.unread<span class='b'>(</span>c<span class='b'>)</span>
        <span class='k'>else</span> curLine.write<span class='b'>(</span>c<span class='b'>)</span>
        curLine.seek<span class='b'>(</span>0<span class='b'>)</span>
        <span class='k'>return</span> <span class='k'>true</span>
      <span class='b'>}</span>
      curLine.write<span class='b'>(</span>c<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// we have boundary match, so now figure out if end of parts</span>
    curLine.size = curLine.size - boundary.size - 2
    c1 := in.readU1
    c2 := in.readU1
    <span class='k'>if</span> <span class='b'>(</span>c1 == <span class='s'>'-'</span> &amp;&amp; c2 == <span class='s'>'-'</span><span class='b'>)</span>
    <span class='b'>{</span>
      endOfParts = <span class='k'>true</span>
      c1 = in.readU1
      c2 = in.readU1
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>c1 != <span class='s'>'\r'</span> || c2 != <span class='s'>'\n'</span><span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Fishy boundary "</span> + <span class='b'>(</span>c1.toChar + c2.toChar<span class='b'>)</span>.toCode<span class='b'>(</span><span class='s'>'"'</span>, <span class='k'>true</span><span class='b'>))</span>
    endOfPart = <span class='k'>true</span>
    curLine.seek<span class='b'>(</span>0<span class='b'>)</span>
    <span class='k'>return</span> curLine.size &gt; 0
  <span class='b'>}</span>

  InStream in
  Str boundary
  Buf curLine
  Int<span class='b'>[]</span>? pushback     <span class='y'>// stack for unread</span>
  Bool endOfPart
  Bool endOfParts
  Int numRead
<span class='b'>}</span>

</pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='WebUtil.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#CR'>CR</a></li>
  <li class='hidden' style='display: block;'><a href='#HT'>HT</a></li>
  <li class='hidden' style='display: block;'><a href='#LF'>LF</a></li>
  <li class='hidden' style='display: block;'><a href='#SP'>SP</a></li>
  <li style='display: block;'><a href='#fromQuotedStr'>fromQuotedStr</a></li>
  <li style='display: block;'><a href='#isToken'>isToken</a></li>
  <li style='display: block;'><a href='#jsMain'>jsMain</a></li>
  <li style='display: block;'><a href='#makeChunkedInStream'>makeChunkedInStream</a></li>
  <li style='display: block;'><a href='#makeChunkedOutStream'>makeChunkedOutStream</a></li>
  <li style='display: block;'><a href='#makeContentInStream'>makeContentInStream</a></li>
  <li style='display: block;'><a href='#makeContentOutStream'>makeContentOutStream</a></li>
  <li style='display: block;'><a href='#makeFixedInStream'>makeFixedInStream</a></li>
  <li style='display: block;'><a href='#makeFixedOutStream'>makeFixedOutStream</a></li>
  <li class='hidden' style='display: block;'><a href='#maxTokenSize'>maxTokenSize</a></li>
  <li style='display: block;'><a href='#parseHeaders'>parseHeaders</a></li>
  <li style='display: block;'><a href='#parseList'>parseList</a></li>
  <li style='display: block;'><a href='#parseMultiPart'>parseMultiPart</a></li>
  <li style='display: block;'><a href='#toQuotedStr'>toQuotedStr</a></li>
  <li class='hidden' style='display: block;'><a href='#token'>token</a></li>
  <li class='hidden' style='display: block;'><a href='#tokenChars'>tokenChars</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
web 1.0.56
[11-Nov-2010 Thu 10:08:21AM EST]
</p>
</div>
</div>
</body>
</html>

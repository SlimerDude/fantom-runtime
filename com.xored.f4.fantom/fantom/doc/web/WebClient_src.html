<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>web::WebClient</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>web</a></li>
  <li>&gt;</li>
  <li><a href='WebClient.html'>WebClient</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>web::WebClient</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  web::WebClient</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2008, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   24 Dec 08  Brian Frank  Almost Christmas!</span>
<span class='y'>//</span>

<span class='k'>using</span> inet

<span class='z'>**</span>
<span class='z'>** The 'WebClient' class is used to manage client side HTTP requests</span>
<span class='z'>** and responses.  The basic lifecycle of WebClient:</span>
<span class='z'>**   1. configure request fields such as 'reqUri', 'reqMethod', and 'reqHeaders'</span>
<span class='z'>**   2. send request headers via 'writeReq'</span>
<span class='z'>**   3. optionally write request body via 'reqOut'</span>
<span class='z'>**   4. read response status and headers via 'readRes'</span>
<span class='z'>**   5. process response fields such as 'resCode' and 'resHeaders'</span>
<span class='z'>**   6. optionally read response body via 'resIn'</span>
<span class='z'>**</span>
<span class='z'>** Using the low level methods 'writeReq' and 'readRes' enables HTTP</span>
<span class='z'>** pipelining (multiple requests and responses on the same TCP socket</span>
<span class='z'>** connection).  There are also a series of convenience methods which</span>
<span class='z'>** make common cases easier.</span>
<span class='z'>**</span>
<span class='z'>** See [pod doc]`pod-doc#webClient` and [examples]`examples::web-client`.</span>
<span class='z'>**</span>
<span class='k'>class</span> WebClient
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Construct with optional request URI.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Uri? reqUri := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>reqUri != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.reqUri = reqUri
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Request</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** The absolute URI of request.</span>
  <span class='z'>**</span>
  Uri <span id='reqUri'>reqUri</span> := <span class='u'>``</span>
  <span class='b'>{</span>
    set <span class='b'>{</span> <span class='k'>if</span> <span class='b'>(</span>!it.isAbs<span class='b'>)</span> <span class='k'>throw</span> ArgErr<span class='b'>(</span><span class='s'>"Request URI not absolute: `$it`"</span><span class='b'>)</span>; &amp;reqUri = it <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** The HTTP method for the request.  Defaults to "GET".</span>
  <span class='z'>**</span>
  Str <span id='reqMethod'>reqMethod</span> := <span class='s'>"GET"</span> <span class='b'>{</span> set <span class='b'>{</span> &amp;reqMethod = it.upper <span class='b'>}</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** HTTP version to use for request must be 1.0 or 1.1.</span>
  <span class='z'>** Default is 1.1.</span>
  <span class='z'>**</span>
  Version <span id='reqVersion'>reqVersion</span> := ver11

  <span class='z'>**</span>
  <span class='z'>** The HTTP headers to use for the next request.  This map uses</span>
  <span class='z'>** case insensitive keys.  The "Host" header is implicitly defined</span>
  <span class='z'>** by 'reqUri' and must not be defined in this map.</span>
  <span class='z'>**</span>
  Str:Str <span id='reqHeaders'>reqHeaders</span> := Str:Str<span class='b'>[</span>:<span class='b'>]</span> <span class='b'>{</span> caseInsensitive = <span class='k'>true</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get the output stream used to write the request body.  This</span>
  <span class='z'>** stream is only available if the request headers included a</span>
  <span class='z'>** "Content-Type" header.  If an explicit "Content-Length" was</span>
  <span class='z'>** specified then this is a fixed length output stream, otherwise</span>
  <span class='z'>** the request is automatically configured to use a chunked</span>
  <span class='z'>** transfer encoding.  This stream should be closed once the</span>
  <span class='z'>** content has been fully written.</span>
  <span class='z'>**</span>
  OutStream <span id='reqOut'>reqOut</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>reqOutStream == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"No output stream for request"</span><span class='b'>)</span>
    <span class='k'>return</span> reqOutStream
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Response</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** HTTP version returned by response.</span>
  <span class='z'>**</span>
  Version <span id='resVersion'>resVersion</span> := ver11

  <span class='z'>**</span>
  <span class='z'>** HTTP status code returned by response.</span>
  <span class='z'>**</span>
  Int <span id='resCode'>resCode</span>

  <span class='z'>**</span>
  <span class='z'>** HTTP status reason phrase returned by response.</span>
  <span class='z'>**</span>
  Str <span id='resPhrase'>resPhrase</span> := <span class='s'>""</span>

  <span class='z'>**</span>
  <span class='z'>** HTTP headers returned by response.</span>
  <span class='z'>**</span>
  Str:Str <span id='resHeaders'>resHeaders</span> := noHeaders

  <span class='z'>**</span>
  <span class='z'>** Get a response header.  If not found and checked</span>
  <span class='z'>** is false then return true, otherwise throw Err.</span>
  <span class='z'>**</span>
  Str? <span id='resHeader'>resHeader</span><span class='b'>(</span>Str key, Bool checked := <span class='k'>true</span><span class='b'>)</span>
  <span class='b'>{</span>
    val := resHeaders<span class='b'>[</span>key<span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>val != <span class='k'>null</span> || !checked<span class='b'>)</span> <span class='k'>return</span> val
    <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Missing HTTP header '$key'"</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Input stream to read response content.  The input stream</span>
  <span class='z'>** will correctly handle end of stream when the content has been</span>
  <span class='z'>** fully read.  If the "Content-Length" header was specified the</span>
  <span class='z'>** end of stream is based on the fixed number of bytes.  If the</span>
  <span class='z'>** "Transfer-Encoding" header defines a chunked encoding, then</span>
  <span class='z'>** chunks are automatically handled.  If the response has no</span>
  <span class='z'>** content body, then throw IOErr.</span>
  <span class='z'>**</span>
  <span class='z'>** The response input stream is automatically configured with</span>
  <span class='z'>** the correct character encoding if one is specified in the</span>
  <span class='z'>** "Content-Type" response header.</span>
  <span class='z'>**</span>
  <span class='z'>** Also see convenience methods: `resStr` and `resBuf`.</span>
  <span class='z'>**</span>
  InStream <span id='resIn'>resIn</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>resInStream == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"No input stream for response $resCode"</span><span class='b'>)</span>
    <span class='k'>return</span> resInStream
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return the entire response back as an in-memory string.</span>
  <span class='z'>** Convenience for 'resIn.readAllStr'.</span>
  <span class='z'>**</span>
  Str <span id='resStr'>resStr</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> resIn.readAllStr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return the entire response back as an in-memory byte buffer.</span>
  <span class='z'>** Convenience for 'resIn.readAllBuf'.</span>
  <span class='z'>**</span>
  Buf <span id='resBuf'>resBuf</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> resIn.readAllBuf
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Networking</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Socket options for the TCP socket used for requests.</span>
  <span class='z'>**</span>
  SocketOptions <span id='socketOptions'>socketOptions</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>options == <span class='k'>null</span><span class='b'>)</span> options = TcpSocket<span class='b'>()</span>.options
    <span class='k'>return</span> options
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** When set to true a 3xx response with a Location header</span>
  <span class='z'>** will automatically update the `reqUri` field and retry the</span>
  <span class='z'>** request using the alternate URI.  Redirects are not followed</span>
  <span class='z'>** if the request has a content body.</span>
  <span class='z'>**</span>
  Bool <span id='followRedirects'>followRedirects</span> := <span class='k'>true</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Get</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Make a GET request and return the response content as</span>
  <span class='z'>** an in-memory string.  The web client is automatically closed.</span>
  <span class='z'>** Throw IOErr is response is not 200.</span>
  <span class='z'>**</span>
  Str <span id='getStr'>getStr</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
      <span class='k'>return</span> getIn.readAllStr
    <span class='k'>finally</span>
      close
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Make a GET request and return the response content as</span>
  <span class='z'>** an in-memory byte buffer.  The web client is automatically closed.</span>
  <span class='z'>** Throw IOErr is response is not 200.</span>
  <span class='z'>**</span>
  Buf <span id='getBuf'>getBuf</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
      <span class='k'>return</span> getIn.readAllBuf
    <span class='k'>finally</span>
      close
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Make a GET request and return the input stream to the</span>
  <span class='z'>** response or throw IOErr if response is not 200.  It is the</span>
  <span class='z'>** caller's responsibility to close this web client.</span>
  <span class='z'>**</span>
  InStream <span id='getIn'>getIn</span><span class='b'>()</span>
  <span class='b'>{</span>
    reqMethod = <span class='s'>"GET"</span>
    writeReq
    readRes
    <span class='k'>if</span> <span class='b'>(</span>resCode != 200<span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Bad HTTP response $resCode $resPhrase"</span><span class='b'>)</span>
    <span class='k'>return</span> resIn
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Post</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Make a post request to the URI with the given form data.</span>
  <span class='z'>** Set the Content-Type to application/x-www-form-urlencoded.</span>
  <span class='z'>** Upon completion the response is ready to be read.</span>
  <span class='z'>**</span>
  This <span id='postForm'>postForm</span><span class='b'>(</span>Str:Str form<span class='b'>)</span>
  <span class='b'>{</span>
    body := Uri.encodeQuery<span class='b'>(</span>form<span class='b'>)</span>
    reqMethod = <span class='s'>"POST"</span>
    reqHeaders<span class='b'>[</span><span class='s'>"Content-Type"</span><span class='b'>]</span> = <span class='s'>"application/x-www-form-urlencoded"</span>
    reqHeaders<span class='b'>[</span><span class='s'>"Content-Length"</span><span class='b'>]</span> = body.size.toStr <span class='y'>// encoded form is ASCII</span>
    writeReq
    reqOut.print<span class='b'>(</span>body<span class='b'>)</span>.close
    readRes
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Make a post request to the URI using UTF-8 encoding of given</span>
  <span class='z'>** string.  If Content-Type is not already set, then set it</span>
  <span class='z'>** to "text/plain; charset=utf-8".  Upon completion the response</span>
  <span class='z'>** is ready to be read.</span>
  <span class='z'>**</span>
  This <span id='postStr'>postStr</span><span class='b'>(</span>Str content<span class='b'>)</span>
  <span class='b'>{</span>
    body := Buf<span class='b'>()</span>.print<span class='b'>(</span>content<span class='b'>)</span>.flip
    reqMethod = <span class='s'>"POST"</span>
    ct := reqHeaders<span class='b'>[</span><span class='s'>"Content-Type"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>ct == <span class='k'>null</span><span class='b'>)</span>
      reqHeaders<span class='b'>[</span><span class='s'>"Content-Type"</span><span class='b'>]</span> = <span class='s'>"text/plain; charset=utf-8"</span>
    reqHeaders<span class='b'>[</span><span class='s'>"Content-Length"</span><span class='b'>]</span> = body.size.toStr
    writeReq
    reqOut.writeBuf<span class='b'>(</span>body<span class='b'>)</span>.close
    readRes
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Service</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Write the request line and request headers.  Once this method</span>
  <span class='z'>** completes the request body may be written via `reqOut`, or the</span>
  <span class='z'>** response may be immediately read via `readRes`.  Throw IOErr</span>
  <span class='z'>** if there is a network or protocol error.  Return this.</span>
  <span class='z'>**</span>
  This <span id='writeReq'>writeReq</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// sanity checks</span>
    <span class='k'>if</span> <span class='b'>(</span>!reqUri.isAbs || reqUri.scheme == <span class='k'>null</span> || reqUri.host == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"reqUri is not absolute: `$reqUri`"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>!reqHeaders.caseInsensitive<span class='b'>)</span> <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"reqHeaders must be case insensitive"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>reqHeaders.containsKey<span class='b'>(</span><span class='s'>"Host"</span><span class='b'>))</span> <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"reqHeaders must not define 'Host'"</span><span class='b'>)</span>

    <span class='y'>// connect to the host:port if we aren't already connected</span>
    <span class='k'>if</span> <span class='b'>(</span>!isConnected<span class='b'>)</span>
    <span class='b'>{</span>
      socket = TcpSocket<span class='b'>()</span>
      <span class='k'>if</span> <span class='b'>(</span>options != <span class='k'>null</span><span class='b'>)</span> socket.options.copyFrom<span class='b'>(</span><span class='k'>this</span>.options<span class='b'>)</span>
      socket.connect<span class='b'>(</span>IpAddr<span class='b'>(</span>reqUri.host<span class='b'>)</span>, reqUri.port ?: 80<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// figure out if/how we are streaming out content body</span>
    out := socket.out
    reqOutStream = WebUtil.makeContentOutStream<span class='b'>(</span>reqHeaders, out<span class='b'>)</span>

    <span class='y'>// host authority header</span>
    host := reqUri.host
    <span class='k'>if</span> <span class='b'>(</span>reqUri.port != <span class='k'>null</span> &amp;&amp; reqUri.port != 80<span class='b'>)</span> host += <span class='s'>":$reqUri.port"</span>

    <span class='y'>// send request</span>
    out.print<span class='b'>(</span>reqMethod<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>" "</span><span class='b'>)</span>.print<span class='b'>(</span>reqUri.relToAuth.encode<span class='b'>)</span>
       .print<span class='b'>(</span><span class='s'>" HTTP/"</span><span class='b'>)</span>.print<span class='b'>(</span>reqVersion<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span>
    out.print<span class='b'>(</span><span class='s'>"Host: "</span><span class='b'>)</span>.print<span class='b'>(</span>host<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span>
    reqHeaders.each |Str v, Str k| <span class='b'>{</span> out.print<span class='b'>(</span>k<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>": "</span><span class='b'>)</span>.print<span class='b'>(</span>v<span class='b'>)</span>.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span> <span class='b'>}</span>
    out.print<span class='b'>(</span><span class='s'>"\r\n"</span><span class='b'>)</span>
    out.flush

    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Read the response status line and response headers.  This method</span>
  <span class='z'>** may be called after the request has been written via `writeReq`</span>
  <span class='z'>** and `reqOut`.  Once this method completes the response status and</span>
  <span class='z'>** headers are available.  If there is a response body, it is available</span>
  <span class='z'>** for reading via `resIn`.  Throw IOErr if there is a network or</span>
  <span class='z'>** protocol error.  Return this.</span>
  <span class='z'>**</span>
  This <span id='readRes'>readRes</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// read response</span>
    <span class='k'>if</span> <span class='b'>(</span>!isConnected<span class='b'>)</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Not connected"</span><span class='b'>)</span>
    in := socket.in
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='y'>// parse status-line</span>
      res := in.readLine
      <span class='k'>if</span> <span class='b'>(</span>res.startsWith<span class='b'>(</span><span class='s'>"HTTP/1.1"</span><span class='b'>))</span> resVersion = ver11
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>res.startsWith<span class='b'>(</span><span class='s'>"HTTP/1.0"</span><span class='b'>))</span> resVersion = ver10
      <span class='k'>else</span> <span class='k'>throw</span> Err<span class='b'>()</span>
      resCode = res<span class='b'>[</span>9..11<span class='b'>]</span>.toInt
      resPhrase = res<span class='b'>[</span>13..-1<span class='b'>]</span>

      <span class='y'>// parse response headers</span>
      resHeaders = WebUtil.parseHeaders<span class='b'>(</span>in<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='k'>throw</span> IOErr<span class='b'>(</span><span class='s'>"Invalid HTTP response"</span><span class='b'>)</span>

    <span class='y'>// check for redirect</span>
    checkFollowRedirect

    <span class='y'>// if there is response content, then create wrap the raw socket</span>
    <span class='y'>// input stream with the appropiate chunked input stream</span>
    resInStream = WebUtil.makeContentInStream<span class='b'>(</span>resHeaders, socket.in<span class='b'>)</span>

    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If we have a 3xx statu code with a location header,</span>
  <span class='z'>** then check for an automate redirect.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='checkFollowRedirect'>checkFollowRedirect</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// only redirect on 3xx status code</span>
    <span class='k'>if</span> <span class='b'>(</span>resCode / 100 != 3<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// must be explicitly configured for redirects</span>
    <span class='k'>if</span> <span class='b'>(</span>!followRedirects<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// only redirect when there is no request content</span>
    <span class='k'>if</span> <span class='b'>(</span>reqOutStream != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// only redirect if a location header was given</span>
    loc := resHeaders<span class='b'>[</span><span class='s'>"Location"</span><span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>loc == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// redirect</span>
    close
    newUri := Uri.decode<span class='b'>(</span>loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>!newUri.isAbs<span class='b'>)</span> newUri = reqUri + newUri
    reqUri = newUri
    writeReq
    readRes
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this web client is currently connected to the remote host.</span>
  <span class='z'>**</span>
  Bool <span id='isConnected'>isConnected</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> socket != <span class='k'>null</span> &amp;&amp; socket.isConnected
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Close the HTTP request and the underlying socket.  Return this.</span>
  <span class='z'>**</span>
  This <span id='close'>close</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>socket != <span class='k'>null</span><span class='b'>)</span> socket.close
    socket = <span class='k'>null</span>
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> <span class='k'>static</span> <span class='k'>const</span> Version <span id='ver10'>ver10</span> := Version<span class='b'>(</span><span class='s'>"1.0"</span><span class='b'>)</span>
  <span class='k'>private</span> <span class='k'>static</span> <span class='k'>const</span> Version <span id='ver11'>ver11</span> := Version<span class='b'>(</span><span class='s'>"1.1"</span><span class='b'>)</span>
  <span class='k'>private</span> <span class='k'>static</span> <span class='k'>const</span> Str:Str <span id='noHeaders'>noHeaders</span> := Str:Str<span class='b'>[</span>:<span class='b'>]</span>

  <span class='k'>private</span> InStream? <span id='resInStream'>resInStream</span>
  <span class='k'>private</span> OutStream? <span id='reqOutStream'>reqOutStream</span>
  <span class='k'>private</span> SocketOptions? <span id='options'>options</span>
  <span class='k'>private</span> TcpSocket? <span id='socket'>socket</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='WebClient.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#checkFollowRedirect'>checkFollowRedirect</a></li>
  <li style='display: block;'><a href='#close'>close</a></li>
  <li style='display: block;'><a href='#followRedirects'>followRedirects</a></li>
  <li style='display: block;'><a href='#getBuf'>getBuf</a></li>
  <li style='display: block;'><a href='#getIn'>getIn</a></li>
  <li style='display: block;'><a href='#getStr'>getStr</a></li>
  <li style='display: block;'><a href='#isConnected'>isConnected</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li class='hidden' style='display: block;'><a href='#noHeaders'>noHeaders</a></li>
  <li class='hidden' style='display: block;'><a href='#options'>options</a></li>
  <li style='display: block;'><a href='#postForm'>postForm</a></li>
  <li style='display: block;'><a href='#postStr'>postStr</a></li>
  <li style='display: block;'><a href='#readRes'>readRes</a></li>
  <li style='display: block;'><a href='#reqHeaders'>reqHeaders</a></li>
  <li style='display: block;'><a href='#reqMethod'>reqMethod</a></li>
  <li style='display: block;'><a href='#reqOut'>reqOut</a></li>
  <li class='hidden' style='display: block;'><a href='#reqOutStream'>reqOutStream</a></li>
  <li style='display: block;'><a href='#reqUri'>reqUri</a></li>
  <li style='display: block;'><a href='#reqVersion'>reqVersion</a></li>
  <li style='display: block;'><a href='#resBuf'>resBuf</a></li>
  <li style='display: block;'><a href='#resCode'>resCode</a></li>
  <li style='display: block;'><a href='#resHeader'>resHeader</a></li>
  <li style='display: block;'><a href='#resHeaders'>resHeaders</a></li>
  <li style='display: block;'><a href='#resIn'>resIn</a></li>
  <li class='hidden' style='display: block;'><a href='#resInStream'>resInStream</a></li>
  <li style='display: block;'><a href='#resPhrase'>resPhrase</a></li>
  <li style='display: block;'><a href='#resStr'>resStr</a></li>
  <li style='display: block;'><a href='#resVersion'>resVersion</a></li>
  <li class='hidden' style='display: block;'><a href='#socket'>socket</a></li>
  <li style='display: block;'><a href='#socketOptions'>socketOptions</a></li>
  <li class='hidden' style='display: block;'><a href='#ver10'>ver10</a></li>
  <li class='hidden' style='display: block;'><a href='#ver11'>ver11</a></li>
  <li style='display: block;'><a href='#writeReq'>writeReq</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
web 1.0.56
[11-Nov-2010 Thu 10:08:21AM EST]
</p>
</div>
</div>
</body>
</html>

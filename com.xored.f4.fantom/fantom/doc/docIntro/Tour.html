<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Tour</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docIntro</a></li>
  <li>&gt;</li>
  <li><a href='Tour.html'>Tour</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='StartHere.html'><img src='../go-previous.png' alt='prev' /></a> <a href='StartHere.html'>Start Here</a></div>
<div class='next'><a href='WhyFantom.html'>Why Fantom</a> <a href='WhyFantom.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Tour</h1>

<h1 id='helloWorld'>Hello World </h1>

<p>We start our whirlwind tour of Fantom's features, with the quintessential hello world:</p>

<pre>class HelloWorld
{
  static Void main()
  {
    echo("hello world")
  }
}</pre>

<p>Minor differences from Java or C# include:</p>

<ul>
<li>all type names are capitalized including <code>Void</code> (Fantom doesn't have primitives nor primitive keywords).</li>

<li>Class and method protection scope default to <code>public</code>.</li>

<li>Fantom sports the <code>echo</code> method for writing to the console or you can use <code>Env.cur.out</code>.</li>

<li>Statements can be terminated with a newline (you can use a semicolon too)</li>

<li>You can declare <code>Str[]</code> args or access them from <code>Env.args</code></li>
</ul>

<h1 id='literals'>Literals </h1>

<p>Fantom supports the same primitive <a href='../docLang/Literals.html'>literals</a> as Java or C#, plus some that are typically found in higher level scripting languages:</p>

<pre>true                // Bool literal
123                 // Int literal
0xcafe_babe         // Int hex, can use _ as separator
'\n'                // Int character literal
"hi"                // Str literal
3.4f                // Float literal
3.4d                // Decimal literal
5sec                // Duration literal
`/dir/file.txt`     // Uri literal
[0, 1, 2]           // List literal
[,]                 // List literal for empty list
[1:"one", 2:"two"]  // Map literal
[:]                 // Map literal for empty map
Int#                // Type literal
Int#plus            // Slot literal</pre>

<h1 id='expressions'>Expressions </h1>

<p>Fantom reuses most the same <a href='../docLang/Expressions.html'>expression</a> syntax as Java and C#:</p>

<pre>obj.toStr()   // call the toStr method
obj.toStr     // parenthesis are optional
obj.field     // access field
x &amp;&amp; y        // logical and
x === y       // reference equality
x == y        // shortcut for x.equals(y)
x &lt; y         // shortcut for x.compare(y) &lt; 0
x &lt;=> y       // shortcut for x.compare(y)
x + y         // shortcut for x.plus(y)
x = y         // assignment
a ? b : c     // ternary operator
a is Str      // instance of operator
a isnot Str   // convenience for !(a is Str)
a as Str      // like C# as operator
a?.func()     // safe invoke operator (like Groovy)
a ?: b        // elvis operator for a != null ? a : b</pre>

<p>Most operators are actually just syntax sugar for a method call.  For example:</p>

<pre>3 + 4  =>  3.plus(4)</pre>

<h1 id='strings'>Strings </h1>

<p>Strings support <a href='../docLang/Literals.html#str'>interpolation</a> which allows you to embed expressions via the "$" character:</p>

<pre>// string interpolation
"$x + $y = ${x+y}"

// longhand for above
x.toStr + " + " + y.toStr + " = " + (x+y).toStr</pre>

<p>A simple variable or dotted expression can just be prefixed with "$", but more complicated expressions are wrapped in curly braces.</p>

<h1 id='statements'>Statements </h1>

<p><a href='../docLang/Statements.html'>Statements</a> are mostly like Java and C#:</p>

<pre>Str s := "hello"    // local variable declaration
s := "hello"        // type inference
if (x) {} else {}   // if/else statement
while (x) {}        // while</pre>

<p>The most noticeable difference is the use of <code>:=</code> to declare a local variable.  Fantom uses type inference, so you can omit a local's type declaration.  The <code>:=</code> operator is used instead of <code>=</code> to show the intention of declaration versus assignment.  It prevents silly mistakes like variable name typos.</p>

<h1 id='fields'>Fields </h1>

<p><a href='../docLang/Fields.html'>Fields</a> automatically include support for accessor methods without a lot of verbosity:</p>

<pre>class Person
{
  Str name
  Int age
}</pre>

<p>The code above is basically equivalent to this Java code:</p>

<pre>public class Person
{
  public String name() { return name; }
  public void name(String x) { name = x; }

  public int age() { return age; }
  public void age(int x) { age = x; }

  private String name;
  private int age;
}</pre>

<p>The reason Java and C# programmers write such tortured code is on the off-chance that they want to trap when a field is get or set.  In Fantom, fields are always accessed via an auto-generated getter or setter which you can override:</p>

<pre>class Person
{
  Str name
  Int age { set { checkAge(val); &amp;age = it } }
}</pre>

<p>The <code>it</code> keyword denotes the value being used to set the field.  The syntax <code>&amp;age</code> denotes that we are setting the actual storage location for the age field (not using the setter).</p>

<h1 id='methods'>Methods </h1>

<p><a href='../docLang/Methods.html'>Method</a> arguments can have default values:</p>

<pre>class Person
{
  Int yearsToRetirement(Int retire := 65) { return retire - age }

  Int age
}</pre>

<p><a href='../docLang/Methods.html#once'>Once methods</a> only compute their result the first time they are called and then return a cached value on subsequent calls:</p>

<pre>once Str fullName() { return "$firstName  $lastName" }</pre>

<h1 id='ctor'>Constructors </h1>

<p>One thing different about Fantom is that <a href='../docLang/Methods.html#ctor'>constructors</a> are named methods:</p>

<pre>class Point
{
  new make(Int x, Int y) { this.x = x; this.y = y; }
  Int x
  Int y
}

// make a point
pt := Point.make(30, 40)   // longhand
pt := Point(30, 40)        // shorthand</pre>

<p>By convention, the primary constructor is called <code>make</code> and other constructors are prefixed with "make".  If you don't provide a constructor, the compiler will auto-generate one for you called <code>make</code>.</p>

<h1 id='inheritance'>Inheritance </h1>

<p>The syntax for <a href='../docLang/Inheritance.html'>inheritance</a> looks just like C#:</p>

<pre>class Animal
{
  virtual Void talk() { echo("talk") }
}

class Dog : Animal
{
  override Void talk() { echo("bark") }
}</pre>

<p>Note the use of <code>virtual</code> and <code>override</code> keywords.  Unlike Java methods must be explicitly marked virtual - you have to design for a method to be overridden.</p>

<h1 id='mixins'>Mixins </h1>

<p>Java and C# use interfaces to implement multiple type inheritance. Fantom <a href='../docLang/Mixins.html'>mixins</a> are like interfaces but can declare method implementations:</p>

<pre>mixin Audio
{
  abstract Int volume
  Void incrementVolume() { volume += 1 }
  Void decrementVolume() { volume -= 1 }
}

class Television : Audio
{
  override Int volume := 0
}</pre>

<p>The best way to explain what the Fantom code does above is to map it to its Java equivalent:</p>

<pre>interface Audio
{
  int volume();
  void volume(int volume);
  void incrementVolume();
  void decrementVolume();
}

class AudioImpl
{
  static void incrementVolume(Audio self) { self.volume(self.volume() + 1); }
  static void decrementVolume(Audio self) { self.volume(self.volume() - 1); }
}

class Television implements Audio
{
  int volume() { return volume; }
  void volume(int x) { volume = x; }

  void incrementVolume() { AudioImpl.incrementVolume(this); }
  void decrementVolume() { AudioImpl.incrementVolume(this); }

  private int volume = 0;
}</pre>

<p>Notice the use of an abstract field.  Like interfaces, a mixin can't actually contain any state.  But mixins can declare abstract fields which define getters and setters, but no actual storage.</p>

<h1 id='closures'>Closures </h1>

<p>Fantom supports first class <a href='../docLang/Functions.html'>functions</a> and <a href='../docLang/Closures.html'>closures</a> - the standard APIs make heavy use of functional programming.  Closure syntax kind of, sort of looks like Ruby.  For example iteration over collections is almost always done using closures:</p>

<pre>// print a list of strings
list := ["red", "yellow", "orange"]
list.each |Str color| { echo(color) }

// print 0 to 9
10.times |Int i| { echo(i) }</pre>

<p>The signature of a closure function can be <a href='../docLang/Closures.html#typeInference'>inferred</a> from its context:</p>

<pre>10.times |i| { echo(i) }</pre>

<p><a href='../docLang/Closures.html#itBlocks'>It-blocks</a> are a special form of closure with an implied parameter of <code>it</code>:</p>

<pre>10.times { echo(it) }</pre>

<p>Closures are also used to pass chunks of code into standard methods:</p>

<pre>// sort a list of files by timestamp
files = files.sort |a, b| { a.modified &lt;=> b.modified }</pre>

<p>Closures are really just an expression that creates a <code><a href='../sys/Func.html'>Func</a></code> instance:</p>

<pre>// create a function that adds two integers
add := |Int a, Int b->Int| { return a + b }
nine := add(4, 5)</pre>

<h1 id='dynamic'>Dynamic Programming </h1>

<p>Fantom provides some key features to break free from the shackles of strong typing when needed.  When you access a field or method using the "." dot operator the compiler does type checking. But you can also use the "->" dynamic call operator to skip type checking:</p>

<pre>obj->foo         // obj.trap("foo", [,])
obj->foo(2, 3)   // obj.trap("foo", [2, 3])
obj->foo = 7     // obj.trap("foo", [7])</pre>

<p>The "->" operator is really just syntax sugar for invoking the <code>Obj.trap</code> method which by default uses reflection to call a method or access a field.  But you can also override the <code>trap</code> method to handle dynamic calls in imaginative ways.</p>

<p>Another feature to make dynamic programming nice is the use of <code>Obj</code> as a wildcard.  You can assign <code>Obj</code> to anything or pass it to a method call without an explicit cast:</p>

<pre>Obj obj
Str s := obj->foo     // Str s := (Str)obj->foo
Int.fromStr(obj)      // Int.fromStr((Str)obj)</pre>

<h1 id='nullableTypes'>Nullable Types </h1>

<p>Types may be nullable or non-nullable. A non-nullable type is guaranteed to never store the null value. Nullable types are indicated with a trailing "?". This means non-nullable is the default unless otherwise specified:</p>

<pre>Str   // never stores null
Str?  // might store null</pre>

<p>The compiler prevents obvious mistakes like using the <code>null</code> literal when a non-nullable type is expected.  Additional checks are implicitly done at runtime when coercing a nullable type to a non-nullable type. This allows your code to fail fast at the point where null bug was introduced versus propagating into unrelated code.</p>

<h1 id='serialization'>Serialization </h1>

<p>The <a href='../docLang/Serialization.html'>serialization</a> syntax of Fantom is a subset of the actual programming language.  This means you use serialization to build up arbitrarily complex object structures in code.  Plus it makes serialized objects easy for us humans to read and write:</p>

<pre>@serializable class Person
{
  Str name
  Int age
  Person[]? children
}

// built up tree of objects in code (or from file)
homer := Person
{
  name = "Homer Simpson"
  age  = 39
  children =
  [
    Person { name = "Bart";   age = 7 },
    Person { name = "Lisa";   age = 5 },
    Person { name = "Maggie"; age = 1 }
  ]
}

// dump serialized structure to console
Env.cur.out.writeObj(homer, ["indent":2])</pre>

<h1 id='immutability'>Immutability </h1>

<p>Classes may be declared <code>const</code> to create <a href='../docLang/Concurrency.html#immutability'>immutable</a> classes:</p>

<pre>const class Point
{
  new make(Int x, Int y) { this.x = x; this.y = y }
  const Int x
  const Int y
}</pre>

<p>Const classes contain only fields which are themselves const and set in the constructor.  To prevent threads from sharing state, static fields must always be const:</p>

<pre>const static Point origin := Point(0, 0)</pre>

<p>Lists and Maps can be declared immutable using the <code>toImmutable</code> method:</p>

<pre>vowels := ['a','e','i','o','u'].toImmutable</pre>

<h1 id='actors'>Actors </h1>

<p>Fantom includes an <a href='../docLang/Actors.html'>actor framework</a> for building concurrent applications:</p>

<pre>// spawn actor which aynchronously increments an Int msg
actor := Actor(group) |Int msg->Int| { msg + 1 }

// send some messages to the actor and block for result
for (i:=0; i&lt;5; ++i) echo(actor.send(i).get)</pre>
<div class='prevNext'>
<div class='prev'><a href='StartHere.html'><img src='../go-previous.png' alt='prev' /></a> <a href='StartHere.html'>Start Here</a></div>
<div class='next'><a href='WhyFantom.html'>Why Fantom</a> <a href='WhyFantom.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#helloWorld'>Hello World </a></li><li><a href='#literals'>Literals </a></li><li><a href='#expressions'>Expressions </a></li><li><a href='#strings'>Strings </a></li><li><a href='#statements'>Statements </a></li><li><a href='#fields'>Fields </a></li><li><a href='#methods'>Methods </a></li><li><a href='#ctor'>Constructors </a></li><li><a href='#inheritance'>Inheritance </a></li><li><a href='#mixins'>Mixins </a></li><li><a href='#closures'>Closures </a></li><li><a href='#dynamic'>Dynamic Programming </a></li><li><a href='#nullableTypes'>Nullable Types </a></li><li><a href='#serialization'>Serialization </a></li><li><a href='#immutability'>Immutability </a></li><li><a href='#actors'>Actors </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docIntro 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

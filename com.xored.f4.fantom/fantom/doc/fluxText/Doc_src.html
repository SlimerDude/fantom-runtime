<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>fluxText::Doc</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>fluxText</a></li>
  <li>&gt;</li>
  <li><a href='Doc.html'>Doc</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>fluxText::Doc</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='../fwt/RichTextModel.html'>fwt::RichTextModel</a>
    fluxText::Doc</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2008, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   30 Jul 08  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='k'>using</span> gfx
<span class='k'>using</span> fwt
<span class='k'>using</span> flux

<span class='z'>**</span>
<span class='z'>** Doc is the model for text edited in a `TextEditor`</span>
<span class='z'>**</span>
<span class='k'>class</span> Doc : RichTextModel
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Construction</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>TextEditorOptions options, SyntaxOptions syntax, SyntaxRules rules<span class='b'>)</span>
  <span class='b'>{</span>
    lines.add<span class='b'>(</span>Line <span class='b'>{</span> it.offset=0; it.text=<span class='s'>""</span> <span class='b'>})</span>
    <span class='k'>this</span>.options   = options
    <span class='k'>this</span>.syntax    = syntax
    <span class='k'>this</span>.rules     = rules
    <span class='k'>this</span>.parser    = Parser<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>
    <span class='k'>this</span>.delimiter = options.lineDelimiter
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// RichTextModel</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Str <span id='text'>text</span>
  <span class='b'>{</span>
    get <span class='b'>{</span> <span class='k'>return</span> lines.join<span class='b'>(</span>delimiter<span class='b'>)</span> |Line line-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> line.text <span class='b'>}</span> <span class='b'>}</span>
    set <span class='b'>{</span> modify<span class='b'>(</span>0, size, it<span class='b'>)</span> <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Int <span id='charCount'>charCount</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> size <span class='b'>}</span>

  <span class='k'>override</span> Int <span id='lineCount'>lineCount</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> lines.size <span class='b'>}</span>

  <span class='k'>override</span> Str <span id='line'>line</span><span class='b'>(</span>Int lineIndex<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> lines<span class='b'>[</span>lineIndex<span class='b'>]</span>.text <span class='b'>}</span>

  <span class='k'>override</span> Int <span id='offsetAtLine'>offsetAtLine</span><span class='b'>(</span>Int lineIndex<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> lines<span class='b'>[</span>lineIndex<span class='b'>]</span>.offset <span class='b'>}</span>

  <span class='k'>override</span> Int <span id='lineAtOffset'>lineAtOffset</span><span class='b'>(</span>Int offset<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// binary search by offset, returns '-insertationPoint-1'</span>
    key := Line <span class='b'>{</span> it.offset = offset <span class='b'>}</span>
    line := lines.binarySearch<span class='b'>(</span>key<span class='b'>)</span> |Line a, Line b-&gt;Int| <span class='b'>{</span> <span class='k'>return</span> a.offset &lt;=&gt; b.offset <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>line &lt; 0<span class='b'>)</span> line = -<span class='b'>(</span>line + 2<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>line &gt;= lines.size<span class='b'>)</span> line = lines.size-1
    <span class='k'>return</span> line
  <span class='b'>}</span>

  <span class='k'>override</span> Void <span id='modify'>modify</span><span class='b'>(</span>Int startOffset, Int len, Str newText<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// compute the lines being replaced</span>
    endOffset      := startOffset + len
    startLineIndex := lineAtOffset<span class='b'>(</span>startOffset<span class='b'>)</span>
    endLineIndex   := lineAtOffset<span class='b'>(</span>endOffset<span class='b'>)</span>
    startLine      := lines<span class='b'>[</span>startLineIndex<span class='b'>]</span>
    endLine        := lines<span class='b'>[</span>endLineIndex<span class='b'>]</span>
    oldText        := textRange<span class='b'>(</span>startOffset, len<span class='b'>)</span>

    <span class='y'>// sample styles before insert</span>
    samplesBefore := <span class='b'>[</span> lineStyling<span class='b'>(</span>endLineIndex+1<span class='b'>)</span>, lineStyling<span class='b'>(</span>lines.size-1<span class='b'>)</span> <span class='b'>]</span>

    <span class='y'>// compute the new text of the lines being replaced</span>
    offsetInStart := startOffset - startLine.offset
    offsetInEnd   := endOffset - endLine.offset
    newLinesText  := startLine.text<span class='b'>[</span>0..&lt;offsetInStart<span class='b'>]</span> + newText + endLine.text<span class='b'>[</span>offsetInEnd..-1<span class='b'>]</span>

    <span class='y'>// split new text into new lines</span>
    newLines := Line<span class='b'>[</span>,<span class='b'>]</span> <span class='b'>{</span> capacity=32 <span class='b'>}</span>
    newLinesText.splitLines.each |Str s|
    <span class='b'>{</span>
      newLines.add<span class='b'>(</span>parser.parseLine<span class='b'>(</span>s<span class='b'>))</span>
    <span class='b'>}</span>

    <span class='y'>// merge in new lines</span>
    lines.removeRange<span class='b'>(</span>startLineIndex..endLineIndex<span class='b'>)</span>
    lines.insertAll<span class='b'>(</span>startLineIndex, newLines<span class='b'>)</span>

    <span class='y'>// update total size, line offsets, and multi-line comments/strings</span>
    updateLines<span class='b'>(</span>lines<span class='b'>)</span>

    <span class='y'>// sample styles after insert</span>
    samplesAfter := <span class='b'>[</span> lineStyling<span class='b'>(</span>startLineIndex+newLines.size<span class='b'>)</span>, lineStyling<span class='b'>(</span>lines.size-1<span class='b'>)</span> <span class='b'>]</span>
    repaintToEnd := samplesBefore != samplesAfter

    <span class='y'>// fire modification event</span>
    tc := TextChange
    <span class='b'>{</span>
      it.startOffset    = startOffset
      it.startLine      = startLineIndex
      it.oldText        = oldText
      it.newText        = newText
      it.oldNumNewlines = oldText.numNewlines
      it.newNumNewlines = newLines.size - 1
      it.repaintLen     = repaintToEnd ? size-startOffset : <span class='k'>null</span>
    <span class='b'>}</span>
    onModify.fire<span class='b'>(</span>Event <span class='b'>{</span> id =EventId.modified; data = tc <span class='b'>})</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Walk all the lines:</span>
  <span class='z'>**   - update offset</span>
  <span class='z'>**   - update total size</span>
  <span class='z'>**   - compute style override for block comments</span>
  <span class='z'>**   - compute style override for multiline strings</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='updateLines'>updateLines</span><span class='b'>(</span>Line<span class='b'>[]</span> lines<span class='b'>)</span>
  <span class='b'>{</span>
    n := 0
    lastIndex := lines.size-1
    delimiterSize := delimiter.size
    commentLevel := 0
    commentMin := rules.blockCommentsNest ? 100 : 1
    inStr := <span class='k'>false</span>

    <span class='y'>// walk the lines</span>
    Block? block := <span class='k'>null</span>
    lines.each |Line line, Int i|
    <span class='b'>{</span>
      <span class='y'>// update offset and total running size</span>
      line.offset = n
      n += line.text.size
      <span class='k'>if</span> <span class='b'>(</span>i != lastIndex<span class='b'>)</span> n += delimiterSize

      <span class='y'>// update comment nesting count</span>
      commentLevel = <span class='b'>(</span>commentLevel + line.commentNesting<span class='b'>)</span>.max<span class='b'>(</span>0<span class='b'>)</span>.min<span class='b'>(</span>commentMin<span class='b'>)</span>

      <span class='y'>// if not inside a multi-line block, then the current line</span>
      <span class='y'>// decides if opening if a new multi-line block (or null);</span>
      <span class='y'>// otherwise this line either closes the current open block</span>
      <span class='y'>// or is inside the block</span>
      <span class='k'>if</span> <span class='b'>(</span>block == <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        line.stylingOverride = <span class='k'>null</span>
        block = line.opens
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        Line? closes := line.closes<span class='b'>(</span>block<span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>closes == <span class='k'>null</span> || commentLevel &gt; 0<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='y'>// override this line as str/comment block</span>
          line.stylingOverride = block.stylingOverride
        <span class='b'>}</span>
        <span class='k'>else</span>
        <span class='b'>{</span>
          <span class='y'>// close the current block, and re-parse line appropriately</span>
          line.stylingOverride = closes.styling
          block = closes.opens
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// update total size</span>
    size = n
  <span class='b'>}</span>

  <span class='k'>override</span> Obj<span class='b'>[]</span>? <span id='lineStyling'>lineStyling</span><span class='b'>(</span>Int lineIndex<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='y'>// get configured styling</span>
      line := lines<span class='b'>[</span>lineIndex<span class='b'>]</span>
      styling := line.stylingOverride ?: line.styling

      <span class='y'>// apply bracket styling if current line is matched brackets</span>
      <span class='k'>if</span> <span class='b'>(</span>lineIndex == bracketLine1 || lineIndex == bracketLine2<span class='b'>)</span>
      <span class='b'>{</span>
        styling = styling.dup
        lineLen := line.text.size
        <span class='k'>if</span> <span class='b'>(</span>lineIndex == bracketLine1<span class='b'>)</span> insertBracketMatch<span class='b'>(</span>styling, bracketCol1, lineLen<span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>lineIndex == bracketLine2<span class='b'>)</span> insertBracketMatch<span class='b'>(</span>styling, bracketCol2, lineLen<span class='b'>)</span>
      <span class='b'>}</span>

      <span class='k'>return</span> styling
    <span class='b'>}</span>
    <span class='k'>catch</span>
    <span class='b'>{</span>
      <span class='k'>return</span> <span class='k'>null</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Color? <span id='lineBackground'>lineBackground</span><span class='b'>(</span>Int lineIndex<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>lineIndex == caretLine<span class='b'>)</span>
      <span class='k'>return</span> syntax.highlightCurLine
    <span class='k'>else</span>
      <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Insert a bracket match style run of one character</span>
  <span class='z'>** at the specified offset.  There are four cases where</span>
  <span class='z'>** "xxx" is run, and "^" is insertion point:</span>
  <span class='z'>**</span>
  <span class='z'>**     x      a) replace single char run</span>
  <span class='z'>**   xxx      b) insert at end</span>
  <span class='z'>**     xxx    c) move run to right one char, insert</span>
  <span class='z'>**   xxxxx    d) breaking middle of run</span>
  <span class='z'>**     ^</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='insertBracketMatch'>insertBracketMatch</span><span class='b'>(</span>Obj<span class='b'>[]</span> styling, Int offset, Int lineLen<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// find insert point in styling list;</span>
    i := 0; Int iOffset := 0; RichTextStyle iStyle := styling<span class='b'>[</span>1<span class='b'>]</span>
    <span class='k'>for</span> <span class='b'>(</span>; i&lt;styling.size; i+=2<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>styling<span class='b'>[</span>i<span class='b'>]</span> &gt;= offset<span class='b'>)</span> <span class='k'>break</span>
      iStyle = styling<span class='b'>[</span>i+1<span class='b'>]</span>
    <span class='b'>}</span>
    iOffset = i&lt;styling.size ? styling<span class='b'>[</span>i<span class='b'>]</span> : lineLen

    <span class='y'>// compute remaining chars in run</span>
    left := lineLen - offset - 1
    <span class='k'>if</span> <span class='b'>(</span>i+2&lt;styling.size<span class='b'>)</span>
      left = <span class='b'>((</span>Int<span class='b'>)</span>styling<span class='b'>[</span>i+2<span class='b'>])</span> - offset - 1

    <span class='y'>// a) if we are replacing a single char run</span>
    <span class='k'>if</span> <span class='b'>(</span>offset == iOffset &amp;&amp; left == 0<span class='b'>)</span>
    <span class='b'>{</span>
      styling<span class='b'>[</span>i+1<span class='b'>]</span> = syntax.bracketMatch
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// b) if end of run, insert only</span>
    <span class='k'>if</span> <span class='b'>(</span>left == 0<span class='b'>)</span>
    <span class='b'>{</span>
      styling.insert<span class='b'>(</span>i, syntax.bracketMatch<span class='b'>)</span>
      styling.insert<span class='b'>(</span>i, offset<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// c) if starting a run of more than one character</span>
    <span class='k'>if</span> <span class='b'>(</span>offset == iOffset<span class='b'>)</span>
    <span class='b'>{</span>
      styling<span class='b'>[</span>i<span class='b'>]</span> = offset+1  <span class='y'>// move to left one char</span>
      styling.insert<span class='b'>(</span>i, syntax.bracketMatch<span class='b'>)</span>
      styling.insert<span class='b'>(</span>i, offset<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// d) we are breaking the middle of run</span>
    styling.insert<span class='b'>(</span>i, iStyle<span class='b'>)</span>
    styling.insert<span class='b'>(</span>i, offset+1<span class='b'>)</span>
    styling.insert<span class='b'>(</span>i, syntax.bracketMatch<span class='b'>)</span>
    styling.insert<span class='b'>(</span>i, offset<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// IO</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Load fresh document already parsed into lines.</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> Void <span id='load'>load</span><span class='b'>(</span>Str<span class='b'>[]</span> strLines<span class='b'>)</span>
  <span class='b'>{</span>
    lines = Line<span class='b'>[</span>,<span class='b'>]</span> <span class='b'>{</span> capacity = strLines.size + 100 <span class='b'>}</span>
    strLines.each |Str str|
    <span class='b'>{</span>
      lines.add<span class='b'>(</span>parser.parseLine<span class='b'>(</span>str<span class='b'>))</span>
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>lines.isEmpty<span class='b'>)</span> lines.add<span class='b'>(</span>parser.parseLine<span class='b'>(</span><span class='s'>""</span><span class='b'>))</span>
    updateLines<span class='b'>(</span>lines<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Save document to output stream (we assume charset</span>
  <span class='z'>** is already configured).</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> Void <span id='save'>save</span><span class='b'>(</span>OutStream out<span class='b'>)</span>
  <span class='b'>{</span>
    stripws := options.stripTrailingWhitespace
    delimiter := <span class='k'>this</span>.delimiter
    lastLine := lines.size-1
    lines.each |Line line, Int i|
    <span class='b'>{</span>
      text := line.text
      <span class='k'>if</span> <span class='b'>(</span>stripws<span class='b'>)</span> text = text.trimEnd
      out.print<span class='b'>(</span>text<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>i != lastLine || text.isEmpty<span class='b'>)</span> out.print<span class='b'>(</span>delimiter<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Utils</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Find the specified string in the document starting the</span>
  <span class='z'>** search at the document offset and looking forward.</span>
  <span class='z'>** Return null is not found.  Note we don't currently</span>
  <span class='z'>** support searching across multiple lines.</span>
  <span class='z'>**</span>
  Int? <span id='findNext'>findNext</span><span class='b'>(</span>Str s, Int offset, Bool matchCase<span class='b'>)</span>
  <span class='b'>{</span>
    offset = offset.max<span class='b'>(</span>0<span class='b'>)</span>.min<span class='b'>(</span>size<span class='b'>)</span>
    lineIndex := lineAtOffset<span class='b'>(</span>offset<span class='b'>)</span>
    offsetInLine := offset - lines<span class='b'>[</span>lineIndex<span class='b'>]</span>.offset

    <span class='k'>while</span> <span class='b'>(</span>lineIndex &lt; lines.size<span class='b'>)</span>
    <span class='b'>{</span>
      line := lines<span class='b'>[</span>lineIndex<span class='b'>]</span>
      r := matchCase ?
        line.text.index<span class='b'>(</span>s, offsetInLine<span class='b'>)</span> :
        line.text.indexIgnoreCase<span class='b'>(</span>s, offsetInLine<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>r != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> line.offset+r
      offsetInLine = 0 <span class='y'>// after first line we always start at zero</span>
      lineIndex++
    <span class='b'>}</span>

    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Find the specified string in the document starting the</span>
  <span class='z'>** search at the document offset and looking backward.</span>
  <span class='z'>** Return null is not found.  Note we don't currently</span>
  <span class='z'>** support searching across multiple lines.</span>
  <span class='z'>**</span>
  Int? <span id='findPrev'>findPrev</span><span class='b'>(</span>Str s, Int offset, Bool matchCase<span class='b'>)</span>
  <span class='b'>{</span>
    offset = offset.max<span class='b'>(</span>0<span class='b'>)</span>.min<span class='b'>(</span>size<span class='b'>)</span>
    lineIndex := lineAtOffset<span class='b'>(</span>offset<span class='b'>)</span>
    offsetInLine := offset - lines<span class='b'>[</span>lineIndex<span class='b'>]</span>.offset

    <span class='k'>while</span> <span class='b'>(</span>lineIndex &gt;= 0<span class='b'>)</span>
    <span class='b'>{</span>
      line := lines<span class='b'>[</span>lineIndex<span class='b'>]</span>
      r := matchCase ?
        line.text.indexr<span class='b'>(</span>s, offsetInLine<span class='b'>)</span> :
        line.text.indexrIgnoreCase<span class='b'>(</span>s, offsetInLine<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>r != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> line.offset+r
      offsetInLine = -1 <span class='y'>// after first line we always start at end</span>
      lineIndex--
    <span class='b'>}</span>

    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Highlight all the marks found in this document.</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> Void <span id='updateMarks'>updateMarks</span><span class='b'>(</span>Mark<span class='b'>[]</span> marks<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// TODO</span>
    <span class='y'>//echo("-- Doc.updateMarks --")</span>
    <span class='y'>//marks.each |Mark m| { echo(m) }</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Attempt to find the matching bracket the specified</span>
  <span class='z'>** offset.  If the bracket is an opening bracket then</span>
  <span class='z'>** we search forward for the closing bracket taking into</span>
  <span class='z'>** account nesting.  If a closing bracket we search backward.</span>
  <span class='z'>** Return null if no match.</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> Int? <span id='matchBracket'>matchBracket</span><span class='b'>(</span>Int offset<span class='b'>)</span>
  <span class='b'>{</span>
    lineIndex := lineAtOffset<span class='b'>(</span>offset<span class='b'>)</span>
    line := lines<span class='b'>[</span>lineIndex<span class='b'>]</span>
    offsetInLine := offset-line.offset

    <span class='y'>// get matched pair</span>
    a := line.text<span class='b'>[</span>offsetInLine<span class='b'>]</span>
    b := bracketPairs<span class='b'>[</span>a<span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>b == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>

    forward := a &lt; b
    nesting := 0

    <span class='k'>while</span> <span class='b'>(</span><span class='k'>true</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>line.text<span class='b'>[</span>offsetInLine<span class='b'>]</span> == a<span class='b'>)</span> ++nesting
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>line.text<span class='b'>[</span>offsetInLine<span class='b'>]</span> == b<span class='b'>)</span> --nesting
      <span class='k'>if</span> <span class='b'>(</span>nesting == 0<span class='b'>)</span> <span class='k'>return</span> offset

      <span class='k'>if</span> <span class='b'>(</span>forward<span class='b'>)</span>
      <span class='b'>{</span>
        offset++; offsetInLine++
        <span class='k'>while</span> <span class='b'>(</span>offsetInLine &gt;= line.text.size<span class='b'>)</span>
        <span class='b'>{</span>
          lineIndex++; offset += delimiter.size
          <span class='k'>if</span> <span class='b'>(</span>lineIndex &gt;= lines.size<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
          line = lines<span class='b'>[</span>lineIndex<span class='b'>]</span>; offsetInLine = 0
        <span class='b'>}</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        offset--; offsetInLine--
        <span class='k'>while</span> <span class='b'>(</span>offsetInLine &lt; 0<span class='b'>)</span>
        <span class='b'>{</span>
          lineIndex--; offset -= delimiter.size
          <span class='k'>if</span> <span class='b'>(</span>lineIndex &lt; 0<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
          line = lines<span class='b'>[</span>lineIndex<span class='b'>]</span>; offsetInLine = line.text.size-1
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Set the two current matching bracket positions.</span>
  <span class='z'>** These will get styled specially.  It is up to the</span>
  <span class='z'>** caller to repaint the dirty lines.</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> Void <span id='setBracketMatch'>setBracketMatch</span><span class='b'>(</span>Int line1, Int col1, Int line2, Int col2<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>line1 &lt; line2 || col1 &lt; col2<span class='b'>)</span>
    <span class='b'>{</span>
      bracketLine1 = line1; bracketCol1 = col1
      bracketLine2 = line2; bracketCol2 = col2
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      bracketLine1 = line2; bracketCol1 = col2
      bracketLine2 = line1; bracketCol2 = col1
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>internal</span> <span class='k'>const</span> <span class='k'>static</span> Int:Int <span id='bracketPairs'>bracketPairs</span>
  <span class='k'>static</span>
  <span class='b'>{</span>
    m := Int:Int<span class='b'>[</span>:<span class='b'>]</span>
    m<span class='b'>[</span><span class='s'>'{'</span><span class='b'>]</span> = <span class='s'>'}'</span>; m<span class='b'>[</span><span class='s'>'}'</span><span class='b'>]</span> = <span class='s'>'{'</span>
    m<span class='b'>[</span><span class='s'>'('</span><span class='b'>]</span> = <span class='s'>')'</span>; m<span class='b'>[</span><span class='s'>')'</span><span class='b'>]</span> = <span class='s'>'('</span>
    m<span class='b'>[</span><span class='s'>'['</span><span class='b'>]</span> = <span class='s'>']'</span>; m<span class='b'>[</span><span class='s'>']'</span><span class='b'>]</span> = <span class='s'>'['</span>
    m<span class='b'>[</span><span class='s'>'&lt;'</span><span class='b'>]</span> = <span class='s'>'&gt;'</span>; m<span class='b'>[</span><span class='s'>'&gt;'</span><span class='b'>]</span> = <span class='s'>'&lt;'</span>
    bracketPairs = m
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Debug</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Debug dump of the document model.</span>
  <span class='z'>**</span>
  Void <span id='dump'>dump</span><span class='b'>(</span>OutStream out := Env.cur.out<span class='b'>)</span>
  <span class='b'>{</span>
    out.printLine<span class='b'>(</span><span class='s'>""</span><span class='b'>)</span>
    out.printLine<span class='b'>(</span><span class='s'>"==== Doc.dump ==="</span><span class='b'>)</span>
    out.printLine<span class='b'>(</span><span class='s'>"size=$size"</span><span class='b'>)</span>
    out.printLine<span class='b'>(</span><span class='s'>"lines.size=$lines.size"</span><span class='b'>)</span>
    out.printLine<span class='b'>(</span><span class='s'>"delimiter=$delimiter.toCode"</span><span class='b'>)</span>
    lines.each |Line line, Int i| <span class='b'>{</span> out.printLine<span class='b'>(</span><span class='s'>"[${i.toStr.justr(3)} @ ${line.offset.toStr.justr(3)}] $line.text.toCode  $line.debug"</span><span class='b'>)</span> <span class='b'>}</span>
    out.printLine<span class='b'>(</span><span class='s'>""</span><span class='b'>)</span>
    out.flush
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>readonly</span> TextEditorOptions <span id='options'>options</span> <span class='y'>// text options for current document</span>
  <span class='k'>readonly</span> SyntaxOptions <span id='syntax'>syntax</span>      <span class='y'>// syntax options for current document</span>
  <span class='k'>readonly</span> SyntaxRules <span id='rules'>rules</span>         <span class='y'>// syntax rules for current document</span>

  <span class='k'>internal</span> Int <span id='size'>size</span> := 0             <span class='y'>// total char count</span>
  <span class='k'>internal</span> Line<span class='b'>[]</span> <span id='lines'>lines</span> := Line<span class='b'>[</span>,<span class='b'>]</span>   <span class='y'>// lines</span>
  <span class='k'>internal</span> Str <span id='delimiter'>delimiter</span>             <span class='y'>// line delimiter</span>
  <span class='k'>internal</span> Parser <span id='parser'>parser</span>             <span class='y'>// to parse lines into styled segments</span>

  <span class='k'>internal</span> Int <span id='caretLine'>caretLine</span>             <span class='y'>// current line for highlighting</span>
  <span class='k'>internal</span> Int? <span id='bracketLine1'>bracketLine1</span>         <span class='y'>// matched bracket 1 line index</span>
  <span class='k'>internal</span> Int? <span id='bracketLine2'>bracketLine2</span>         <span class='y'>// matched bracket 2 line index</span>
  <span class='k'>internal</span> Int? <span id='bracketCol1'>bracketCol1</span>          <span class='y'>// matched bracket 1 offset in line</span>
  <span class='k'>internal</span> Int? <span id='bracketCol2'>bracketCol2</span>          <span class='y'>// matched bracket 2 offset in line</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** Line</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** Line models one text line of a Doc</span>
<span class='z'>**</span>
<span class='k'>internal</span> <span class='k'>class</span> Line
<span class='b'>{</span>
  <span class='z'>** Return 'text'.</span>
  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> text <span class='b'>}</span>

  <span class='z'>** Zero based offset from start of document (this</span>
  <span class='z'>** field is managed by the Doc).</span>
  Int offset <span class='b'>{</span> <span class='k'>internal</span> set; <span class='b'>}</span>

  <span class='z'>** Text of line (without delimiter)</span>
  Str text := <span class='s'>""</span>

  <span class='z'>** Offset/RichTextStyle pairs</span>
  Obj<span class='b'>[]</span>? styling

  <span class='z'>** Override when line is inside a block comment or multi-line str</span>
  Obj<span class='b'>[]</span>? stylingOverride

  <span class='z'>** Opens n comments if &gt; 0 or closes n comments if &lt; 0</span>
  <span class='k'>virtual</span> Int commentNesting<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> 0 <span class='b'>}</span>

  <span class='z'>** If this line opens a multi-line block (comment/str),</span>
  <span class='z'>** then return a block handle, else null.</span>
  <span class='k'>virtual</span> Block? opens<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>null</span> <span class='b'>}</span>

  <span class='z'>** If this line closes the specified block, then return the new</span>
  <span class='z'>** line which takes into account that this line is the closing line</span>
  <span class='z'>** of a multi-line comment or string.</span>
  <span class='k'>virtual</span> Line? closes<span class='b'>(</span>Block open<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>null</span> <span class='b'>}</span>

  <span class='z'>** Debug information</span>
  <span class='k'>internal</span> <span class='k'>virtual</span> Str debug<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='s'>""</span> <span class='b'>}</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** FatLine</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** FatLine subclasses "thin" lines to cache more parsed</span>
<span class='z'>** information.  We use a subclass to avoid the extra memory</span>
<span class='z'>** overhead on lines which don't need these extra fields.</span>
<span class='z'>**</span>
<span class='k'>internal</span> <span class='k'>class</span> FatLine : Line
<span class='b'>{</span>
  <span class='z'>** Opens n comments if &gt; 0 or closes n comments if &lt; 0</span>
  <span class='k'>override</span> Int commentNesting := 0

  <span class='z'>** If this line opens a multi-line block (comment/str),</span>
  <span class='z'>** then return a block handle, else null.</span>
  <span class='k'>override</span> Block? opens

  <span class='z'>** If this line closes the specified block, then return the new</span>
  <span class='z'>** line which takes into account that this line is the closing line</span>
  <span class='z'>** of a multi-line comment or string.</span>
  <span class='k'>override</span> Line? closes<span class='b'>(</span>Block open<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>closeBlocks == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;closeBlocks.size; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      newLine := closeBlocks<span class='b'>[</span>i<span class='b'>]</span>.closes<span class='b'>(</span><span class='k'>this</span>, open<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>newLine != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> newLine
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>** List of blocks this line potentially closes</span>
  <span class='z'>** if used after an opening block</span>
  Block<span class='b'>[]</span>? closeBlocks

  <span class='z'>** Debug information</span>
  <span class='k'>internal</span> <span class='k'>override</span> Str debug<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"{$commentNesting, $opens, $closeBlocks}"</span>
  <span class='b'>}</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** Block</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** Blocks model multiple line syntax constructs: block comments</span>
<span class='z'>** and multi-line strings.</span>
<span class='z'>**</span>
<span class='k'>internal</span> <span class='k'>abstract</span> <span class='k'>class</span> Block
<span class='b'>{</span>
  <span class='z'>** Which style override should be used inside the block?</span>
  <span class='k'>abstract</span> Obj<span class='b'>[]</span>? stylingOverride<span class='b'>()</span>

  <span class='z'>** If this block marker can be used to close the specified</span>
  <span class='z'>** open block, then return the new line taking into account</span>
  <span class='z'>** that the cur line is closing a mult-line block comment</span>
  <span class='z'>** or str.  Return null if this instance doesn't close open.</span>
  <span class='k'>abstract</span> Line? closes<span class='b'>(</span>Line line, Block open<span class='b'>)</span>
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Doc.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#bracketCol1'>bracketCol1</a></li>
  <li class='hidden' style='display: block;'><a href='#bracketCol2'>bracketCol2</a></li>
  <li class='hidden' style='display: block;'><a href='#bracketLine1'>bracketLine1</a></li>
  <li class='hidden' style='display: block;'><a href='#bracketLine2'>bracketLine2</a></li>
  <li class='hidden' style='display: block;'><a href='#bracketPairs'>bracketPairs</a></li>
  <li class='hidden' style='display: block;'><a href='#caretLine'>caretLine</a></li>
  <li style='display: block;'><a href='#charCount'>charCount</a></li>
  <li class='hidden' style='display: block;'><a href='#delimiter'>delimiter</a></li>
  <li style='display: block;'><a href='#dump'>dump</a></li>
  <li style='display: block;'><a href='#findNext'>findNext</a></li>
  <li style='display: block;'><a href='#findPrev'>findPrev</a></li>
  <li class='hidden' style='display: block;'><a href='#insertBracketMatch'>insertBracketMatch</a></li>
  <li style='display: block;'><a href='#line'>line</a></li>
  <li style='display: block;'><a href='#lineAtOffset'>lineAtOffset</a></li>
  <li style='display: block;'><a href='#lineBackground'>lineBackground</a></li>
  <li style='display: block;'><a href='#lineCount'>lineCount</a></li>
  <li style='display: block;'><a href='#lineStyling'>lineStyling</a></li>
  <li class='hidden' style='display: block;'><a href='#lines'>lines</a></li>
  <li class='hidden' style='display: block;'><a href='#load'>load</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li class='hidden' style='display: block;'><a href='#matchBracket'>matchBracket</a></li>
  <li style='display: block;'><a href='#modify'>modify</a></li>
  <li style='display: block;'><a href='#offsetAtLine'>offsetAtLine</a></li>
  <li style='display: block;'><a href='#options'>options</a></li>
  <li class='hidden' style='display: block;'><a href='#parser'>parser</a></li>
  <li style='display: block;'><a href='#rules'>rules</a></li>
  <li class='hidden' style='display: block;'><a href='#save'>save</a></li>
  <li class='hidden' style='display: block;'><a href='#setBracketMatch'>setBracketMatch</a></li>
  <li class='hidden' style='display: block;'><a href='#size'>size</a></li>
  <li style='display: block;'><a href='#syntax'>syntax</a></li>
  <li style='display: block;'><a href='#text'>text</a></li>
  <li class='hidden' style='display: block;'><a href='#updateLines'>updateLines</a></li>
  <li class='hidden' style='display: block;'><a href='#updateMarks'>updateMarks</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
fluxText 1.0.56
[11-Nov-2010 Thu 10:08:27AM EST]
</p>
</div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::Normalize</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='Normalize.html'>Normalize</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::Normalize</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    <a href='CompilerStep.html'>compiler::CompilerStep</a>
      compiler::Normalize</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//    2 Dec 05  Brian Frank  Creation</span>
<span class='y'>//   30 Sep 06  Brian Frank  Ported from Java to Fan</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Normalize the abstract syntax tree:</span>
<span class='z'>**   - Collapse multiple static new blocks</span>
<span class='z'>**   - Init static fields in static new block</span>
<span class='z'>**   - Init instance fields in instance new block</span>
<span class='z'>**   - Add implicit return in methods</span>
<span class='z'>**   - Add implicit super constructor call</span>
<span class='z'>**   - Rewrite synthetic getter/setter for override of concrete field</span>
<span class='z'>**   - Infer collection fields from LHS of field definition</span>
<span class='z'>**   - Generate once method boiler plate</span>
<span class='z'>**</span>
<span class='k'>class</span> Normalize : CompilerStep
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Run</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='run'>run</span><span class='b'>()</span>
  <span class='b'>{</span>
    log.debug<span class='b'>(</span><span class='s'>"Normalize"</span><span class='b'>)</span>
    walk<span class='b'>(</span>compiler, VisitDepth.typeDef<span class='b'>)</span>
    bombIfErr
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Type Normalization</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='visitTypeDef'>visitTypeDef</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    loc := t.loc
    iInit := Block<span class='b'>(</span>loc<span class='b'>)</span>  <span class='y'>// instance init</span>
    sInit := Block<span class='b'>(</span>loc<span class='b'>)</span>  <span class='y'>// static init</span>

    <span class='y'>// walk thru all the slots</span>
    t.slotDefs.dup.each |SlotDef s|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>s <span class='k'>is</span> FieldDef<span class='b'>)</span>
      <span class='b'>{</span>
        f := <span class='b'>(</span>FieldDef<span class='b'>)</span>s
        normalizeField<span class='b'>(</span>f<span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>f.init != <span class='k'>null</span> &amp;&amp; !f.isAbstract<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>f.isStatic<span class='b'>)</span>
            sInit.add<span class='b'>(</span>fieldInitStmt<span class='b'>(</span>f<span class='b'>))</span>
          <span class='k'>else</span>
            iInit.add<span class='b'>(</span>fieldInitStmt<span class='b'>(</span>f<span class='b'>))</span>
          f.walkInit = <span class='k'>false</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        <span class='y'>// if a static initializer, append it</span>
        m := <span class='b'>(</span>MethodDef<span class='b'>)</span>s
        <span class='k'>if</span> <span class='b'>(</span>m.isStaticInit<span class='b'>)</span>
          appendStaticInit<span class='b'>(</span>sInit, m<span class='b'>)</span>
        <span class='k'>else</span>
          normalizeMethod<span class='b'>(</span>m, iInit<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// add instance$init if needed</span>
    <span class='k'>if</span> <span class='b'>(</span>!iInit.isEmpty<span class='b'>)</span>
    <span class='b'>{</span>
      iInit.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>))</span>
      ii := MethodDef.makeInstanceInit<span class='b'>(</span>iInit.loc, t, iInit<span class='b'>)</span>
      t.addSlot<span class='b'>(</span>ii<span class='b'>)</span>
      callInstanceInit<span class='b'>(</span>t, ii<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// add static$init if needed</span>
    <span class='k'>if</span> <span class='b'>(</span>!sInit.isEmpty<span class='b'>)</span>
    <span class='b'>{</span>
      sInit.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>))</span>
      t.normalizeStaticInits<span class='b'>(</span>MethodDef.makeStaticInit<span class='b'>(</span>sInit.loc, t, sInit<span class='b'>))</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='appendStaticInit'>appendStaticInit</span><span class='b'>(</span>Block sInit, MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// append inside an "if (true) {}" block so that each static</span>
    <span class='y'>// initializer is given its own scope in the unified static initializer;</span>
    <span class='y'>// the "if (true)" gets optimized away in CoodeAsm</span>
    loc := m.loc
    cond := LiteralExpr<span class='b'>(</span>loc, ExprId.trueLiteral, ns.boolType, <span class='k'>true</span><span class='b'>)</span>
    ifStmt := IfStmt<span class='b'>(</span>loc, cond, m.code<span class='b'>)</span>
    sInit.add<span class='b'>(</span>ifStmt<span class='b'>)</span>
    m.code = <span class='k'>null</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Method Normalization</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='normalizeMethod'>normalizeMethod</span><span class='b'>(</span>MethodDef m, Block iInit<span class='b'>)</span>
  <span class='b'>{</span>
    code := m.code
    <span class='k'>if</span> <span class='b'>(</span>code == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// add implicit return</span>
    <span class='k'>if</span> <span class='b'>(</span>!code.isExit<span class='b'>)</span> addImplicitReturn<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// insert super constructor call</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isCtor<span class='b'>)</span> insertSuperCtor<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// once</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isOnce<span class='b'>)</span> normalizeOnce<span class='b'>(</span>m, iInit<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='addImplicitReturn'>addImplicitReturn</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    code := m.code
    loc := code.loc

    <span class='y'>// we allow return keyword to be omitted if there is exactly one statement</span>
    <span class='k'>if</span> <span class='b'>(</span>code.size == 1 &amp;&amp; !m.returnType.isVoid &amp;&amp; code.stmts<span class='b'>[</span>0<span class='b'>]</span>.id == StmtId.expr<span class='b'>)</span>
    <span class='b'>{</span>
      code.stmts<span class='b'>[</span>0<span class='b'>]</span> = ReturnStmt.makeSynthetic<span class='b'>(</span>code.stmts<span class='b'>[</span>0<span class='b'>]</span>.loc, code.stmts<span class='b'>[</span>0<span class='b'>]</span>-&gt;expr<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// return is implied as simple method exit</span>
    code.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>))</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='insertSuperCtor'>insertSuperCtor</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// don't need to insert if one already is defined</span>
    <span class='k'>if</span> <span class='b'>(</span>m.ctorChain != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// never insert super call for synthetic types, mixins, or Obj.make</span>
    parent := m.parent
    base := parent.base
    <span class='k'>if</span> <span class='b'>(</span>parent.isSynthetic<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>parent.isMixin<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>base.isObj<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// check if the base class has exactly one available</span>
    <span class='y'>// constructor with no parameters</span>
    superCtors := base.ctors
    <span class='k'>if</span> <span class='b'>(</span>superCtors.size != 1<span class='b'>)</span> <span class='k'>return</span>
    superCtor := superCtors.first
    <span class='k'>if</span> <span class='b'>(</span>superCtor.isPrivate<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>superCtor.isInternal &amp;&amp; base.pod != parent.pod<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>!superCtor.params.isEmpty<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// if we find a ctor to use, then create an implicit super call</span>
    m.ctorChain = CallExpr.makeWithMethod<span class='b'>(</span>m.loc, SuperExpr<span class='b'>(</span>m.loc<span class='b'>)</span>, superCtor<span class='b'>)</span>
    m.ctorChain.isCtorChain = <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='normalizeOnce'>normalizeOnce</span><span class='b'>(</span>MethodDef m, Block iInit<span class='b'>)</span>
  <span class='b'>{</span>
    loc := m.loc

    <span class='y'>// we'll report these errors in CheckErrors</span>
    <span class='k'>if</span> <span class='b'>(</span>curType.isConst || curType.isMixin ||
        m.isStatic || m.isCtor || m.isFieldAccessor<span class='b'>)</span>
      <span class='k'>return</span>

    <span class='y'>// error checking</span>
    <span class='k'>if</span> <span class='b'>(</span>m.ret.isVoid<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Once method '$m.name' cannot return Void"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>!m.params.isEmpty<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Once method '$m.name' cannot have parameters"</span>, loc<span class='b'>)</span>

    <span class='y'>// generate storage field</span>
    f := FieldDef<span class='b'>(</span>loc, curType<span class='b'>)</span>
    f.flags     = FConst.Private + FConst.Storage + FConst.Synthetic
    f.name      = m.name + <span class='s'>"\$Store"</span>
    f.fieldType = ns.objType.toNullable
    f.init      = Expr.makeForLiteral<span class='b'>(</span>loc, ns, <span class='s'>"_once_"</span><span class='b'>)</span>
    curType.addSlot<span class='b'>(</span>f<span class='b'>)</span>
     iInit.add<span class='b'>(</span>fieldInitStmt<span class='b'>(</span>f<span class='b'>))</span>

    <span class='y'>// add name$Once with original code</span>
    x := MethodDef<span class='b'>(</span>loc, curType<span class='b'>)</span>
    x.flags        = FConst.Private + FConst.Synthetic
    x.name         = m.name + <span class='s'>"\$Once"</span>
    x.ret          = ns.objType.toNullable
    x.inheritedRet = <span class='k'>null</span>
    x.paramDefs    = m.paramDefs
    x.vars         = m.vars
    x.usesCvars    = m.usesCvars
    x.code         = m.code
    curType.addSlot<span class='b'>(</span>x<span class='b'>)</span>

    <span class='y'>// swizzle any closures using that method to the name$Once version</span>
    curType.closures.each |ClosureExpr c|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>c.enclosingSlot === m<span class='b'>)</span> c.enclosingSlot = x
    <span class='b'>}</span>

    <span class='y'>// replace original method code with our delegate:</span>
    <span class='y'>//   if (name$Store == "_once_")</span>
    <span class='y'>//     name$Store = name$Once()</span>
    <span class='y'>//   return (RetType)name$Store</span>
    m.code  = Block<span class='b'>(</span>loc<span class='b'>)</span>

    <span class='y'>// if (name$Store == "_once_")</span>
    cond := BinaryExpr<span class='b'>(</span>
      f.makeAccessorExpr<span class='b'>(</span>loc, <span class='k'>false</span><span class='b'>)</span>,
      Token.same,
      Expr.makeForLiteral<span class='b'>(</span>loc, ns, <span class='s'>"_once_"</span><span class='b'>))</span>

    <span class='y'>// name$Store = name$Once()</span>
    trueBlock := Block<span class='b'>(</span>loc<span class='b'>)</span>
    trueBlock.add<span class='b'>(</span>BinaryExpr<span class='b'>(</span>
        f.makeAccessorExpr<span class='b'>(</span>loc, <span class='k'>false</span><span class='b'>)</span>,
        Token.assign,
        CallExpr.makeWithMethod<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc<span class='b'>)</span>, x<span class='b'>)</span>
      <span class='b'>)</span>.toStmt<span class='b'>)</span>

    ifStmt := IfStmt<span class='b'>(</span>loc, cond, trueBlock<span class='b'>)</span>
    m.code.add<span class='b'>(</span>ifStmt<span class='b'>)</span>

    <span class='y'>// return (RetType)name$Store</span>
    retStmt := ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>)</span>
    retStmt.expr = TypeCheckExpr.coerce<span class='b'>(</span>
      f.makeAccessorExpr<span class='b'>(</span>loc, <span class='k'>false</span><span class='b'>)</span>,
      m.ret<span class='b'>)</span>
    m.code.add<span class='b'>(</span>retStmt<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='callInstanceInit'>callInstanceInit</span><span class='b'>(</span>TypeDef t, MethodDef ii<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// we call instance$init in every constructor</span>
    <span class='y'>// unless the constructor chains to "this"</span>
    t.methodDefs.each |MethodDef m|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!m.isCtor<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>if</span> <span class='b'>(</span>t.isNative<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>if</span> <span class='b'>(</span>m.ctorChain != <span class='k'>null</span> &amp;&amp; m.ctorChain.target.id === ExprId.thisExpr<span class='b'>)</span> <span class='k'>return</span>
      call := CallExpr.makeWithMethod<span class='b'>(</span>m.loc, ThisExpr<span class='b'>(</span>m.loc<span class='b'>)</span>, ii<span class='b'>)</span>
      m.code.stmts.insert<span class='b'>(</span>0, call.toStmt<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Field Normalization</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='normalizeField'>normalizeField</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// validate type of field</span>
    t := f.fieldType
    <span class='k'>if</span> <span class='b'>(</span>t.isThis<span class='b'>)</span>   <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use This as field type"</span>, f.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isVoid<span class='b'>)</span>   <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use Void as field type"</span>, f.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>!t.isValid<span class='b'>)</span> <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Invalid type '$t'"</span>, f.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>

    <span class='y'>// if field init value is a list/map without an explicit type,</span>
    <span class='y'>// then infer type of collection based on field's declared type</span>
    <span class='k'>if</span> <span class='b'>(</span>f.init != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>f.init.id == ExprId.listLiteral<span class='b'>)</span> inferFieldListType<span class='b'>(</span>f<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>f.init.id == ExprId.mapLiteral<span class='b'>)</span> inferFieldMapType<span class='b'>(</span>f<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if this field overrides a concrete field, that means we already have</span>
    <span class='y'>// a concrete getter/setter for this field - if either of this field's</span>
    <span class='y'>// accessors is synthetic, then rewrite the one generated by Parser with</span>
    <span class='y'>// one that calls the "super" version of the accessor</span>
    <span class='k'>if</span> <span class='b'>(</span>f.concreteBase != <span class='k'>null</span> &amp;&amp; !f.isAbstract &amp;&amp; !f.isNative<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!f.hasGet<span class='b'>)</span> genSyntheticOverrideGet<span class='b'>(</span>f<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>!f.hasSet<span class='b'>)</span> genSyntheticOverrideSet<span class='b'>(</span>f<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// ensure that getter is using inherited return</span>
    <span class='y'>// in case we have a covariant override</span>
    <span class='k'>if</span> <span class='b'>(</span>f.get != <span class='k'>null</span><span class='b'>)</span>
      f.get.inheritedRet = f.inheritedRet
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='inferFieldListType'>inferFieldListType</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if literal had explicit type, then bail</span>
    init := f.init <span class='k'>as</span> ListLiteralExpr
    <span class='k'>if</span> <span class='b'>(</span>init.explicitType != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// force explicit type to be defined type of field</span>
    init.explicitType = f.fieldType.toNonNullable <span class='k'>as</span> ListType
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='inferFieldMapType'>inferFieldMapType</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if literal had explicit type, then bail</span>
    init := f.init <span class='k'>as</span> MapLiteralExpr
    <span class='k'>if</span> <span class='b'>(</span>init.explicitType != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// force explicit type to be defined type of field</span>
    init.explicitType = f.fieldType.toNonNullable <span class='k'>as</span> MapType
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='genSyntheticOverrideGet'>genSyntheticOverrideGet</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    loc := f.loc
    f.get.code.stmts.clear
    f.get.code.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc, FieldExpr<span class='b'>(</span>loc, SuperExpr<span class='b'>(</span>loc<span class='b'>)</span>, f.concreteBase<span class='b'>)))</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='genSyntheticOverrideSet'>genSyntheticOverrideSet</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    loc := f.loc
    lhs := FieldExpr<span class='b'>(</span>loc, SuperExpr<span class='b'>(</span>loc<span class='b'>)</span>, f.concreteBase<span class='b'>)</span>
    rhs := UnknownVarExpr<span class='b'>(</span>loc, <span class='k'>null</span>, <span class='s'>"it"</span><span class='b'>)</span>
    code := f.get.code
    f.set.code.stmts.clear
    f.set.code.add<span class='b'>(</span>BinaryExpr.makeAssign<span class='b'>(</span>lhs, rhs<span class='b'>)</span>.toStmt<span class='b'>)</span>
    f.set.code.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>))</span>
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> ExprStmt <span id='fieldInitStmt'>fieldInitStmt</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    useAccessor := f.concreteBase != <span class='k'>null</span>
    lhs := f.makeAccessorExpr<span class='b'>(</span>f.loc, useAccessor<span class='b'>)</span>
    rhs := f.init
    <span class='k'>return</span> BinaryExpr.makeAssign<span class='b'>(</span>lhs, rhs<span class='b'>)</span>.toStmt
  <span class='b'>}</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Normalize.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#addImplicitReturn'>addImplicitReturn</a></li>
  <li class='hidden' style='display: block;'><a href='#appendStaticInit'>appendStaticInit</a></li>
  <li class='hidden' style='display: block;'><a href='#callInstanceInit'>callInstanceInit</a></li>
  <li class='hidden' style='display: block;'><a href='#fieldInitStmt'>fieldInitStmt</a></li>
  <li class='hidden' style='display: block;'><a href='#genSyntheticOverrideGet'>genSyntheticOverrideGet</a></li>
  <li class='hidden' style='display: block;'><a href='#genSyntheticOverrideSet'>genSyntheticOverrideSet</a></li>
  <li class='hidden' style='display: block;'><a href='#inferFieldListType'>inferFieldListType</a></li>
  <li class='hidden' style='display: block;'><a href='#inferFieldMapType'>inferFieldMapType</a></li>
  <li class='hidden' style='display: block;'><a href='#insertSuperCtor'>insertSuperCtor</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li class='hidden' style='display: block;'><a href='#normalizeField'>normalizeField</a></li>
  <li class='hidden' style='display: block;'><a href='#normalizeMethod'>normalizeMethod</a></li>
  <li class='hidden' style='display: block;'><a href='#normalizeOnce'>normalizeOnce</a></li>
  <li style='display: block;'><a href='#run'>run</a></li>
  <li style='display: block;'><a href='#visitTypeDef'>visitTypeDef</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::ClosureVars</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='ClosureVars.html'>ClosureVars</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::ClosureVars</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    <a href='CompilerStep.html'>compiler::CompilerStep</a>
      compiler::ClosureVars</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   5 Mar 06  Brian Frank  Creation</span>
<span class='y'>//   4 Oct 06  Brian Frank  Port from Java to Fan</span>
<span class='y'>//   4 Sep 09  Brian Frank  Redesign with individual wrappers</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** ClosureVars is used to process closure variables which have</span>
<span class='z'>** been enclosed from their parent scope:</span>
<span class='z'>**</span>
<span class='z'>**  ResolveExpr</span>
<span class='z'>**  -----------</span>
<span class='z'>**  ResolveExpr we detected variables used from parent scope</span>
<span class='z'>**  and created shadow variables in the closure's scope with</span>
<span class='z'>**  a reference via 'MethodVar.shadows'.  Also during this step</span>
<span class='z'>**  we note any variables which are reassigned making them</span>
<span class='z'>**  non-final (according to Java final variable semantics).</span>
<span class='z'>**</span>
<span class='z'>**  Process Method</span>
<span class='z'>**  --------------</span>
<span class='z'>**  First we walk all types looking for methods which use</span>
<span class='z'>**  closure variables:</span>
<span class='z'>**</span>
<span class='z'>**   1. For each one walk thru its variables to see if any variables</span>
<span class='z'>**      enclosed are non-final (reassigned at some point).  These</span>
<span class='z'>**      variables as hoisted onto the heap with wrappers:</span>
<span class='z'>**         class Wrapper$T { new make(T v) { val=v }  T val }</span>
<span class='z'>**</span>
<span class='z'>**   2. If no wrapped variables, then we can leave a cvars method</span>
<span class='z'>**      alone - everything stays the same.  If however we do have</span>
<span class='z'>**      wrapped variables, then we need to walk the expr tree of</span>
<span class='z'>**      the method replacing all access of the variable with its</span>
<span class='z'>**      wrapper access:</span>
<span class='z'>**         x := 3     =&gt;   x := Wrapper$Int(3)</span>
<span class='z'>**         x = x + 1  =&gt;   x.val = x.val + 1</span>
<span class='z'>**</span>
<span class='z'>**   3. If any params were wrapped, we generated a new local variable</span>
<span class='z'>**      in 'wrapNonFinalVars'.  During the expr tree walk we replaced all</span>
<span class='z'>**      references to the param to its new wrapped local.   To finish</span>
<span class='z'>**      processing the method we insert a bit of code in the beginning</span>
<span class='z'>**      of the method to initialize the local.</span>
<span class='z'>**</span>
<span class='z'>**  Process Closure</span>
<span class='z'>**  ---------------</span>
<span class='z'>**  After we have walked all methods using closure variables (which</span>
<span class='z'>**  might include closure doCall methods themselves), then we walk</span>
<span class='z'>**  all the closures.</span>
<span class='z'>**</span>
<span class='z'>**   1. For each shadowed variables we need:</span>
<span class='z'>**        a. Define field on the closure to store variable</span>
<span class='z'>**        b. Pass variable to closure constructor at substitution site</span>
<span class='z'>**        c. Add variable to as closure constructor param</span>
<span class='z'>**        d. Assign param to field in constructor</span>
<span class='z'>**      If the variable has been wrapped we are doing this for the</span>
<span class='z'>**      wrapped variable (we don't unwrap it).</span>
<span class='z'>**</span>
<span class='z'>**   2. If any of the closures shadowed variables are wrapped, then</span>
<span class='z'>**      we do a expr tree walk of doCall - the exact same thing as</span>
<span class='z'>**      step 2 of the processMethod stage.</span>
<span class='z'>**</span>
<span class='z'>**</span>
<span class='k'>class</span> ClosureVars : CompilerStep
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler<span class='b'>)</span> : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span> <span class='b'>{}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Run</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='run'>run</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// process all the methods which use closures</span>
    types.each |TypeDef t| <span class='b'>{</span> scanType<span class='b'>(</span>t<span class='b'>)</span> <span class='b'>}</span>

    <span class='y'>// process all the closures themselves</span>
    compiler.closures.each |c| <span class='b'>{</span> processClosure<span class='b'>(</span>c<span class='b'>)</span> <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='scanType'>scanType</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// only process methods which use closure variables</span>
    t.methodDefs.each |m| <span class='b'>{</span> <span class='k'>if</span> <span class='b'>(</span>m.usesCvars<span class='b'>)</span> processMethod<span class='b'>(</span>m<span class='b'>)</span> <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Process Method</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='processMethod'>processMethod</span><span class='b'>(</span>MethodDef method<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!wrapNonFinalVars<span class='b'>(</span>method<span class='b'>))</span> <span class='k'>return</span>
    walkMethod<span class='b'>(</span>method<span class='b'>)</span>
    fixWrappedParams<span class='b'>(</span>method<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Wrap Non-Final Vars</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Wrap each non-final variable which is reassigned and used</span>
  <span class='z'>** inside a closure.  By wrapping it we hoist it into the heap</span>
  <span class='z'>** so that it may be shared b/w method and closure(s).  Return</span>
  <span class='z'>** true if we wrapped any vars.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Bool <span id='wrapNonFinalVars'>wrapNonFinalVars</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    wrapped := <span class='k'>false</span>
    m.vars.each |var, i|
    <span class='b'>{</span>
      <span class='y'>// we only care about variables used in closures</span>
      <span class='k'>if</span> <span class='b'>(</span>!var.usedInClosure<span class='b'>)</span> <span class='k'>return</span>

      <span class='y'>// if the variable is never reassigned, then we</span>
      <span class='y'>// can use it directly since it is final</span>
      <span class='k'>if</span> <span class='b'>(</span>!var.isReassigned<span class='b'>)</span> <span class='k'>return</span>

      <span class='y'>// generate or reuse Wrapper class for this type</span>
      wrapField := genWrapper<span class='b'>(</span><span class='k'>this</span>, var.ctype<span class='b'>)</span>

      <span class='k'>if</span> <span class='b'>(</span>var.isParam<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='y'>// we can't change signature of parameters since they</span>
        <span class='y'>// are passed in externally, so we have to create a new</span>
        <span class='y'>// local to use for the wrapper version of the param</span>
        w := m.addLocalVar<span class='b'>(</span>wrapField.parent, var.name + <span class='s'>"\$Wrapper"</span>, m.code<span class='b'>)</span>
        w.wrapField = wrapField
        var.paramWrapper = w
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        <span class='y'>// generate wrapper type and update variable type</span>
        <span class='k'>if</span> <span class='b'>(</span>var.wrapField != <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> Err<span class='b'>()</span>
        var.wrapField = wrapField
        var.ctype = wrapField.parent
      <span class='b'>}</span>

      <span class='y'>// keep track that we've wrapped something</span>
      wrapped = <span class='k'>true</span>
    <span class='b'>}</span>
    <span class='k'>return</span> wrapped
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Walk Method</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Walk the method body:</span>
  <span class='z'>**   1.  Create wrapper for each local var definition which requries it</span>
  <span class='z'>**   2.  Add unwrap val access for each use of a wrapped local variable</span>
  <span class='z'>**   3.  If using a wrapped param, then replace with wrapped local</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='walkMethod'>walkMethod</span><span class='b'>(</span>MethodDef method<span class='b'>)</span>
  <span class='b'>{</span>
    method.code.walk<span class='b'>(</span><span class='k'>this</span>, VisitDepth.expr<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Stmt<span class='b'>[]</span>? <span id='visitStmt'>visitStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.id === StmtId.localDef &amp;&amp; <span class='b'>((</span>LocalDefStmt<span class='b'>)</span>stmt<span class='b'>)</span>.var.isWrapped<span class='b'>)</span>
      <span class='k'>return</span> fixLocalDef<span class='b'>(</span>stmt<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Expr <span id='visitExpr'>visitExpr</span><span class='b'>(</span>Expr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>expr.id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.localVar: <span class='k'>return</span> fixWrappedVar<span class='b'>(</span>expr<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fix Local Init</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If a local variable has been hoisted onto the heap with</span>
  <span class='z'>** a wrapper, then generate wrapper initialization:</span>
  <span class='z'>**</span>
  <span class='z'>**   // original code</span>
  <span class='z'>**   local := 3</span>
  <span class='z'>**</span>
  <span class='z'>**   // becomes</span>
  <span class='z'>**   local := Wrap$Int(3)</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Stmt<span class='b'>[]</span>? <span id='fixLocalDef'>fixLocalDef</span><span class='b'>(</span>LocalDefStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// get the initial value to pass to wrapper constructor</span>
    Expr? init
    <span class='k'>if</span> <span class='b'>(</span>stmt.init == <span class='k'>null</span><span class='b'>)</span>
      init = LiteralExpr.makeNull<span class='b'>(</span>stmt.loc, ns<span class='b'>)</span>
    <span class='k'>else</span>
      init = <span class='b'>((</span>BinaryExpr<span class='b'>)</span>stmt.init<span class='b'>)</span>.rhs

    <span class='y'>// replace original initialization with wrapper construction</span>
    stmt.init = initWrapper<span class='b'>(</span>stmt.loc, stmt.var, init<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Generate the expression: var := Wrapper(init)</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='initWrapper'>initWrapper</span><span class='b'>(</span>Loc loc, MethodVar var, Expr init<span class='b'>)</span>
  <span class='b'>{</span>
    wrapCtor := var.wrapField.parent.method<span class='b'>(</span><span class='s'>"make"</span><span class='b'>)</span>
    lhs := LocalVarExpr.makeNoUnwrap<span class='b'>(</span>loc, var<span class='b'>)</span>
    rhs := CallExpr.makeWithMethod<span class='b'>(</span>loc, <span class='k'>null</span>, wrapCtor, <span class='b'>[</span>init<span class='b'>])</span>
    <span class='k'>return</span> BinaryExpr.makeAssign<span class='b'>(</span>lhs, rhs<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fix Wrapped Var</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If we are accessing a wrapped variable, then add</span>
  <span class='z'>** indirection to access it from Wrapper.val field.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='fixWrappedVar'>fixWrappedVar</span><span class='b'>(</span>LocalVarExpr local<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if this variable access is a wrapped parameter, then</span>
    <span class='y'>// we never use the parameter itself, but rather the wrapper</span>
    <span class='y'>// local variable</span>
    var := local.var
    <span class='k'>if</span> <span class='b'>(</span>var.paramWrapper != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// use param wrapper variable</span>
      var = var.paramWrapper

      <span class='y'>// if not unwrapping, we still need to use different variable</span>
      <span class='k'>if</span> <span class='b'>(</span>!local.unwrap<span class='b'>)</span> <span class='k'>return</span> LocalVarExpr<span class='b'>(</span>local.loc, var<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if not a wrapped variable or we have explictly marked</span>
    <span class='y'>// it to stay wrapped, then don't do anything</span>
    <span class='k'>if</span> <span class='b'>(</span>!var.isWrapped || !local.unwrap<span class='b'>)</span> <span class='k'>return</span> local

    <span class='y'>// unwrap from the Wrapper.val field</span>
    loc := local.loc
    <span class='k'>return</span> fieldExpr<span class='b'>(</span>loc, LocalVarExpr.makeNoUnwrap<span class='b'>(</span>loc, var<span class='b'>)</span>, var.wrapField<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fix Wrapped Params</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** After we have walked the expr tree, we go back and initialize</span>
  <span class='z'>** the wrapper for any wrapped params used inside closures:</span>
  <span class='z'>**</span>
  <span class='z'>**   Void foo(Int x)</span>
  <span class='z'>**   {</span>
  <span class='z'>**     x$wrapper := Wrap$Int(x)</span>
  <span class='z'>**     ...</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='fixWrappedParams'>fixWrappedParams</span><span class='b'>(</span>MethodDef method<span class='b'>)</span>
  <span class='b'>{</span>
    method.vars.each |var|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>var.paramWrapper == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>
      loc := method.loc
      initWrap := initWrapper<span class='b'>(</span>loc, var.paramWrapper, LocalVarExpr<span class='b'>(</span>loc, var<span class='b'>))</span>
      method.code.stmts.insert<span class='b'>(</span>0, initWrap.toStmt<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Process Closure</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Walk each closure:</span>
  <span class='z'>**   1.  Find all the shadowed variables</span>
  <span class='z'>**   2.  Call addVarToClosure for each shadowed variable</span>
  <span class='z'>**   3.  If needed do expr tree walk</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='processClosure'>processClosure</span><span class='b'>(</span>ClosureExpr closure<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// get the variables shadowed from enclosing scope</span>
    shadowed := closure.doCall.vars.findAll |var| <span class='b'>{</span> var.shadows != <span class='k'>null</span> <span class='b'>}</span>

    <span class='y'>// process each shadowed variable</span>
    shadowed.each |var, i| <span class='b'>{</span> addVarToClosure<span class='b'>(</span>closure, var, var.name+<span class='s'>"\$"</span>+i<span class='b'>)</span> <span class='b'>}</span>

    <span class='y'>// if any of the shadowed variables are wrapped we need</span>
    <span class='y'>// to walk the expression tree</span>
    walkExprTree := shadowed.any |var| <span class='b'>{</span> var.isWrapped <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>walkExprTree<span class='b'>)</span> closure.doCall.code.walkExpr |expr|
    <span class='b'>{</span>
      expr.id === ExprId.localVar ? fixWrappedVar<span class='b'>(</span>expr<span class='b'>)</span> : expr
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** For each variable enclosed by the closure:</span>
  <span class='z'>**  1. Add field on the closure to store variable</span>
  <span class='z'>**  2. Add param to as closure constructor</span>
  <span class='z'>**  3. Pass variable to closure constructor at substitution site</span>
  <span class='z'>**  4. Assign param to field in constructor</span>
  <span class='z'>**  5. Initialize variable in doCall from field</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='addVarToClosure'>addVarToClosure</span><span class='b'>(</span>ClosureExpr closure, MethodVar var, Str name<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check if what we are shadowing is a wrapped param</span>
    <span class='k'>if</span> <span class='b'>(</span>var.shadows.paramWrapper != <span class='k'>null</span><span class='b'>)</span>
      var.shadows = var.shadows.paramWrapper

    <span class='y'>// check if shadowed var has been wrapped</span>
    <span class='k'>if</span> <span class='b'>(</span>var.shadows.isWrapped<span class='b'>)</span>
    <span class='b'>{</span>
      var.ctype = var.shadows.ctype
      var.wrapField = var.shadows.wrapField
    <span class='b'>}</span>

    loc := closure.loc
    field := addToClosure<span class='b'>(</span>closure, name, LocalVarExpr.makeNoUnwrap<span class='b'>(</span>loc, var.shadows<span class='b'>))</span>

    <span class='y'>// load from field to local in beginning of doCall</span>
    loadLocal := BinaryExpr.makeAssign<span class='b'>(</span>LocalVarExpr.makeNoUnwrap<span class='b'>(</span>loc, var<span class='b'>)</span>, fieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc<span class='b'>)</span>, field<span class='b'>))</span>
    closure.doCall.code.stmts.insert<span class='b'>(</span>0, loadLocal.toStmt<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** This method is called by ClosureExpr to auto-generate the</span>
  <span class='z'>** implicit outer "this" field in the Closure's implementation</span>
  <span class='z'>** class:</span>
  <span class='z'>**   1. Add $this field to closure's anonymous class</span>
  <span class='z'>**   2. Add $this param to closure's make constructor</span>
  <span class='z'>**   3. Pass this to closure constructor at substitute site</span>
  <span class='z'>**   4. Set field from param in constructor</span>
  <span class='z'>**</span>
  <span class='k'>static</span> CField <span id='makeOuterThisField'>makeOuterThisField</span><span class='b'>(</span>ClosureExpr closure<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// pass this to subtitute closure constructor</span>
    loc := closure.loc
    Expr? subArg
    <span class='k'>if</span> <span class='b'>(</span>closure.enclosingClosure != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// if this is a nested closure, then we have to get $this</span>
      <span class='y'>// from it's own $this field</span>
      outerThis := closure.enclosingClosure.outerThisField
      subArg = fieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc<span class='b'>)</span>, outerThis<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// outer most closure just uses this</span>
      subArg = ThisExpr<span class='b'>(</span>loc, closure.enclosingType<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='k'>return</span> addToClosure<span class='b'>(</span>closure, <span class='s'>"\$this"</span>, subArg<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Common code between addVarToClosure and makeOuterThisField.</span>
  <span class='z'>** Return storage field for closure variable.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> <span class='k'>static</span> FieldDef <span id='addToClosure'>addToClosure</span><span class='b'>(</span>ClosureExpr closure, Str name, Expr subtituteArg<span class='b'>)</span>
  <span class='b'>{</span>
    loc      := closure.loc
    thisType := closure.enclosingType
    implType := closure.cls
    ctype    := subtituteArg.ctype

    <span class='y'>// define storage field on closure class</span>
    field := FieldDef<span class='b'>(</span>loc, implType<span class='b'>)</span>
    field.name  = name
    field.flags = syntheticFieldFlags
    field.fieldType = ctype
    implType.addSlot<span class='b'>(</span>field<span class='b'>)</span>

    <span class='y'>// pass variable to subtitute closure constructor in outer scope</span>
    closure.substitute.args.add<span class='b'>(</span>subtituteArg<span class='b'>)</span>

    <span class='y'>// add parameter to constructor</span>
    ctor := implType.methodDef<span class='b'>(</span><span class='s'>"make"</span><span class='b'>)</span>
    pvar := ctor.addParamVar<span class='b'>(</span>ctype, name<span class='b'>)</span>

    <span class='y'>// set field in constructor</span>
    assign := BinaryExpr.makeAssign<span class='b'>(</span>fieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc<span class='b'>)</span>, field<span class='b'>)</span>, LocalVarExpr.makeNoUnwrap<span class='b'>(</span>loc, pvar<span class='b'>))</span>
    ctor.code.stmts.insert<span class='b'>(</span>0, assign.toStmt<span class='b'>)</span>

    <span class='k'>return</span> field
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Generate Wrapper</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Given a variable type, generate a wrapper class of the format:</span>
  <span class='z'>**</span>
  <span class='z'>**   class Wrap$ctype[$n] { CType val }</span>
  <span class='z'>**</span>
  <span class='z'>** Wrappers are used to manage variables on the heap so that they</span>
  <span class='z'>** can be shared between methods and closures.  We generate one</span>
  <span class='z'>** wrapper class per variable type per pod with potentially a</span>
  <span class='z'>** non-nullable and nullable variant ($n suffix).</span>
  <span class='z'>**</span>
  <span class='z'>** Eventually we'd probably like to share wrappers for common types</span>
  <span class='z'>** like Int, Str, Obj, etc.</span>
  <span class='z'>**</span>
  <span class='z'>** Return the val field of the wrapper.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> CField <span id='genWrapper'>genWrapper</span><span class='b'>(</span>CompilerSupport cs, CType ctype<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// build class name key</span>
    suffix := ctype.isNullable ? <span class='s'>"\$n"</span> : <span class='s'>""</span>
    podName := ctype.pod.name != <span class='s'>"sys"</span> ? <span class='s'>"\$"</span> + ctype.pod.name : <span class='s'>""</span>
    name := <span class='s'>"Wrap"</span> + podName + <span class='s'>"\$"</span> + ctype.name + suffix

    <span class='y'>// reuse existing wrapper</span>
    existing := cs.compiler.wrappers<span class='b'>[</span>name<span class='b'>]</span>
    <span class='k'>if</span> <span class='b'>(</span>existing != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> existing

    <span class='y'>// define new wrapper</span>
    loc := Loc<span class='b'>(</span><span class='s'>"synthetic"</span><span class='b'>)</span>
    w := TypeDef<span class='b'>(</span>cs.ns, loc, cs.syntheticsUnit, name<span class='b'>)</span>
    w.flags = FConst.Internal + FConst.Synthetic
    w.base  = cs.ns.objType
    cs.addTypeDef<span class='b'>(</span>w<span class='b'>)</span>

    <span class='y'>// generate val field</span>
    f := FieldDef<span class='b'>(</span>loc, w<span class='b'>)</span>
    f.name = <span class='s'>"val"</span>
    f.fieldType = ctype
    f.flags = syntheticFieldFlags
    w.addSlot<span class='b'>(</span>f<span class='b'>)</span>

    <span class='y'>// generate constructor:  make(T v) { this.val = v }</span>
    ctor := MethodDef<span class='b'>(</span>loc, w<span class='b'>)</span>
    ctor.flags  = FConst.Ctor + FConst.Internal + FConst.Synthetic
    ctor.name   = <span class='s'>"make"</span>
    ctor.ret    = cs.ns.voidType
    param := ParamDef<span class='b'>(</span>loc, ctype, <span class='s'>"v"</span><span class='b'>)</span>
    pvar  := MethodVar.makeForParam<span class='b'>(</span>ctor, 1, param, param.paramType<span class='b'>)</span>
    ctor.params.add<span class='b'>(</span>param<span class='b'>)</span>
    ctor.vars.add<span class='b'>(</span>pvar<span class='b'>)</span>
    ctor.code   = Block<span class='b'>(</span>loc<span class='b'>)</span>
    lhs := fieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc, w<span class='b'>)</span>, f<span class='b'>)</span>
    rhs := LocalVarExpr<span class='b'>(</span>loc, pvar<span class='b'>)</span>
    ctor.code.add<span class='b'>(</span>BinaryExpr.makeAssign<span class='b'>(</span>lhs, rhs<span class='b'>)</span>.toStmt<span class='b'>)</span>
    ctor.code.add<span class='b'>(</span>ReturnStmt.makeSynthetic<span class='b'>(</span>loc<span class='b'>))</span>
    w.addSlot<span class='b'>(</span>ctor<span class='b'>)</span>

    <span class='y'>// cache for reuse</span>
    cs.compiler.wrappers<span class='b'>[</span>name<span class='b'>]</span> = f
    <span class='k'>return</span> f
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Utils</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> <span class='k'>static</span> FieldExpr <span id='fieldExpr'>fieldExpr</span><span class='b'>(</span>Loc loc, Expr target, CField field<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// make sure we don't use accessor</span>
    FieldExpr<span class='b'>(</span>loc, target, field, <span class='k'>false</span><span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> <span class='k'>const</span> <span class='k'>static</span> Int <span id='syntheticFieldFlags'>syntheticFieldFlags</span>:= FConst.Internal+FConst.Storage+FConst.Synthetic

<span class='b'>}</span>

</pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='ClosureVars.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#addToClosure'>addToClosure</a></li>
  <li class='hidden' style='display: block;'><a href='#addVarToClosure'>addVarToClosure</a></li>
  <li class='hidden' style='display: block;'><a href='#fieldExpr'>fieldExpr</a></li>
  <li class='hidden' style='display: block;'><a href='#fixLocalDef'>fixLocalDef</a></li>
  <li class='hidden' style='display: block;'><a href='#fixWrappedParams'>fixWrappedParams</a></li>
  <li class='hidden' style='display: block;'><a href='#fixWrappedVar'>fixWrappedVar</a></li>
  <li style='display: block;'><a href='#genWrapper'>genWrapper</a></li>
  <li class='hidden' style='display: block;'><a href='#initWrapper'>initWrapper</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#makeOuterThisField'>makeOuterThisField</a></li>
  <li class='hidden' style='display: block;'><a href='#processClosure'>processClosure</a></li>
  <li class='hidden' style='display: block;'><a href='#processMethod'>processMethod</a></li>
  <li style='display: block;'><a href='#run'>run</a></li>
  <li class='hidden' style='display: block;'><a href='#scanType'>scanType</a></li>
  <li class='hidden' style='display: block;'><a href='#syntheticFieldFlags'>syntheticFieldFlags</a></li>
  <li style='display: block;'><a href='#visitExpr'>visitExpr</a></li>
  <li style='display: block;'><a href='#visitStmt'>visitStmt</a></li>
  <li class='hidden' style='display: block;'><a href='#walkMethod'>walkMethod</a></li>
  <li class='hidden' style='display: block;'><a href='#wrapNonFinalVars'>wrapNonFinalVars</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

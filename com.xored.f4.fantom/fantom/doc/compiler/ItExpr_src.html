<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::ItExpr</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='ItExpr.html'>ItExpr</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::ItExpr</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='Node.html'>compiler::Node</a>
    <a href='Expr.html'>compiler::Expr</a>
      <a href='LocalVarExpr.html'>compiler::LocalVarExpr</a>
        compiler::ItExpr</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   19 Jul 06  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Expr</span>
<span class='z'>**</span>
<span class='k'>abstract</span> <span class='k'>class</span> Expr : Node
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Construction</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ExprId id<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.id = id
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Expr</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return this expression as an Int literal usable in a tableswitch,</span>
  <span class='z'>** or null if this Expr doesn't represent a constant Int.  Expressions</span>
  <span class='z'>** which work as table switch cases: int literals and enum constants</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Int? asTableSwitchCase<span class='b'>()</span> <span class='b'>{</span> <span class='k'>null</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get this expression's type as a string for error reporting.</span>
  <span class='z'>**</span>
  Str toTypeStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>id == ExprId.nullLiteral<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"null"</span>
    <span class='k'>return</span> ctype.toStr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this expression performs assignment, then return</span>
  <span class='z'>** the target of that assignment.  Otherwise return null.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Obj? assignTarget<span class='b'>()</span> <span class='b'>{</span> <span class='k'>null</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this expression can be used as the</span>
  <span class='z'>** left hand side of an assignment expression.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is this a boolean conditional (boolOr/boolAnd)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool isCond<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Does this expression make up a complete statement.</span>
  <span class='z'>** If you override this to true, then you must make sure</span>
  <span class='z'>** the expr is popped in CodeAsm.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool isStmt<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Was this expression generated by the compiler (not necessarily</span>
  <span class='z'>** everything auto-generated has this flag true, but we set in</span>
  <span class='z'>** cases where error checking needs to be handled special)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool synthetic<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this an assignment expression, then return the</span>
  <span class='z'>** result of calling the given function with the LHS.</span>
  <span class='z'>** Otherwise return false.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool isDefiniteAssign<span class='b'>(</span>|Expr lhs-&gt;Bool| f<span class='b'>)</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this expression is guaranteed to sometimes</span>
  <span class='z'>** return a null result (safe invoke, as, etc)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool isAlwaysNullable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Assignments to instance fields require a temporary local variable.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool assignRequiresTempVar<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this expression represents the same variable or</span>
  <span class='z'>** field as that.  This is used for self assignment checks.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool sameVarAs<span class='b'>(</span>Expr that<span class='b'>)</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Map the list of expressions into their list of types</span>
  <span class='z'>**</span>
  <span class='k'>static</span> CType<span class='b'>[]</span> ctypes<span class='b'>(</span>Expr<span class='b'>[]</span> exprs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> exprs.map |Expr e-&gt;CType| <span class='b'>{</span> e.ctype <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Given a list of Expr instances, find the common base type</span>
  <span class='z'>** they all share.  This method does not take into account</span>
  <span class='z'>** the null literal.  It is used for type inference for lists</span>
  <span class='z'>** and maps.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> CType commonType<span class='b'>(</span>CNamespace ns, Expr<span class='b'>[]</span> exprs<span class='b'>)</span>
  <span class='b'>{</span>
    hasNull := <span class='k'>false</span>
    exprs = exprs.exclude |Expr e-&gt;Bool|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>e.id !== ExprId.nullLiteral<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
      hasNull = <span class='k'>true</span>
      <span class='k'>return</span> <span class='k'>true</span>
    <span class='b'>}</span>
    t := CType.common<span class='b'>(</span>ns, ctypes<span class='b'>(</span>exprs<span class='b'>))</span>
    <span class='k'>if</span> <span class='b'>(</span>hasNull<span class='b'>)</span> t = t.toNullable
    <span class='k'>return</span> t
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return this expression as an ExprStmt</span>
  <span class='z'>**</span>
  ExprStmt toStmt<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> ExprStmt<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return this expression as serialization text or</span>
  <span class='z'>** throw exception if not serializable.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>throw</span> CompilerErr<span class='b'>(</span><span class='s'>"'$id' not serializable"</span>, loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Make an Expr which will serialize the given literal.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Expr makeForLiteral<span class='b'>(</span>Loc loc, CNamespace ns, Obj val<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>val.typeof<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> Bool#:
        <span class='k'>return</span> val == <span class='k'>true</span> ?
          LiteralExpr<span class='b'>(</span>loc, ExprId.trueLiteral, ns.boolType, <span class='k'>true</span><span class='b'>)</span> :
          LiteralExpr<span class='b'>(</span>loc, ExprId.falseLiteral, ns.boolType, <span class='k'>false</span><span class='b'>)</span>
      <span class='k'>case</span> Str#:
        <span class='k'>return</span> LiteralExpr<span class='b'>(</span>loc, ExprId.strLiteral, ns.strType, val<span class='b'>)</span>
      <span class='k'>case</span> DateTime#:

        <span class='k'>return</span> CallExpr<span class='b'>(</span>loc, <span class='k'>null</span>, <span class='s'>"fromStr"</span>, ExprId.construction<span class='b'>)</span>
        <span class='b'>{</span>
          method = ns.resolveSlot<span class='b'>(</span><span class='s'>"sys::DateTime.fromStr"</span><span class='b'>)</span>
          ctype  = method.parent
          args   = <span class='b'>[</span>makeForLiteral<span class='b'>(</span>loc, ns, val.toStr<span class='b'>)]</span>
        <span class='b'>}</span>
      <span class='k'>default</span>:
        <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Unsupported literal type $val.typeof"</span><span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Set this expression to not be left on the stack.</span>
  <span class='z'>**</span>
  Expr noLeave<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// if the expression is prefixed with a synthetic cast by</span>
    <span class='y'>// CallResolver, it is unnecessary at the top level and must</span>
    <span class='y'>// be stripped</span>
    result := <span class='k'>this</span>
    <span class='k'>if</span> <span class='b'>(</span>result.id === ExprId.coerce<span class='b'>)</span>
    <span class='b'>{</span>
      coerce := <span class='b'>(</span>TypeCheckExpr<span class='b'>)</span>result
      <span class='k'>if</span> <span class='b'>(</span>coerce.synthetic<span class='b'>)</span> result = coerce.target
    <span class='b'>}</span>
    result.leave = <span class='k'>false</span>
    <span class='k'>return</span> result
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Doc</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get this expression as a string suitable for documentation.</span>
  <span class='z'>**</span>
  Str? toDocStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// not perfect, but better than what we had previously which</span>
    <span class='y'>// was nothing; we might want to grab the actual text from the</span>
    <span class='y'>// actual source file - but with the current design we've freed</span>
    <span class='y'>// the buffer by the time the tokens are passed to the parser</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='y'>// if we access an internal slot then don't expose in public docs</span>
      CSlot? slot := <span class='k'>null</span>
      <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> <span class='k'>is</span> CallExpr<span class='b'>)</span> slot = <span class='b'>((</span>CallExpr<span class='b'>)</span><span class='k'>this</span><span class='b'>)</span>.method
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> <span class='k'>is</span> FieldExpr<span class='b'>)</span> slot = <span class='b'>((</span>FieldExpr<span class='b'>)</span><span class='k'>this</span><span class='b'>)</span>.field
      <span class='k'>if</span> <span class='b'>(</span>slot != <span class='k'>null</span> &amp;&amp; <span class='b'>(</span>slot.isPrivate || slot.isInternal<span class='b'>))</span> <span class='k'>return</span> <span class='k'>null</span>

      <span class='y'>// remove extra parens with binary ops</span>
      s := toStr
      <span class='k'>if</span> <span class='b'>(</span>s<span class='b'>[</span>0<span class='b'>]</span> == <span class='s'>'('</span> &amp;&amp; s<span class='b'>[</span>-1<span class='b'>]</span> == <span class='s'>')'</span><span class='b'>)</span> s = s<span class='b'>[</span>1..-2<span class='b'>]</span>

      <span class='y'>// hide implicit assignments</span>
      <span class='k'>if</span> <span class='b'>(</span>s.contains<span class='b'>(</span><span class='s'>"="</span><span class='b'>))</span> s = s<span class='b'>[</span>s.index<span class='b'>(</span><span class='s'>"="</span><span class='b'>)</span>+1..-1<span class='b'>]</span>.trim

      <span class='y'>// remove extra parens with binary ops</span>
      <span class='k'>if</span> <span class='b'>(</span>s<span class='b'>[</span>0<span class='b'>]</span> == <span class='s'>'('</span> &amp;&amp; s<span class='b'>[</span>-1<span class='b'>]</span> == <span class='s'>')'</span><span class='b'>)</span> s = s<span class='b'>[</span>1..-2<span class='b'>]</span>

      <span class='y'>// hide storage operator</span>
      s = s.replace<span class='b'>(</span><span class='s'>".@"</span>, <span class='s'>"."</span><span class='b'>)</span>

      <span class='y'>// hide safe nav construction</span>
      s = s.replace<span class='b'>(</span><span class='s'>".?("</span>, <span class='s'>"("</span><span class='b'>)</span>

      <span class='y'>// use unqualified names</span>
      <span class='k'>while</span> <span class='b'>(</span><span class='k'>true</span><span class='b'>)</span>
      <span class='b'>{</span>
        qcolon := s.index<span class='b'>(</span><span class='s'>"::"</span><span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>qcolon == <span class='k'>null</span><span class='b'>)</span> <span class='k'>break</span>
        i := qcolon-1
        <span class='k'>for</span> <span class='b'>(</span>; i&gt;=0; --i<span class='b'>)</span> <span class='k'>if</span> <span class='b'>(</span>!s<span class='b'>[</span>i<span class='b'>]</span>.isAlphaNum &amp;&amp; s<span class='b'>[</span>i<span class='b'>]</span> != <span class='s'>'_'</span><span class='b'>)</span> <span class='k'>break</span>
        s = <span class='b'>(</span>i &lt; 0<span class='b'>)</span> ? s<span class='b'>[</span>qcolon+2..-1<span class='b'>]</span> : s<span class='b'>[</span>0..i<span class='b'>]</span> + s<span class='b'>[</span>qcolon+2..-1<span class='b'>]</span>
      <span class='b'>}</span>

      <span class='k'>if</span> <span class='b'>(</span>s.size &gt; 40<span class='b'>)</span> s = <span class='s'>"..."</span>
      <span class='k'>return</span> s
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='b'>(</span>Err e<span class='b'>)</span>
    <span class='b'>{</span>
      e.trace
      <span class='k'>return</span> toStr
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Tree</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  Expr walk<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    walkChildren<span class='b'>(</span>v<span class='b'>)</span>
    <span class='k'>return</span> v.visitExpr<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>virtual</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

  <span class='k'>static</span> Expr? walkExpr<span class='b'>(</span>Visitor v, Expr? expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    <span class='k'>return</span> expr.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>static</span> Expr<span class='b'>[]</span> walkExprs<span class='b'>(</span>Visitor v, Expr?<span class='b'>[]</span> exprs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;exprs.size; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      expr := exprs<span class='b'>[</span>i<span class='b'>]</span>
      <span class='k'>if</span> <span class='b'>(</span>expr != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        replace := expr.walk<span class='b'>(</span>v<span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>expr !== replace<span class='b'>)</span>
          exprs<span class='b'>[</span>i<span class='b'>]</span> = replace
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>return</span> exprs
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Debug</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> <span class='k'>abstract</span> Str toStr<span class='b'>()</span>

  <span class='k'>override</span> Void print<span class='b'>(</span>AstWriter out<span class='b'>)</span>
  <span class='b'>{</span>
    out.w<span class='b'>(</span>toStr<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>readonly</span> ExprId id      <span class='y'>// expression type identifier</span>
  CType? ctype            <span class='y'>// type expression resolves to</span>
  Bool leave := <span class='k'>true</span> <span class='b'>{</span> <span class='k'>protected</span> set <span class='b'>}</span> <span class='y'>// leave this expression on the stack</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** LiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** LiteralExpr puts an Bool, Int, Float, Str, Duration, Uri,</span>
<span class='z'>** or null constant onto the stack.</span>
<span class='z'>**</span>
<span class='k'>class</span> LiteralExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ExprId id, CType ctype, Obj? val<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
    <span class='k'>this</span>.val   = val
    <span class='k'>if</span> <span class='b'>(</span>val == <span class='k'>null</span> &amp;&amp; !ctype.isNullable<span class='b'>)</span>
      <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"null literal must typed as nullable!"</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeNull<span class='b'>(</span>Loc loc, CNamespace ns<span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>loc, ExprId.nullLiteral, ns.objType.toNullable, <span class='k'>null</span><span class='b'>)</span> <span class='b'>{}</span>

  <span class='k'>new</span> makeTrue<span class='b'>(</span>Loc loc, CNamespace ns<span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>loc, ExprId.trueLiteral, ns.boolType, <span class='k'>true</span><span class='b'>)</span> <span class='b'>{}</span>

  <span class='k'>new</span> makeFalse<span class='b'>(</span>Loc loc, CNamespace ns<span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>loc, ExprId.falseLiteral, ns.boolType, <span class='k'>false</span><span class='b'>)</span> <span class='b'>{}</span>

  <span class='k'>new</span> makeStr<span class='b'>(</span>Loc loc, CNamespace ns, Str val<span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>loc, ExprId.strLiteral, ns.strType, val<span class='b'>)</span> <span class='b'>{}</span>

  <span class='k'>static</span> LiteralExpr makeDefaultLiteral<span class='b'>(</span>Loc loc, CNamespace ns, CType ctype<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!ctype.isNullable<span class='b'>())</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>ctype.isBool<span class='b'>())</span>  <span class='k'>return</span> make<span class='b'>(</span>loc, ExprId.falseLiteral, ctype, <span class='k'>false</span><span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>ctype.isInt<span class='b'>())</span>   <span class='k'>return</span> make<span class='b'>(</span>loc, ExprId.intLiteral, ctype, 0<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>ctype.isFloat<span class='b'>())</span> <span class='k'>return</span> make<span class='b'>(</span>loc, ExprId.floatLiteral, ctype, 0f<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> makeNull<span class='b'>(</span>loc, ns<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAlwaysNullable<span class='b'>()</span> <span class='b'>{</span> id === ExprId.nullLiteral <span class='b'>}</span>

  <span class='k'>override</span> Int? asTableSwitchCase<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> val <span class='k'>as</span> Int
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.nullLiteral:     <span class='k'>return</span> <span class='s'>"null"</span>
      <span class='k'>case</span> ExprId.falseLiteral:    <span class='k'>return</span> <span class='s'>"false"</span>
      <span class='k'>case</span> ExprId.trueLiteral:     <span class='k'>return</span> <span class='s'>"true"</span>
      <span class='k'>case</span> ExprId.intLiteral:      <span class='k'>return</span> val.toStr
      <span class='k'>case</span> ExprId.floatLiteral:    <span class='k'>return</span> val.toStr + <span class='s'>"f"</span>
      <span class='k'>case</span> ExprId.decimalLiteral:  <span class='k'>return</span> val.toStr + <span class='s'>"d"</span>
      <span class='k'>case</span> ExprId.strLiteral:      <span class='k'>return</span> val.toStr.toCode
      <span class='k'>case</span> ExprId.uriLiteral:      <span class='k'>return</span> val.toStr.toCode<span class='b'>(</span><span class='s'>'`'</span><span class='b'>)</span>
      <span class='k'>case</span> ExprId.typeLiteral:     <span class='k'>return</span> <span class='s'>"${val-&gt;signature}#"</span>
      <span class='k'>case</span> ExprId.durationLiteral: <span class='k'>return</span> val.toStr
      <span class='k'>default</span>:                     <span class='k'>return</span> <span class='k'>super</span>.serialize
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.nullLiteral: <span class='k'>return</span> <span class='s'>"null"</span>
      <span class='k'>case</span> ExprId.strLiteral:  <span class='k'>return</span> <span class='s'>"\""</span> + val.toStr.replace<span class='b'>(</span><span class='s'>"\n"</span>, <span class='s'>"\\n"</span><span class='b'>)</span> + <span class='s'>"\""</span>
      <span class='k'>case</span> ExprId.typeLiteral: <span class='k'>return</span> <span class='s'>"${val}#"</span>
      <span class='k'>case</span> ExprId.uriLiteral:  <span class='k'>return</span> <span class='s'>"`$val`"</span>
      <span class='k'>default</span>: <span class='k'>return</span> val.toStr
    <span class='b'>}</span>
  <span class='b'>}</span>

  Obj? val <span class='y'>// Bool, Int, Float, Str (for Str/Uri), Duration, CType, or null</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** LocaleLiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** LocaleLiteralExpr: podName::key=defVal</span>
<span class='z'>**</span>
<span class='k'>class</span> LocaleLiteralExpr: Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, Str pattern<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.localeLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.pattern = pattern
    <span class='k'>this</span>.key = pattern
    eq := pattern.index<span class='b'>(</span><span class='s'>"="</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>eq != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.key = pattern<span class='b'>[</span>0..&lt;eq<span class='b'>]</span>
      <span class='k'>this</span>.def = pattern<span class='b'>[</span>eq+1..-1<span class='b'>]</span>
    <span class='b'>}</span>

    colons := key.index<span class='b'>(</span><span class='s'>"::"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>colons != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.podName = key<span class='b'>[</span>0..&lt;colons<span class='b'>]</span>
      <span class='k'>this</span>.key     = key<span class='b'>[</span>colons+2..-1<span class='b'>]</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"&lt;${pattern}&gt;"</span> <span class='b'>}</span>

  Str pattern
  Str key
  Str? podName
  Str? def
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** SlotLiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** SlotLiteralExpr</span>
<span class='z'>**</span>
<span class='k'>class</span> SlotLiteralExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType parent, Str name<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.slotLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.parent = parent
    <span class='k'>this</span>.name = name
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"$parent.signature#${name}"</span> <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"$parent.signature#${name}"</span> <span class='b'>}</span>

  CType parent
  Str name
  CSlot? slot
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** RangeLiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** RangeLiteralExpr creates a Range instance</span>
<span class='z'>**</span>
<span class='k'>class</span> RangeLiteralExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType ctype, Expr start, Expr end, Bool exclusive<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.rangeLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
    <span class='k'>this</span>.start = start
    <span class='k'>this</span>.end   = end
    <span class='k'>this</span>.exclusive = exclusive
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    start = start.walk<span class='b'>(</span>v<span class='b'>)</span>
    end   = end.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>exclusive<span class='b'>)</span>
      <span class='k'>return</span> <span class='s'>"${start}...${end}"</span>
    <span class='k'>else</span>
      <span class='k'>return</span> <span class='s'>"${start}..${end}"</span>
  <span class='b'>}</span>

  Expr start
  Expr end
  Bool exclusive
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ListLiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ListLiteralExpr creates a List instance</span>
<span class='z'>**</span>
<span class='k'>class</span> ListLiteralExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ListType? explicitType := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.listLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.explicitType = explicitType
  <span class='b'>}</span>

  <span class='k'>new</span> makeFor<span class='b'>(</span>Loc loc, CType ctype, Expr<span class='b'>[]</span> vals<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>loc, ExprId.listLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
    <span class='k'>this</span>.vals  = vals
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    vals = walkExprs<span class='b'>(</span>v, vals<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> format |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> e.serialize <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> format |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> e.toStr <span class='b'>}</span>
  <span class='b'>}</span>

  Str format<span class='b'>(</span>|Expr e-&gt;Str| f<span class='b'>)</span>
  <span class='b'>{</span>
    s := StrBuf.make
    <span class='k'>if</span> <span class='b'>(</span>explicitType != <span class='k'>null</span><span class='b'>)</span> s.add<span class='b'>(</span>explicitType.v<span class='b'>)</span>
    s.add<span class='b'>(</span><span class='s'>"["</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>vals.isEmpty<span class='b'>)</span> s.add<span class='b'>(</span><span class='s'>","</span><span class='b'>)</span>
    <span class='k'>else</span> vals.each |Expr v, Int i|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>i &gt; 0<span class='b'>)</span> s.add<span class='b'>(</span><span class='s'>","</span><span class='b'>)</span>
      s.add<span class='b'>(</span>f<span class='b'>(</span>v<span class='b'>))</span>
    <span class='b'>}</span>
    s.add<span class='b'>(</span><span class='s'>"]"</span><span class='b'>)</span>
    <span class='k'>return</span> s.toStr
  <span class='b'>}</span>

  ListType? explicitType
  Expr<span class='b'>[]</span> vals := Expr<span class='b'>[</span>,<span class='b'>]</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** MapLiteralExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** MapLiteralExpr creates a List instance</span>
<span class='z'>**</span>
<span class='k'>class</span> MapLiteralExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, MapType? explicitType := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.mapLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.explicitType = explicitType
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    keys = walkExprs<span class='b'>(</span>v, keys<span class='b'>)</span>
    vals = walkExprs<span class='b'>(</span>v, vals<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> format |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> e.serialize <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> format |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> e.toStr <span class='b'>}</span>
  <span class='b'>}</span>

  Str format<span class='b'>(</span>|Expr e-&gt;Str| f<span class='b'>)</span>
  <span class='b'>{</span>
    s := StrBuf.make
    <span class='k'>if</span> <span class='b'>(</span>explicitType != <span class='k'>null</span><span class='b'>)</span> s.add<span class='b'>(</span>explicitType<span class='b'>)</span>
    s.add<span class='b'>(</span><span class='s'>"["</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>vals.isEmpty<span class='b'>)</span> s.add<span class='b'>(</span><span class='s'>":"</span><span class='b'>)</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      keys.size.times |Int i|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>i &gt; 0<span class='b'>)</span> s.add<span class='b'>(</span><span class='s'>","</span><span class='b'>)</span>
        s.add<span class='b'>(</span>f<span class='b'>(</span>keys<span class='b'>[</span>i<span class='b'>]))</span>.add<span class='b'>(</span><span class='s'>":"</span><span class='b'>)</span>.add<span class='b'>(</span>f<span class='b'>(</span>vals<span class='b'>[</span>i<span class='b'>]))</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    s.add<span class='b'>(</span><span class='s'>"]"</span><span class='b'>)</span>
    <span class='k'>return</span> s.toStr
  <span class='b'>}</span>

  MapType? explicitType
  Expr<span class='b'>[]</span> keys := Expr<span class='b'>[</span>,<span class='b'>]</span>
  Expr<span class='b'>[]</span> vals := Expr<span class='b'>[</span>,<span class='b'>]</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** UnaryExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** UnaryExpr is used for unary expressions including !, +.</span>
<span class='z'>** Note that - is mapped to negate() as a shortcut method.</span>
<span class='z'>**</span>
<span class='k'>class</span> UnaryExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ExprId id, Token opToken, Expr operand<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.opToken = opToken
    <span class='k'>this</span>.operand = operand
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    operand = operand.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>id == ExprId.cmpNull<span class='b'>)</span>
      <span class='k'>return</span> operand.toStr + <span class='s'>" == null"</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>id == ExprId.cmpNotNull<span class='b'>)</span>
      <span class='k'>return</span> operand.toStr + <span class='s'>" != null"</span>
    <span class='k'>else</span>
      <span class='k'>return</span> opToken.toStr + operand.toStr
  <span class='b'>}</span>

  Token opToken   <span class='y'>// operator token type (Token.bang, etc)</span>
  Expr operand    <span class='y'>// operand expression</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** BinaryExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** BinaryExpr is used for binary expressions with a left hand side and a</span>
<span class='z'>** right hand side including assignment.  Note that many common binary</span>
<span class='z'>** operations are actually modeled as ShortcutExpr to enable method based</span>
<span class='z'>** operator overloading.</span>
<span class='z'>**</span>
<span class='k'>class</span> BinaryExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Expr lhs, Token opToken, Expr rhs<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>lhs.loc, opToken.toExprId<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.lhs = lhs
    <span class='k'>this</span>.opToken = opToken
    <span class='k'>this</span>.rhs = rhs
  <span class='b'>}</span>

  <span class='k'>new</span> makeAssign<span class='b'>(</span>Expr lhs, Expr rhs, Bool leave := <span class='k'>false</span><span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>lhs, Token.assign, rhs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = lhs.ctype
    <span class='k'>this</span>.leave = leave
  <span class='b'>}</span>

  <span class='k'>override</span> Obj? assignTarget<span class='b'>()</span> <span class='b'>{</span> id === ExprId.assign ? lhs : <span class='k'>null</span> <span class='b'>}</span>

  <span class='k'>override</span> Bool isStmt<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> id === ExprId.assign <span class='b'>}</span>

  <span class='k'>override</span> Bool isDefiniteAssign<span class='b'>(</span>|Expr lhs-&gt;Bool| f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>id === ExprId.assign &amp;&amp; f<span class='b'>(</span>lhs<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>
    <span class='k'>return</span> rhs.isDefiniteAssign<span class='b'>(</span>f<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    lhs = lhs.walk<span class='b'>(</span>v<span class='b'>)</span>
    rhs = rhs.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>id === ExprId.assign<span class='b'>)</span>
      <span class='k'>return</span> <span class='s'>"${lhs.serialize}=${rhs.serialize}"</span>
    <span class='k'>else</span>
      <span class='k'>return</span> <span class='k'>super</span>.serialize
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"($lhs $opToken $rhs)"</span>
  <span class='b'>}</span>

  Token opToken      <span class='y'>// operator token type (Token.and, etc)</span>
  Expr lhs           <span class='y'>// left hand side</span>
  Expr rhs           <span class='y'>// right hand side</span>
  MethodVar? tempVar <span class='y'>// temp local var to store field assignment leaves</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** CondExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** CondExpr is used for || and &amp;&amp; short-circuit boolean conditionals.</span>
<span class='z'>**</span>
<span class='k'>class</span> CondExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Expr first, Token opToken<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>first.loc, opToken.toExprId<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.opToken = opToken
    <span class='k'>this</span>.operands = <span class='b'>[</span>first<span class='b'>]</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isCond<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>true</span> <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    operands = walkExprs<span class='b'>(</span>v, operands<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> operands.join<span class='b'>(</span><span class='s'>" $opToken "</span><span class='b'>)</span>
  <span class='b'>}</span>

  Token opToken      <span class='y'>// operator token type (Token.and, etc)</span>
  Expr<span class='b'>[]</span> operands    <span class='y'>// list of operands</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** NameExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** NameExpr is the base class for an identifier expression which has</span>
<span class='z'>** an optional base expression.  NameExpr is the base class for</span>
<span class='z'>** UnknownVarExpr and CallExpr which are resolved via CallResolver</span>
<span class='z'>**</span>
<span class='k'>abstract</span> <span class='k'>class</span> NameExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ExprId id, Expr? target, Str? name<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.target = target
    <span class='k'>this</span>.name   = name
    <span class='k'>this</span>.isSafe = <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAlwaysNullable<span class='b'>()</span> <span class='b'>{</span> isSafe <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    target = walkExpr<span class='b'>(</span>v, target<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>target != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> target.toStr + <span class='b'>(</span>isSafe ? <span class='s'>"?."</span> : <span class='s'>"."</span><span class='b'>)</span> + name
    <span class='k'>else</span>
      <span class='k'>return</span> name
  <span class='b'>}</span>

  Expr? target  <span class='y'>// base target expression or null</span>
  Str? name     <span class='y'>// name of variable (local/field/method)</span>
  Bool isSafe   <span class='y'>// if ?. operator</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** UnknownVarExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** UnknownVarExpr is a place holder in the AST for a variable until</span>
<span class='z'>** we can figure out what it references: local or slot.  We also use</span>
<span class='z'>** this class for storage operators before they are resolved to a field.</span>
<span class='z'>**</span>
<span class='k'>class</span> UnknownVarExpr : NameExpr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, Expr? target, Str name<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.unknownVar, target, name<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeStorage<span class='b'>(</span>Loc loc, Expr? target, Str name<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>loc, ExprId.storage, target, name<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** CallExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** CallExpr is a method call.</span>
<span class='z'>**</span>
<span class='k'>class</span> CallExpr : NameExpr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, Expr? target := <span class='k'>null</span>, Str? name := <span class='k'>null</span>, ExprId id := ExprId.call<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id, target, name<span class='b'>)</span>
  <span class='b'>{</span>
    args = Expr<span class='b'>[</span>,<span class='b'>]</span>
    isDynamic = <span class='k'>false</span>
    isSafe = <span class='k'>false</span>
    isCtorChain = <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeWithMethod<span class='b'>(</span>Loc loc, Expr? target, CMethod method, Expr<span class='b'>[]</span>? args := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>this</span>.make<span class='b'>(</span>loc, target, method.name, ExprId.call<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.method = method
    <span class='k'>this</span>.ctype = method.isCtor ? method.parent : method.returnType
    <span class='k'>if</span> <span class='b'>(</span>args != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.args = args
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> toCallStr<span class='b'>(</span><span class='k'>true</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isDefiniteAssign<span class='b'>(</span>|Expr lhs-&gt;Bool| f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>target != <span class='k'>null</span> &amp;&amp; target.isDefiniteAssign<span class='b'>(</span>f<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>
    <span class='k'>return</span> args.any |Expr arg-&gt;Bool| <span class='b'>{</span> arg.isDefiniteAssign<span class='b'>(</span>f<span class='b'>)</span> <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isStmt<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// stand alone constructor is not a valid stmt</span>
    <span class='k'>if</span> <span class='b'>(</span>method.isCtor<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// with block applied to stand alone constructor is not valid stmt</span>
    <span class='k'>if</span> <span class='b'>(</span>method.name == <span class='s'>"with"</span> &amp;&amp; target <span class='k'>is</span> CallExpr &amp;&amp; <span class='b'>((</span>CallExpr<span class='b'>)</span>target<span class='b'>)</span>.method.isCtor<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// consider any other call a stand alone stmt</span>
    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>virtual</span> Bool isCompare<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    target = walkExpr<span class='b'>(</span>v, target<span class='b'>)</span>
    args = walkExprs<span class='b'>(</span>v, args<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// only serialize a true Type("xx") expr which maps to Type.fromStr</span>
    <span class='k'>if</span> <span class='b'>(</span>id != ExprId.construction || method.name != <span class='s'>"fromStr"</span><span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>super</span>.serialize

    argSer := args.join<span class='b'>(</span><span class='s'>","</span><span class='b'>)</span> |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> e.serialize <span class='b'>}</span>
    <span class='k'>return</span> <span class='s'>"$method.parent($argSer)"</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void print<span class='b'>(</span>AstWriter out<span class='b'>)</span>
  <span class='b'>{</span>
    out.w<span class='b'>(</span>toCallStr<span class='b'>(</span><span class='k'>false</span><span class='b'>))</span>
    <span class='k'>if</span> <span class='b'>(</span>args.size &gt; 0 &amp;&amp; args.last <span class='k'>is</span> ClosureExpr<span class='b'>)</span>
      args.last.print<span class='b'>(</span>out<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Str toCallStr<span class='b'>(</span>Bool isToStr<span class='b'>)</span>
  <span class='b'>{</span>
    s := StrBuf.make

    <span class='k'>if</span> <span class='b'>(</span>target != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      s.add<span class='b'>(</span>target<span class='b'>)</span>.add<span class='b'>(</span>isSafe ? <span class='s'>"?"</span> : <span class='s'>""</span><span class='b'>)</span>.add<span class='b'>(</span>isDynamic ? <span class='s'>"-&gt;"</span> : <span class='s'>"."</span><span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>method != <span class='k'>null</span> &amp;&amp; <span class='b'>(</span>method.isStatic || method.isCtor<span class='b'>))</span>
      s.add<span class='b'>(</span>method.parent.qname<span class='b'>)</span>.add<span class='b'>(</span><span class='s'>"."</span><span class='b'>)</span>

    s.add<span class='b'>(</span>name<span class='b'>)</span>.add<span class='b'>(</span><span class='s'>"("</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>args.last <span class='k'>is</span> ClosureExpr<span class='b'>)</span>
    <span class='b'>{</span>
      s.add<span class='b'>(</span>args<span class='b'>[</span>0..-2<span class='b'>]</span>.join<span class='b'>(</span><span class='s'>", "</span><span class='b'>))</span>.add<span class='b'>(</span><span class='s'>") "</span><span class='b'>)</span>;
      <span class='k'>if</span> <span class='b'>(</span>isToStr<span class='b'>)</span> s.add<span class='b'>(</span>args.last<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      s.add<span class='b'>(</span>args.join<span class='b'>(</span><span class='s'>", "</span><span class='b'>))</span>.add<span class='b'>(</span><span class='s'>")"</span><span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> s.toStr
  <span class='b'>}</span>

  Expr<span class='b'>[]</span> args         <span class='y'>// Expr[] arguments to pass</span>
  Bool isDynamic      <span class='y'>// true if this is a -&gt; dynamic call</span>
  Bool isCtorChain    <span class='y'>// true if this is MethodDef.ctorChain call</span>
  Bool noParens       <span class='y'>// was this call accessed without parens</span>
  Bool isCallOp       <span class='y'>// was this 'target()' (instead of 'target.name()')</span>
  CMethod? method     <span class='y'>// resolved method</span>
  <span class='k'>override</span> Bool synthetic := <span class='k'>false</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ShortcutExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ShortcutExpr is used for operator expressions which are a shortcut</span>
<span class='z'>** to a method call:</span>
<span class='z'>**   a + b     =&gt;  a.plus(b)</span>
<span class='z'>**   a - b     =&gt;  a.minus(b)</span>
<span class='z'>**   a * b     =&gt;  a.mult(b)</span>
<span class='z'>**   a / b     =&gt;  a.div(b)</span>
<span class='z'>**   a % b     =&gt;  a.mod(b)</span>
<span class='z'>**   a[b]      =&gt;  a.get(b)</span>
<span class='z'>**   a[b] = c  =&gt;  a.set(b, c)</span>
<span class='z'>**   -a        =&gt;  a.negate()</span>
<span class='z'>**   ++a, a++  =&gt;  a.increment()</span>
<span class='z'>**   --a, a--  =&gt;  a.decrement()</span>
<span class='z'>**   a == b    =&gt;  a.equals(b)</span>
<span class='z'>**   a != b    =&gt;  ! a.equals(b)</span>
<span class='z'>**   a &lt;=&gt;     =&gt;  a.compare(b)</span>
<span class='z'>**   a &gt; b     =&gt;  a.compare(b) &gt; 0</span>
<span class='z'>**   a &gt;= b    =&gt;  a.compare(b) &gt;= 0</span>
<span class='z'>**   a &lt; b     =&gt;  a.compare(b) &lt; 0</span>
<span class='z'>**   a &lt;= b    =&gt;  a.compare(b) &lt;= 0</span>
<span class='z'>**</span>
<span class='k'>class</span> ShortcutExpr : CallExpr
<span class='b'>{</span>
  <span class='k'>new</span> makeUnary<span class='b'>(</span>Loc loc, Token opToken, Expr operand<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>loc, <span class='k'>null</span>, <span class='k'>null</span>, ExprId.shortcut<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.op      = opToken.toShortcutOp<span class='b'>(</span>1<span class='b'>)</span>
    <span class='k'>this</span>.opToken = opToken
    <span class='k'>this</span>.name    = op.methodName
    <span class='k'>this</span>.target  = operand
  <span class='b'>}</span>

  <span class='k'>new</span> makeBinary<span class='b'>(</span>Expr lhs, Token opToken, Expr rhs<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>lhs.loc, <span class='k'>null</span>, <span class='k'>null</span>, ExprId.shortcut<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.op      = opToken.toShortcutOp<span class='b'>(</span>2<span class='b'>)</span>
    <span class='k'>this</span>.opToken = opToken
    <span class='k'>this</span>.name    = op.methodName
    <span class='k'>this</span>.target  = lhs
    <span class='k'>this</span>.args.add<span class='b'>(</span>rhs<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeGet<span class='b'>(</span>Loc loc, Expr target, Expr index<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>loc, <span class='k'>null</span>, <span class='k'>null</span>, ExprId.shortcut<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.op      = ShortcutOp.get
    <span class='k'>this</span>.opToken = Token.lbracket
    <span class='k'>this</span>.name    = op.methodName
    <span class='k'>this</span>.target  = target
    <span class='k'>this</span>.args.add<span class='b'>(</span>index<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeFrom<span class='b'>(</span>ShortcutExpr from<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>from.loc, <span class='k'>null</span>, <span class='k'>null</span>, ExprId.shortcut<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.op      = from.op
    <span class='k'>this</span>.opToken = from.opToken
    <span class='k'>this</span>.name    = from.name
    <span class='k'>this</span>.target  = from.target
    <span class='k'>this</span>.args    = from.args
    <span class='k'>this</span>.isPostfixLeave = from.isPostfixLeave
  <span class='b'>}</span>

  <span class='k'>override</span> Bool assignRequiresTempVar<span class='b'>()</span> <span class='b'>{</span> isAssignable <span class='b'>}</span>

  <span class='k'>override</span> Obj? assignTarget<span class='b'>()</span> <span class='b'>{</span> isAssign ? target : <span class='k'>null</span> <span class='b'>}</span>

  <span class='k'>override</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> op === ShortcutOp.get <span class='b'>}</span>

  <span class='k'>override</span> Bool isCompare<span class='b'>()</span> <span class='b'>{</span> op === ShortcutOp.eq || op === ShortcutOp.cmp <span class='b'>}</span>

  <span class='k'>override</span> Bool isStmt<span class='b'>()</span> <span class='b'>{</span> isAssign || op === ShortcutOp.set <span class='b'>}</span>

  Bool isAssign<span class='b'>()</span> <span class='b'>{</span> opToken.isAssign || opToken.isIncrementOrDecrement <span class='b'>}</span>

  Bool isStrConcat<span class='b'>()</span> <span class='b'>{</span> opToken == Token.plus &amp;&amp; args.size == 1 &amp;&amp; target.ctype.isStr <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>op == ShortcutOp.get<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"${target}[$args.first]"</span>
    <span class='k'>if</span> <span class='b'>(</span>op == ShortcutOp.increment<span class='b'>)</span> <span class='k'>return</span> isPostfixLeave ? <span class='s'>"${target}++"</span> : <span class='s'>"++${target}"</span>
    <span class='k'>if</span> <span class='b'>(</span>op == ShortcutOp.decrement<span class='b'>)</span> <span class='k'>return</span> isPostfixLeave ? <span class='s'>"${target}--"</span> : <span class='s'>"--${target}"</span>
    <span class='k'>if</span> <span class='b'>(</span>isAssign<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"${target} ${opToken} ${args.first}"</span>
    <span class='k'>if</span> <span class='b'>(</span>op.degree == 1<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"${opToken}${target}"</span>
    <span class='k'>if</span> <span class='b'>(</span>op.degree == 2<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"(${target} ${opToken} ${args.first})"</span>
    <span class='k'>return</span> <span class='k'>super</span>.toStr
  <span class='b'>}</span>

  <span class='k'>override</span> Void print<span class='b'>(</span>AstWriter out<span class='b'>)</span>
  <span class='b'>{</span>
    out.w<span class='b'>(</span>toStr<span class='b'>())</span>
  <span class='b'>}</span>

  ShortcutOp op
  Token opToken
  Bool isPostfixLeave := <span class='k'>false</span>  <span class='y'>// x++ or x-- (must have Expr.leave set too)</span>
  MethodVar? tempVar    <span class='y'>// temp local var to store += to field/indexed</span>
<span class='b'>}</span>

<span class='z'>**</span>
<span class='z'>** IndexedAssignExpr is a subclass of ShortcutExpr used</span>
<span class='z'>** in situations like x[y] += z where we need keep of two</span>
<span class='z'>** extra scratch variables and the get's matching set method.</span>
<span class='z'>** Note this class models the top x[y] += z, NOT the get target</span>
<span class='z'>** which is x[y].</span>
<span class='z'>**</span>
<span class='z'>** In this example, IndexedAssignExpr shortcuts Int.plus and</span>
<span class='z'>** its target shortcuts List.get:</span>
<span class='z'>**   x := [2]</span>
<span class='z'>**   x[0] += 3</span>
<span class='z'>**</span>
<span class='k'>class</span> IndexedAssignExpr : ShortcutExpr
<span class='b'>{</span>
  <span class='k'>new</span> makeFrom<span class='b'>(</span>ShortcutExpr from<span class='b'>)</span>
    : <span class='k'>super</span>.makeFrom<span class='b'>(</span>from<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

  MethodVar? scratchA
  MethodVar? scratchB
  CMethod? setMethod
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** FieldExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** FieldExpr is used for a field variable access.</span>
<span class='z'>**</span>
<span class='k'>class</span> FieldExpr : NameExpr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, Expr? target := <span class='k'>null</span>, CField? field := <span class='k'>null</span>, Bool useAccessor := <span class='k'>true</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.field, target, <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.useAccessor = useAccessor
    <span class='k'>this</span>.isSafe = <span class='k'>false</span>
    <span class='k'>if</span> <span class='b'>(</span>field != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.name  = field.name
      <span class='k'>this</span>.field = field
      <span class='k'>this</span>.ctype = field.fieldType
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>true</span> <span class='b'>}</span>

  <span class='k'>override</span> Bool assignRequiresTempVar<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> !field.isStatic <span class='b'>}</span>

  <span class='k'>override</span> Bool sameVarAs<span class='b'>(</span>Expr that<span class='b'>)</span>
  <span class='b'>{</span>
    x := that <span class='k'>as</span> FieldExpr
    <span class='k'>if</span> <span class='b'>(</span>x == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    <span class='k'>return</span> field == x.field &amp;&amp; target.sameVarAs<span class='b'>(</span>x.target<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Int? asTableSwitchCase<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// TODO - this should probably be tightened up if we switch to const</span>
    <span class='k'>if</span> <span class='b'>(</span>field.isStatic &amp;&amp; field.parent.isEnum &amp;&amp; ctype.isEnum<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>switch</span> <span class='b'>(</span>field.typeof<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>case</span> ReflectField#:
          ifield := field <span class='k'>as</span> ReflectField
          <span class='k'>return</span> <span class='b'>((</span>Enum<span class='b'>)</span>ifield.f.get<span class='b'>)</span>.ordinal
        <span class='k'>case</span> FieldDef#:
          fieldDef := field <span class='k'>as</span> FieldDef
          enumDef := fieldDef.parentDef.enumDef<span class='b'>(</span>field.name<span class='b'>)</span>
          <span class='k'>if</span> <span class='b'>(</span>enumDef != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> enumDef.ordinal
        <span class='k'>case</span> FField#:
          ffield := field <span class='k'>as</span> FField
          attr := ffield.attr<span class='b'>(</span>FConst.EnumOrdinalAttr<span class='b'>)</span>
          <span class='k'>if</span> <span class='b'>(</span>attr != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> attr.u2
        <span class='k'>default</span>:
          <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Invalid field for tableswitch: $field.typeof $loc.toLocStr"</span><span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>field.isStatic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>field.parent.isFloat<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>switch</span> <span class='b'>(</span>name<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>case</span> <span class='s'>"nan"</span>:    <span class='k'>return</span> <span class='s'>"sys::Float(\"NaN\")"</span>
          <span class='k'>case</span> <span class='s'>"posInf"</span>: <span class='k'>return</span> <span class='s'>"sys::Float(\"INF\")"</span>
          <span class='k'>case</span> <span class='s'>"negInf"</span>: <span class='k'>return</span> <span class='s'>"sys::Float(\"-INF\")"</span>
        <span class='b'>}</span>
      <span class='b'>}</span>

      <span class='k'>if</span> <span class='b'>(</span>field.isEnum<span class='b'>)</span>
        <span class='k'>return</span> <span class='s'>"${field.parent.qname}(\"$name\")"</span>
    <span class='b'>}</span>

    <span class='k'>return</span> <span class='k'>super</span>.serialize
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    s := StrBuf.make
    <span class='k'>if</span> <span class='b'>(</span>target != <span class='k'>null</span><span class='b'>)</span> s.add<span class='b'>(</span>target<span class='b'>)</span>.add<span class='b'>(</span><span class='s'>"."</span><span class='b'>)</span>;
    <span class='k'>if</span> <span class='b'>(</span>!useAccessor<span class='b'>)</span> s.add<span class='b'>(</span><span class='s'>"@"</span><span class='b'>)</span>
    s.add<span class='b'>(</span>name<span class='b'>)</span>
    <span class='k'>return</span> s.toStr
  <span class='b'>}</span>

  CField? field       <span class='y'>// resolved field</span>
  Bool useAccessor    <span class='y'>// false if access using '*' storage operator</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** LocalVarExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** LocalVarExpr is used to access a local variable stored in a register.</span>
<span class='z'>**</span>
<span class='k'>class</span> LocalVarExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, MethodVar? var, ExprId id := ExprId.localVar<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>var != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.var = var
      <span class='k'>this</span>.ctype = var.ctype
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>new</span> makeNoUnwrap<span class='b'>(</span>Loc loc, MethodVar var<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>loc, ExprId.localVar<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.var    = var
    <span class='k'>this</span>.ctype  = var.ctype
    <span class='k'>this</span>.unwrap = <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>true</span> <span class='b'>}</span>

  <span class='k'>override</span> Bool assignRequiresTempVar<span class='b'>()</span> <span class='b'>{</span> var.usedInClosure <span class='b'>}</span>

  <span class='k'>override</span> Bool sameVarAs<span class='b'>(</span>Expr that<span class='b'>)</span>
  <span class='b'>{</span>
    x := that <span class='k'>as</span> LocalVarExpr
    <span class='k'>if</span> <span class='b'>(</span>x == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    <span class='k'>if</span> <span class='b'>(</span>var?.usedInClosure != x?.var?.usedInClosure<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    <span class='k'>return</span> register == x.register
  <span class='b'>}</span>

  <span class='k'>virtual</span> Int register<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> var.register <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>var == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='s'>"???"</span>
    <span class='k'>return</span> var.name
  <span class='b'>}</span>

  MethodVar? var        <span class='y'>// bound variable</span>
  Bool unwrap := <span class='k'>true</span>   <span class='y'>// if hoisted onto heap with wrapper</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ThisExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ThisExpr models the "this" keyword to access the implicit this</span>
<span class='z'>** local variable always stored in register zero.</span>
<span class='z'>**</span>
<span class='k'>class</span> ThisExpr : LocalVarExpr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType? ctype := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, <span class='k'>null</span>, ExprId.thisExpr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='k'>override</span> Int register<span class='b'>()</span> <span class='b'>{</span> 0 <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"this"</span> <span class='b'>}</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** SuperExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** SuperExpr is used to access super class slots.  It always references</span>
<span class='z'>** the implicit this local variable stored in register zero, but the</span>
<span class='z'>** super class's slot definitions.</span>
<span class='z'>**</span>
<span class='k'>class</span> SuperExpr : LocalVarExpr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType? explicitType := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, <span class='k'>null</span>, ExprId.superExpr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.explicitType = explicitType
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAssignable<span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='k'>override</span> Int register<span class='b'>()</span> <span class='b'>{</span> 0 <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>explicitType != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> <span class='s'>"${explicitType}.super"</span>
    <span class='k'>else</span>
      <span class='k'>return</span> <span class='s'>"super"</span>
  <span class='b'>}</span>

  CType? explicitType   <span class='y'>// if "named super"</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ItExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ItExpr models the "it" keyword to access the implicit</span>
<span class='z'>** target of an it-block.</span>
<span class='z'>**</span>
<span class='k'>class</span> ItExpr : LocalVarExpr
<span class='b'>{</span>
  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Loc loc, CType? ctype := <span class='k'>null</span><span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, <span class='k'>null</span>, ExprId.itExpr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
  <span class='b'>}</span>

  <span class='k'>override</span> Bool <span id='isAssignable'>isAssignable</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='k'>override</span> Int <span id='register'>register</span><span class='b'>()</span> <span class='b'>{</span> 1 <span class='b'>}</span>  <span class='y'>// Void doCall(Type it)</span>

  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span> <span class='b'>{</span> <span class='s'>"it"</span> <span class='b'>}</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** StaticTargetExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** StaticTargetExpr wraps a type reference as an Expr for use as</span>
<span class='z'>** a target in a static field access or method call</span>
<span class='z'>**</span>
<span class='k'>class</span> StaticTargetExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType ctype<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.staticTarget<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> ctype.signature
  <span class='b'>}</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** TypeCheckExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** TypeCheckExpr is an expression which is composed of an arbitrary</span>
<span class='z'>** expression and a type - is, as, coerce</span>
<span class='z'>**</span>
<span class='k'>class</span> TypeCheckExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, ExprId id, Expr target, CType check<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, id<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.target = target
    <span class='k'>this</span>.check  = check
    <span class='k'>this</span>.ctype  = check
  <span class='b'>}</span>

  <span class='k'>new</span> coerce<span class='b'>(</span>Expr target, CType to<span class='b'>)</span>
    : <span class='k'>super</span>.make<span class='b'>(</span>target.loc, ExprId.coerce<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>to.isGenericParameter<span class='b'>)</span> to = to.ns.objType <span class='y'>// TODO: not sure about this</span>
    <span class='k'>this</span>.target = target
    <span class='k'>this</span>.from   = target.ctype
    <span class='k'>this</span>.check  = to
    <span class='k'>this</span>.ctype  = to
    <span class='k'>this</span>.synthetic = <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    target = walkExpr<span class='b'>(</span>v, target<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isStmt<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> id === ExprId.coerce &amp;&amp; target.isStmt
  <span class='b'>}</span>

  <span class='k'>override</span> Bool isAlwaysNullable<span class='b'>()</span> <span class='b'>{</span> id === ExprId.asExpr <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>id == ExprId.coerce<span class='b'>)</span>
      <span class='k'>return</span> target.serialize
    <span class='k'>else</span>
      <span class='k'>return</span> <span class='k'>super</span>.serialize
  <span class='b'>}</span>

  Str opStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.isExpr:    <span class='k'>return</span> <span class='s'>"is"</span>
      <span class='k'>case</span> ExprId.isnotExpr: <span class='k'>return</span> <span class='s'>"isnot"</span>
      <span class='k'>case</span> ExprId.asExpr:    <span class='k'>return</span> <span class='s'>"as"</span>
      <span class='k'>default</span>:               <span class='k'>throw</span> Err<span class='b'>(</span>id.toStr<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.isExpr:    <span class='k'>return</span> <span class='s'>"($target is $check)"</span>
      <span class='k'>case</span> ExprId.isnotExpr: <span class='k'>return</span> <span class='s'>"($target isnot $check)"</span>
      <span class='k'>case</span> ExprId.asExpr:    <span class='k'>return</span> <span class='s'>"($target as $check)"</span>
      <span class='k'>case</span> ExprId.coerce:    <span class='k'>return</span> <span class='s'>"(($check)$target)"</span>
      <span class='k'>default</span>:               <span class='k'>throw</span> Err<span class='b'>(</span>id.toStr<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>** From type if coerce</span>
  CType? from <span class='b'>{</span> get <span class='b'>{</span> <span class='k'>return</span> &amp;from ?: target.ctype <span class='b'>}</span> <span class='b'>}</span>

  Expr target
  CType check    <span class='y'>// to type if coerce</span>
  <span class='k'>override</span> Bool synthetic := <span class='k'>false</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** TernaryExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** TernaryExpr is used for the ternary expression &lt;cond&gt; ? &lt;true&gt; : &lt;false&gt;</span>
<span class='z'>**</span>
<span class='k'>class</span> TernaryExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Expr condition, Expr trueExpr, Expr falseExpr<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>condition.loc, ExprId.ternary<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.condition = condition
    <span class='k'>this</span>.trueExpr  = trueExpr
    <span class='k'>this</span>.falseExpr = falseExpr
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    condition = condition.walk<span class='b'>(</span>v<span class='b'>)</span>
    trueExpr  = trueExpr.walk<span class='b'>(</span>v<span class='b'>)</span>
    falseExpr = falseExpr.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"$condition ? $trueExpr : $falseExpr"</span>
  <span class='b'>}</span>

  Expr condition     <span class='y'>// boolean test</span>
  Expr trueExpr      <span class='y'>// result of expression if condition is true</span>
  Expr falseExpr     <span class='y'>// result of expression if condition is false</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ComplexLiteral</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ComplexLiteral is used to model a serialized complex object</span>
<span class='z'>** declared in facets.  It is only used in facets, in all other</span>
<span class='z'>** code complex literals are parsed as it-block ClosureExprs.</span>
<span class='z'>**</span>
<span class='k'>class</span> ComplexLiteral : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType ctype<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.complexLiteral<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype = ctype
    <span class='k'>this</span>.names = Str<span class='b'>[</span>,<span class='b'>]</span>
    <span class='k'>this</span>.vals  = Expr<span class='b'>[</span>,<span class='b'>]</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    vals = walkExprs<span class='b'>(</span>v, vals<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> doToStr |expr| <span class='b'>{</span> expr.toStr <span class='b'>}</span> <span class='b'>}</span>

  <span class='k'>override</span> Str serialize<span class='b'>()</span> <span class='b'>{</span> doToStr |expr| <span class='b'>{</span> expr.serialize <span class='b'>}</span> <span class='b'>}</span>

  Str doToStr<span class='b'>(</span>|Expr-&gt;Str| f<span class='b'>)</span>
  <span class='b'>{</span>
    s := StrBuf<span class='b'>()</span>
    s.add<span class='b'>(</span><span class='s'>"$ctype {"</span><span class='b'>)</span>
    names.each |Str n, Int i| <span class='b'>{</span> s.add<span class='b'>(</span><span class='s'>"$n = ${f(vals[i])};"</span><span class='b'>)</span> <span class='b'>}</span>
    s.add<span class='b'>(</span><span class='s'>"}"</span><span class='b'>)</span>
    <span class='k'>return</span> s.toStr
  <span class='b'>}</span>

  Str<span class='b'>[]</span> names
  Expr<span class='b'>[]</span> vals
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ClosureExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ClosureExpr is an "inlined anonymous method" which closes over it's</span>
<span class='z'>** lexical scope.  ClosureExpr is placed into the AST by the parser</span>
<span class='z'>** with the code field containing the method implementation.  In</span>
<span class='z'>** InitClosures we remap a ClosureExpr to an anonymous class TypeDef</span>
<span class='z'>** which extends Func.  The function implementation is moved to the</span>
<span class='z'>** anonymous class's doCall() method.  However we leave ClosureExpr</span>
<span class='z'>** in the AST in it's original location with a substitute expression.</span>
<span class='z'>** The substitute expr just creates an instance of the anonymous class.</span>
<span class='z'>** But by leaving the ClosureExpr in the tree, we can keep track of</span>
<span class='z'>** the original lexical scope of the closure.</span>
<span class='z'>**</span>
<span class='k'>class</span> ClosureExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, TypeDef enclosingType,
           SlotDef enclosingSlot, ClosureExpr? enclosingClosure,
           FuncType signature, Str name<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.closure<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.ctype            = signature
    <span class='k'>this</span>.enclosingType    = enclosingType
    <span class='k'>this</span>.enclosingSlot    = enclosingSlot
    <span class='k'>this</span>.enclosingClosure = enclosingClosure
    <span class='k'>this</span>.signature        = signature
    <span class='k'>this</span>.name             = name
  <span class='b'>}</span>

  <span class='k'>once</span> CField outerThisField<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>enclosingSlot.isStatic<span class='b'>)</span> <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Internal error: $loc.toLocStr"</span><span class='b'>)</span>
    <span class='k'>return</span> ClosureVars.makeOuterThisField<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"$signature { ... }"</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void print<span class='b'>(</span>AstWriter out<span class='b'>)</span>
  <span class='b'>{</span>
    out.w<span class='b'>(</span>signature.toStr<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>substitute != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      out.w<span class='b'>(</span><span class='s'>" { substitute: "</span><span class='b'>)</span>
      substitute.print<span class='b'>(</span>out<span class='b'>)</span>
      out.w<span class='b'>(</span><span class='s'>" }"</span><span class='b'>)</span>.nl
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      out.nl
      code.print<span class='b'>(</span>out<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  Expr toWith<span class='b'>(</span>Expr target<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>target.ctype != <span class='k'>null</span><span class='b'>)</span> setInferredSignature<span class='b'>(</span>FuncType.makeItBlock<span class='b'>(</span>target.ctype<span class='b'>))</span>
    x := CallExpr.makeWithMethod<span class='b'>(</span>loc, target, enclosingType.ns.objWith, Expr<span class='b'>[</span><span class='k'>this</span><span class='b'>])</span>
    <span class='y'>// TODO: this coercion should be added automatically later in the pipeline</span>
    <span class='k'>if</span> <span class='b'>(</span>target.ctype == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> x
    <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>x, target.ctype<span class='b'>)</span>
  <span class='b'>}</span>

  Void setInferredSignature<span class='b'>(</span>FuncType t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// bail if we didn't expect an inferred the signature</span>
    <span class='y'>// or haven't gotten to InitClosures yet</span>
    <span class='k'>if</span> <span class='b'>(</span>!signature.inferredSignature || cls == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// between the explicit signature and the inferred</span>
    <span class='y'>// signature, take the most specific types; this is where</span>
    <span class='y'>// we take care of functions with generic parameters like V</span>
    t = t.toArity<span class='b'>(((</span>FuncType<span class='b'>)</span>cls.base<span class='b'>)</span>.arity<span class='b'>)</span>
    t = signature.mostSpecific<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// sanity check</span>
    <span class='k'>if</span> <span class='b'>(</span>t.usesThis<span class='b'>)</span>
      <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Inferring signature with un-parameterized this type: $t"</span><span class='b'>)</span>

    <span class='y'>// update my signature and the doCall signature</span>
    signature = t
    ctype = t
    <span class='k'>if</span> <span class='b'>(</span>doCall != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// update parameter types</span>
      doCall.paramDefs.each |ParamDef p, Int i|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>i &lt; signature.params.size<span class='b'>)</span>
          p.paramType = signature.params<span class='b'>[</span>i<span class='b'>]</span>
      <span class='b'>}</span>

      <span class='y'>// update return, we might have to translate an single</span>
      <span class='y'>// expression statement into a return statement</span>
      <span class='k'>if</span> <span class='b'>(</span>doCall.ret.isVoid &amp;&amp; !t.ret.isVoid<span class='b'>)</span>
      <span class='b'>{</span>
        doCall.ret = t.ret
        collapseExprAndReturn<span class='b'>(</span>doCall<span class='b'>)</span>
        collapseExprAndReturn<span class='b'>(</span>call<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// if an itBlock, set type of it</span>
    <span class='k'>if</span> <span class='b'>(</span>isItBlock<span class='b'>)</span> itType = t.params.first

    <span class='y'>// update base type of Func subclass</span>
    cls.base = t
  <span class='b'>}</span>

  Void collapseExprAndReturn<span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    code := m.code.stmts
    <span class='k'>if</span> <span class='b'>(</span>code.size != 2<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>code<span class='b'>[</span>0<span class='b'>]</span>.id !== StmtId.expr<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>code<span class='b'>[</span>1<span class='b'>]</span>.id !== StmtId.returnStmt<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>!<span class='b'>((</span>ReturnStmt<span class='b'>)</span>code.last<span class='b'>)</span>.isSynthetic<span class='b'>)</span> <span class='k'>return</span>
    expr := <span class='b'>((</span>ExprStmt<span class='b'>)</span>code.first<span class='b'>)</span>.expr
    code.set<span class='b'>(</span>0, ReturnStmt.makeSynthetic<span class='b'>(</span>expr.loc, expr<span class='b'>))</span>
    code.removeAt<span class='b'>(</span>1<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='y'>// Parse</span>
  TypeDef enclosingType         <span class='y'>// enclosing class</span>
  SlotDef enclosingSlot         <span class='y'>// enclosing method or field initializer</span>
  ClosureExpr? enclosingClosure <span class='y'>// if nested closure</span>
  FuncType signature            <span class='y'>// function signature</span>
  Block? code                   <span class='y'>// moved into a MethodDef in InitClosures</span>
  Str name                      <span class='y'>// anonymous class name</span>
  Bool isItBlock                <span class='y'>// does closure have implicit it scope</span>

  <span class='y'>// InitClosures</span>
  CallExpr? substitute          <span class='y'>// expression to substitute during assembly</span>
  TypeDef? cls                  <span class='y'>// anonymous class which implements the closure</span>
  MethodDef? call               <span class='y'>// anonymous class's call() with code</span>
  MethodDef? doCall             <span class='y'>// anonymous class's doCall() with code</span>

  <span class='y'>// ResolveExpr</span>
  <span class='b'>[</span>Str:MethodVar<span class='b'>]</span>? enclosingVars <span class='y'>// my parent methods vars in scope</span>
  Bool setsConst                 <span class='y'>// sets one or more const fields (CheckErrors)</span>
  CType? itType                  <span class='y'>// type of implicit it</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ClosureExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** DslExpr is an embedded Domain Specific Language which</span>
<span class='z'>** is parsed by a DslPlugin.</span>
<span class='z'>**</span>
<span class='k'>class</span> DslExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, CType anchorType, Loc srcLoc, Str src<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.dsl<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.anchorType = anchorType
    <span class='k'>this</span>.src        = src
    <span class='k'>this</span>.srcLoc     = srcLoc
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"$anchorType &lt;|$src|&gt;"</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void print<span class='b'>(</span>AstWriter out<span class='b'>)</span>
  <span class='b'>{</span>
    out.w<span class='b'>(</span>toStr<span class='b'>)</span>
  <span class='b'>}</span>

  CType anchorType  <span class='y'>// anchorType &lt;|src|&gt;</span>
  Str src           <span class='y'>// anchorType &lt;|src|&gt;</span>
  Loc srcLoc        <span class='y'>// location of first char of src</span>
  Int leadingTabs   <span class='y'>// number of leading tabs on original Fantom line</span>
  Int leadingSpaces <span class='y'>// number of leading non-tab chars on original Fantom line</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ThrowExpr</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ThrowExpr models throw as an expr versus a statement</span>
<span class='z'>** for use inside ternary/elvis operations.</span>
<span class='z'>**</span>
<span class='k'>class</span> ThrowExpr : Expr
<span class='b'>{</span>
  <span class='k'>new</span> make<span class='b'>(</span>Loc loc, Expr exception<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>loc, ExprId.throwExpr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.exception = exception
  <span class='b'>}</span>

  <span class='k'>override</span> Void walkChildren<span class='b'>(</span>Visitor v<span class='b'>)</span>
  <span class='b'>{</span>
    exception = exception.walk<span class='b'>(</span>v<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> <span class='s'>"throw $exception"</span> <span class='b'>}</span>

  Expr exception   <span class='y'>// exception to throw</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ExprId</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ExprId uniquely identifies the type of expr</span>
<span class='z'>**</span>
<span class='k'>enum</span> <span class='k'>class</span> ExprId
<span class='b'>{</span>
  nullLiteral,      <span class='y'>// LiteralExpr</span>
  trueLiteral,
  falseLiteral,
  intLiteral,
  floatLiteral,
  decimalLiteral,
  strLiteral,
  durationLiteral,
  uriLiteral,
  typeLiteral,
  localeLiteral,    <span class='y'>// LocaleLiteralExpr</span>
  slotLiteral,      <span class='y'>// SlotLiteralExpr</span>
  rangeLiteral,     <span class='y'>// RangeLiteralExpr</span>
  listLiteral,      <span class='y'>// ListLiteralExpr</span>
  mapLiteral,       <span class='y'>// MapLiteralExpr</span>
  boolNot,          <span class='y'>// UnaryExpr</span>
  cmpNull,
  cmpNotNull,
  elvis,
  assign,           <span class='y'>// BinaryExpr</span>
  same,
  notSame,
  boolOr,           <span class='y'>// CondExpr</span>
  boolAnd,
  isExpr,           <span class='y'>// TypeCheckExpr</span>
  isnotExpr,
  asExpr,
  coerce,
  call,             <span class='y'>// CallExpr</span>
  construction,
  shortcut,         <span class='y'>// ShortcutExpr (has ShortcutOp)</span>
  field,            <span class='y'>// FieldExpr</span>
  localVar,         <span class='y'>// LocalVarExpr</span>
  thisExpr,         <span class='y'>// ThisExpr</span>
  superExpr,        <span class='y'>// SuperExpr</span>
  itExpr,           <span class='y'>// ItExpr</span>
  staticTarget,     <span class='y'>// StaticTargetExpr</span>
  unknownVar,       <span class='y'>// UnknownVarExpr</span>
  storage,
  ternary,          <span class='y'>// TernaryExpr</span>
  complexLiteral,   <span class='y'>// ComplexLiteral</span>
  closure,          <span class='y'>// ClosureExpr</span>
  dsl,              <span class='y'>// DslExpr</span>
  throwExpr         <span class='y'>// ThrowExpr</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ShortcutId</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** ShortcutOp is a sub-id for ExprId.shortcut which identifies the</span>
<span class='z'>** an shortuct operation and it's method call</span>
<span class='z'>**</span>
<span class='k'>enum</span> <span class='k'>class</span> ShortcutOp
<span class='b'>{</span>
  plus<span class='b'>(</span>2, <span class='s'>"+"</span><span class='b'>)</span>,
  minus<span class='b'>(</span>2, <span class='s'>"-"</span><span class='b'>)</span>,
  mult<span class='b'>(</span>2, <span class='s'>"*"</span><span class='b'>)</span>,
  div<span class='b'>(</span>2, <span class='s'>"/"</span><span class='b'>)</span>,
  mod<span class='b'>(</span>2, <span class='s'>"%"</span><span class='b'>)</span>,
  negate<span class='b'>(</span>1, <span class='s'>"-"</span><span class='b'>)</span>,
  increment<span class='b'>(</span>1, <span class='s'>"++"</span><span class='b'>)</span>,
  decrement<span class='b'>(</span>1, <span class='s'>"--"</span><span class='b'>)</span>,
  eq<span class='b'>(</span>2, <span class='s'>"=="</span>, <span class='s'>"equals"</span><span class='b'>)</span>,
  cmp<span class='b'>(</span>2, <span class='s'>"&lt;=&gt;"</span>, <span class='s'>"compare"</span><span class='b'>)</span>,
  get<span class='b'>(</span>2, <span class='s'>"[]"</span><span class='b'>)</span>,
  set<span class='b'>(</span>3, <span class='s'>"[]="</span><span class='b'>)</span>

  <span class='k'>private</span> <span class='k'>new</span> make<span class='b'>(</span>Int degree, Str symbol, Str? methodName := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.degree = degree
    <span class='k'>this</span>.symbol = symbol
    <span class='k'>this</span>.methodName = methodName == <span class='k'>null</span> ? name : methodName
    <span class='k'>this</span>.isOperator = methodName == <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='k'>static</span> ShortcutOp? fromPrefix<span class='b'>(</span>Str prefix<span class='b'>)</span> <span class='b'>{</span> prefixes<span class='b'>[</span>prefix<span class='b'>]</span> <span class='b'>}</span>
  <span class='k'>private</span> <span class='k'>static</span> <span class='k'>const</span> Str:ShortcutOp prefixes
  <span class='k'>static</span>
  <span class='b'>{</span>
    m := Str:ShortcutOp<span class='b'>[</span>:<span class='b'>]</span>
    vals.each |val| <span class='b'>{</span> m<span class='b'>[</span>val.methodName<span class='b'>]</span> = val <span class='b'>}</span>
    prefixes = m
  <span class='b'>}</span>

  Str formatErr<span class='b'>(</span>CType lhs, CType rhs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> === get<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"$lhs.qname [ $rhs.qname ]"</span>
    <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> === set<span class='b'>)</span> <span class='k'>return</span> <span class='s'>"$lhs.qname [ $rhs.qname ]="</span>
    <span class='k'>return</span> <span class='s'>"$lhs.qname $symbol $rhs.qname"</span>
  <span class='b'>}</span>

  <span class='k'>const</span> Int degree
  <span class='k'>const</span> Str methodName
  <span class='k'>const</span> Bool isOperator
  <span class='k'>const</span> Str symbol
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='ItExpr.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#isAssignable'>isAssignable</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#register'>register</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>

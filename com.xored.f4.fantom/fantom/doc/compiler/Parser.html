<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::Parser</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='Parser.html'>Parser</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::Parser</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    compiler::Parser</pre>
</div>
<div class='detail'>

<p>Parser is responsible for parsing a list of tokens into the abstract syntax tree.  At this point the CompilationUnit, Usings, and TypeDefs are already populated by the ScanForUsingAndTypes step.</p>
</div>
</div>
<div class='slots'>
<div class='detail'>
<h2>Slots</h2>
<dl>
<dt id='Once' class='field'>Once<a href='Parser_src.html#Once'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='../sys/Int.html'>Int</a> Once := 2147483648</code></p>
</dd>
<dt id='ParserFlagsMask' class='field'>ParserFlagsMask<a href='Parser_src.html#ParserFlagsMask'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='../sys/Int.html'>Int</a> ParserFlagsMask := Readonly</code></p>
</dd>
<dt id='ProtectionMask' class='field'>ProtectionMask<a href='Parser_src.html#ProtectionMask'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='../sys/Int.html'>Int</a> ProtectionMask := ...</code></p>
</dd>
<dt id='Readonly' class='field'>Readonly<a href='Parser_src.html#Readonly'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='../sys/Int.html'>Int</a> Readonly := 1073741824</code></p>
</dd>
<dt id='addExpr' class='method hidden'>addExpr<a href='Parser_src.html#addExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> addExpr()</code></p>

<p>Additive expression:</p>

<pre>&lt;addExpr>  :=  &lt;multExpr> (("+" | "-") &lt;multExpr>)*</pre>
</dd>
<dt id='assignExpr' class='method hidden'>assignExpr<a href='Parser_src.html#assignExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> assignExpr(<a href='Expr.html'>Expr</a>? expr := null)</code></p>

<p>Assignment expression:</p>

<pre>&lt;assignExpr>     :=  &lt;ifExpr> [&lt;assignOp> &lt;assignExpr>]
&lt;assignOp>       :=  "=" | "*=" | "/=" | "%=" | "+=" | "-="</pre>
</dd>
<dt id='block' class='method hidden'>block<a href='Parser_src.html#block'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Block.html'>Block</a> block()</code></p>

<p>Top level for blocks which must be surrounded by braces</p>
</dd>
<dt id='breakStmt' class='method hidden'>breakStmt<a href='Parser_src.html#breakStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='BreakStmt.html'>BreakStmt</a> breakStmt()</code></p>

<p>Break statement:</p>

<pre>&lt;break>  :=  "break" &lt;eos></pre>
</dd>
<dt id='callArgs' class='method hidden'>callArgs<a href='Parser_src.html#callArgs'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> callArgs(<a href='CallExpr.html'>CallExpr</a> call, <a href='../sys/Bool.html'>Bool</a> closureOk := true)</code></p>

<p>Parse args with known parens:</p>

<pre>&lt;args>  := [&lt;expr> ("," &lt;expr>)*] [&lt;closure>]</pre>
</dd>
<dt id='callExpr' class='method hidden'>callExpr<a href='Parser_src.html#callExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CallExpr.html'>CallExpr</a> callExpr(<a href='Expr.html'>Expr</a>? target)</code></p>

<p>Call expression:</p>

<pre>&lt;call>  :=  &lt;id> ["(" &lt;args> ")"] [&lt;closure>]</pre>
</dd>
<dt id='callOp' class='method hidden'>callOp<a href='Parser_src.html#callOp'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> callOp(<a href='Expr.html'>Expr</a> target)</code></p>

<p>Call operator:</p>

<pre>&lt;callOp>  := "(" &lt;args> ")" [&lt;closure>]</pre>
</dd>
<dt id='closure' class='method hidden'>closure<a href='Parser_src.html#closure'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ClosureExpr.html'>ClosureExpr</a> closure(<a href='Loc.html'>Loc</a> loc, <a href='FuncType.html'>FuncType</a> funcType)</code></p>

<p>Parse body of closure expression and return ClosureExpr.</p>
</dd>
<dt id='closureCount' class='field hidden'>closureCount<a href='Parser_src.html#closureCount'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Int.html'>Int</a>? closureCount</code></p>
</dd>
<dt id='closures' class='field hidden'>closures<a href='Parser_src.html#closures'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ClosureExpr.html'>ClosureExpr</a>[] closures</code></p>
</dd>
<dt id='collectionLiteralExpr' class='method hidden'>collectionLiteralExpr<a href='Parser_src.html#collectionLiteralExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> collectionLiteralExpr(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a>? explicitType)</code></p>

<p>Collection literal:</p>

<pre>&lt;list>       :=  [&lt;type>] "[" &lt;listItems> "]"
&lt;listItems>  :=  "," | (&lt;expr> ("," &lt;expr>)*)
&lt;map>        :=  [&lt;mapType>] "[" &lt;mapItems> "]"
&lt;mapItems>   :=  ":" | (&lt;mapPair> ("," &lt;mapPair>)*)
&lt;mapPair>    :=  &lt;expr> ":" &lt;expr></pre>
</dd>
<dt id='complexLiteral' class='method hidden'>complexLiteral<a href='Parser_src.html#complexLiteral'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> complexLiteral(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a> ctype)</code></p>

<p>This is used to parse an it-block outside of the scope of a field or method definition.  It is used to parse complex literals declared in a facet without mucking up the closure code path.</p>
</dd>
<dt id='condAndExpr' class='method hidden'>condAndExpr<a href='Parser_src.html#condAndExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> condAndExpr()</code></p>

<p>Conditional and expression:</p>

<pre>&lt;condAndExpr>  :=  &lt;equalityExpr> ("&amp;&amp;" &lt;equalityExpr>)*</pre>
</dd>
<dt id='condOrExpr' class='method hidden'>condOrExpr<a href='Parser_src.html#condOrExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> condOrExpr()</code></p>

<p>Conditional or expression:</p>

<pre>&lt;condOrExpr>  :=  &lt;condAndExpr>  ("||" &lt;condAndExpr>)*</pre>
</dd>
<dt id='consume' class='method hidden'>consume<a href='Parser_src.html#consume'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TokenVal.html'>TokenVal</a> consume(<a href='Token.html'>Token</a>? kind := null)</code></p>

<p>Consume the current token and return consumed token. If kind is non-null then verify first</p>
</dd>
<dt id='consumeId' class='method hidden'>consumeId<a href='Parser_src.html#consumeId'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Str.html'>Str</a> consumeId()</code></p>

<p>Verify current is an identifier, consume it, and return it.</p>
</dd>
<dt id='continueStmt' class='method hidden'>continueStmt<a href='Parser_src.html#continueStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ContinueStmt.html'>ContinueStmt</a> continueStmt()</code></p>

<p>Continue statement:</p>

<pre>&lt;continue>  :=  "continue" &lt;eos></pre>
</dd>
<dt id='ctorChain' class='method hidden'>ctorChain<a href='Parser_src.html#ctorChain'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CallExpr.html'>CallExpr</a> ctorChain(<a href='MethodDef.html'>MethodDef</a> method)</code></p>
</dd>
<dt id='ctype' class='method hidden'>ctype<a href='Parser_src.html#ctype'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CType.html'>CType</a> ctype()</code></p>

<p>Type signature:</p>

<pre>&lt;type>      :=  &lt;simpleType> | &lt;listType> | &lt;mapType> | &lt;funcType>
&lt;listType>  :=  &lt;type> "[]"
&lt;mapType>   :=  ["["] &lt;type> ":" &lt;type> ["]"]</pre>
</dd>
<dt id='cur' class='field hidden'>cur<a href='Parser_src.html#cur'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TokenVal.html'>TokenVal</a>? cur</code></p>
</dd>
<dt id='curClosure' class='field hidden'>curClosure<a href='Parser_src.html#curClosure'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ClosureExpr.html'>ClosureExpr</a>? curClosure</code></p>
</dd>
<dt id='curSlot' class='field hidden'>curSlot<a href='Parser_src.html#curSlot'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='SlotDef.html'>SlotDef</a>? curSlot</code></p>
</dd>
<dt id='curType' class='field hidden'>curType<a href='Parser_src.html#curType'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TypeDef.html'>TypeDef</a>? curType</code></p>
</dd>
<dt id='curt' class='field hidden'>curt<a href='Parser_src.html#curt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Token.html'>Token</a>? curt</code></p>
</dd>
<dt id='defGet' class='method hidden'>defGet<a href='Parser_src.html#defGet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> defGet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='defGetAndSet' class='method hidden'>defGetAndSet<a href='Parser_src.html#defGetAndSet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> defGetAndSet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='defSet' class='method hidden'>defSet<a href='Parser_src.html#defSet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> defSet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='doc' class='method hidden'>doc<a href='Parser_src.html#doc'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Str.html'>Str</a>[]? doc()</code></p>

<p>Parse fandoc or retur null</p>
</dd>
<dt id='endOfStmt' class='method hidden'>endOfStmt<a href='Parser_src.html#endOfStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Bool.html'>Bool</a> endOfStmt(<a href='../sys/Str.html'>Str</a>? errMsg := ...)</code></p>

<p>Statements can be terminated with a semicolon, end of line or } end of block.   Return true on success.  On failure return false if errMsg is null or log/throw an exception.</p>
</dd>
<dt id='enumDef' class='method hidden'>enumDef<a href='Parser_src.html#enumDef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='EnumDef.html'>EnumDef</a> enumDef(<a href='../sys/Int.html'>Int</a> ordinal)</code></p>

<p>Enum definition:</p>

<pre>&lt;enumDef>  :=  &lt;id> ["(" &lt;args> ")"]</pre>
</dd>
<dt id='enumDefs' class='method hidden'>enumDefs<a href='Parser_src.html#enumDefs'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> enumDefs(<a href='TypeDef.html'>TypeDef</a> def)</code></p>

<p>Enum definition list:</p>

<pre>&lt;enumDefs>  :=  &lt;enumDef> ("," &lt;enumDef>)* &lt;eos></pre>
</dd>
<dt id='equalityExpr' class='method hidden'>equalityExpr<a href='Parser_src.html#equalityExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> equalityExpr()</code></p>

<p>Equality expression:</p>

<pre>&lt;equalityExpr>  :=  &lt;relationalExpr> [("==" | "!=" | "===" | "!==") &lt;relationalExpr>]</pre>
</dd>
<dt id='err' class='method'>err<a href='Parser_src.html#err'>Source</a></dt>
<dd>
<p><code class='sig'>override <a href='CompilerErr.html'>CompilerErr</a> err(<a href='../sys/Str.html'>Str</a> msg, <a href='Loc.html'>Loc</a>? loc := null)</code></p>
<div class='slotInfo'>
<p>Overrides <a href='CompilerSupport.html#err'>compiler::CompilerSupport.err</a></p>
<p>Doc inherited from <a href='CompilerSupport.html#err'>compiler::CompilerSupport.err</a></p>
</div>

<p>Create, log, and return a CompilerErr.</p>
</dd>
<dt id='expr' class='method hidden'>expr<a href='Parser_src.html#expr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> expr()</code></p>

<p>Expression:</p>

<pre>&lt;expr>  :=  &lt;assignExpr></pre>
</dd>
<dt id='exprOrLocalDefStmt' class='method hidden'>exprOrLocalDefStmt<a href='Parser_src.html#exprOrLocalDefStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Stmt.html'>Stmt</a> exprOrLocalDefStmt(<a href='../sys/Bool.html'>Bool</a> isEndOfStmt)</code></p>

<p>Expression or local variable declaration:</p>

<pre>&lt;exprStmt>  :=  &lt;expr> &lt;eos>
&lt;localDef>  :=  [&lt;type>] &lt;id> [":=" &lt;expr>] &lt;eos>
&lt;itAdd>     :=  &lt;expr> ("," &lt;expr>)*</pre>
</dd>
<dt id='facets' class='method hidden'>facets<a href='Parser_src.html#facets'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='FacetDef.html'>FacetDef</a>[]? facets()</code></p>

<p>Facet definition:</p>

<pre>&lt;facets>     := &lt;facet>*
&lt;facet>      := "@" &lt;simpleType> [&lt;facetVals>]
&lt;facetVals>  := "{" &lt;facetVal> (&lt;eos> &lt;facetVal>)* "}"
&lt;facetVal>   := &lt;id> "=" &lt;expr></pre>
</dd>
<dt id='fieldDef' class='method hidden'>fieldDef<a href='Parser_src.html#fieldDef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='FieldDef.html'>FieldDef</a> fieldDef(<a href='Loc.html'>Loc</a> loc, <a href='TypeDef.html'>TypeDef</a> parent, <a href='../sys/Str.html'>Str</a>[]? doc, <a href='FacetDef.html'>FacetDef</a>[]? facets, <a href='../sys/Int.html'>Int</a> flags, <a href='TypeRef.html'>TypeRef</a>? type, <a href='../sys/Str.html'>Str</a> name)</code></p>

<p>Field definition:</p>

<pre>&lt;fieldDef>     :=  &lt;facets> &lt;fieldFlags> [&lt;type>] &lt;id> [":=" &lt;expr>]
                   [ "{" [&lt;fieldGetter>] [&lt;fieldSetter>] "}" ] &lt;eos>
&lt;fieldFlags>   :=  [&lt;protection>] ["readonly"] ["static"]
&lt;fieldGetter>  :=  "get" (&lt;eos> | &lt;block>)
&lt;fieldSetter>  :=  &lt;protection> "set" (&lt;eos> | &lt;block>)</pre>
</dd>
<dt id='flags' class='method hidden'>flags<a href='Parser_src.html#flags'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Int.html'>Int</a> flags(<a href='../sys/Bool.html'>Bool</a> normalize := true)</code></p>

<p>Parse any list of flags in any order, we will check invalid combinations in the CheckErrors step.</p>
</dd>
<dt id='forStmt' class='method hidden'>forStmt<a href='Parser_src.html#forStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ForStmt.html'>ForStmt</a> forStmt()</code></p>

<p>For statement:</p>

<pre>&lt;for>      :=  "for" "(" [&lt;forInit>] ";" &lt;expr> ";" &lt;expr> ")" &lt;block>
&lt;forInit>  :=  &lt;expr> | &lt;localDef></pre>
</dd>
<dt id='funcType' class='method hidden'>funcType<a href='Parser_src.html#funcType'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CType.html'>CType</a> funcType()</code></p>

<p>Method type signature:</p>

<pre>&lt;funcType>       :=  "|" ("->" | &lt;funcTypeSig>) "|"
&lt;funcTypeSig>    :=  &lt;formals> ["->" &lt;type>]
&lt;formals>        :=  [&lt;formal> ("," &lt;formal>)*]
&lt;formal>         :=  &lt;formFull> | &lt;formalInferred> | &lt;formalTypeOnly>
&lt;formalFull>     :=  &lt;type> &lt;id>
&lt;formalInferred> :=  &lt;id>
&lt;formalTypeOnly> :=  &lt;type></pre>
</dd>
<dt id='funcTypeFormal' class='method hidden'>funcTypeFormal<a href='Parser_src.html#funcTypeFormal'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Bool.html'>Bool</a> funcTypeFormal(<a href='CType.html'>CType</a>[] params, <a href='../sys/Str.html'>Str</a>[] names, <a href='../sys/Bool.html'>Bool</a>[] unnamed)</code></p>
</dd>
<dt id='genSyntheticGet' class='method hidden'>genSyntheticGet<a href='Parser_src.html#genSyntheticGet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> genSyntheticGet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='genSyntheticSet' class='method hidden'>genSyntheticSet<a href='Parser_src.html#genSyntheticSet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> genSyntheticSet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='getOrSet' class='method hidden'>getOrSet<a href='Parser_src.html#getOrSet'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> getOrSet(<a href='FieldDef.html'>FieldDef</a> f)</code></p>
</dd>
<dt id='idExpr' class='method hidden'>idExpr<a href='Parser_src.html#idExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> idExpr(<a href='Expr.html'>Expr</a>? target, <a href='../sys/Bool.html'>Bool</a> dynamicCall, <a href='../sys/Bool.html'>Bool</a> safeCall)</code></p>

<p>Identifier expression:</p>

<pre>&lt;idExpr>  :=  &lt;local> | &lt;field> | &lt;call>
&lt;local>   :=  &lt;id>
&lt;field>   :=  ["*"] &lt;id></pre>
</dd>
<dt id='ifExpr' class='method hidden'>ifExpr<a href='Parser_src.html#ifExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> ifExpr()</code></p>

<p>Ternary/Elvis expressions:</p>

<pre>&lt;ifExpr>       :=  &lt;ternaryExpr> | &lt;elvisExpr>
&lt;ternaryExpr>  :=  &lt;condOrExpr> ["?" &lt;ifExprBody> ":" &lt;ifExprBody>]
&lt;elvisExpr>    :=  &lt;condOrExpr> "?:" &lt;ifExprBody></pre>
</dd>
<dt id='ifExprBody' class='method hidden'>ifExprBody<a href='Parser_src.html#ifExprBody'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> ifExprBody()</code></p>

<p>If expression body (ternary/elvis):</p>

<pre>&lt;ifExprBody>   :=  &lt;condOrExpr> | &lt;ifExprThrow>
&lt;ifExprThrow>  :=  "throw" &lt;expr></pre>
</dd>
<dt id='ifStmt' class='method hidden'>ifStmt<a href='Parser_src.html#ifStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='IfStmt.html'>IfStmt</a> ifStmt()</code></p>

<p>If/else statement:</p>

<pre>&lt;if>  :=  "if" "(" &lt;expr> ")" &lt;block> [ "else" &lt;block> ]</pre>
</dd>
<dt id='inFieldInit' class='field hidden'>inFieldInit<a href='Parser_src.html#inFieldInit'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Bool.html'>Bool</a> inFieldInit</code></p>
</dd>
<dt id='indexExpr' class='method hidden'>indexExpr<a href='Parser_src.html#indexExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> indexExpr(<a href='Expr.html'>Expr</a> target)</code></p>

<p>Index expression:</p>

<pre>&lt;indexExpr>  := "[" &lt;expr> "]"</pre>
</dd>
<dt id='inheritType' class='method hidden'>inheritType<a href='Parser_src.html#inheritType'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CType.html'>CType</a> inheritType()</code></p>
</dd>
<dt id='itAdd' class='method hidden'>itAdd<a href='Parser_src.html#itAdd'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> itAdd(<a href='Expr.html'>Expr</a> e)</code></p>

<p>Comma operator is sugar for it.add(target):</p>

<pre>&lt;itAdd>  :=  &lt;expr> ("," &lt;expr>)* &lt;eos></pre>
</dd>
<dt id='listLiteralExpr' class='method hidden'>listLiteralExpr<a href='Parser_src.html#listLiteralExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ListLiteralExpr.html'>ListLiteralExpr</a> listLiteralExpr(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a>? explicitType, <a href='Expr.html'>Expr</a>? first)</code></p>

<p>Parse List literal; if first is null then</p>

<pre>cur must be on lbracket</pre>

<p>else</p>

<pre>cur must be on comma after first item</pre>
</dd>
<dt id='localDefStmt' class='method hidden'>localDefStmt<a href='Parser_src.html#localDefStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='LocalDefStmt.html'>LocalDefStmt</a> localDefStmt(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a>? localType, <a href='../sys/Bool.html'>Bool</a> isEndOfStmt)</code></p>

<p>Parse local variable declaration, the current token must be the identifier of the local variable.</p>
</dd>
<dt id='make' class='method'>make<a href='Parser_src.html#make'>Source</a></dt>
<dd>
<p><code class='sig'>new make(<a href='Compiler.html'>Compiler</a> compiler, <a href='CompilationUnit.html'>CompilationUnit</a> unit, <a href='ClosureExpr.html'>ClosureExpr</a>[] closures)</code></p>

<p>Construct the parser for the specified compilation unit.</p>
</dd>
<dt id='mapLiteralExpr' class='method hidden'>mapLiteralExpr<a href='Parser_src.html#mapLiteralExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='MapLiteralExpr.html'>MapLiteralExpr</a> mapLiteralExpr(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a>? explicitType, <a href='Expr.html'>Expr</a>? first)</code></p>

<p>Parse Map literal; if first is null:</p>

<pre>cur must be on lbracket</pre>

<p>else</p>

<pre>cur must be on colon of first key/value pair</pre>
</dd>
<dt id='methodDef' class='method hidden'>methodDef<a href='Parser_src.html#methodDef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='MethodDef.html'>MethodDef</a> methodDef(<a href='Loc.html'>Loc</a> loc, <a href='TypeDef.html'>TypeDef</a> parent, <a href='../sys/Str.html'>Str</a>[]? doc, <a href='FacetDef.html'>FacetDef</a>[]? facets, <a href='../sys/Int.html'>Int</a> flags, <a href='TypeRef.html'>TypeRef</a> ret, <a href='../sys/Str.html'>Str</a> name)</code></p>

<p>Method definition:</p>

<pre>&lt;methodDef>      :=  &lt;facets> &lt;methodFlags> &lt;type> &lt;id> "(" &lt;params> ")" &lt;methodBody>
&lt;methodFlags>    :=  [&lt;protection>] ["virtual"] ["override"] ["abstract"] ["static"]
&lt;params>         :=  [&lt;param> ("," &lt;param>)*]
&lt;param>          :=  &lt;type> &lt;id> [":=" &lt;expr>]
&lt;methodBody>     :=  &lt;eos> | ( "{" &lt;stmts> "}" )</pre>
</dd>
<dt id='multExpr' class='method hidden'>multExpr<a href='Parser_src.html#multExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> multExpr()</code></p>

<p>Multiplicative expression:</p>

<pre>&lt;multExpr>  :=  &lt;parenExpr> (("*" | "/" | "%") &lt;parenExpr>)*</pre>
</dd>
<dt id='numTokens' class='field hidden'>numTokens<a href='Parser_src.html#numTokens'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Int.html'>Int</a> numTokens</code></p>
</dd>
<dt id='paramDef' class='method hidden'>paramDef<a href='Parser_src.html#paramDef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ParamDef.html'>ParamDef</a> paramDef()</code></p>
</dd>
<dt id='parenExpr' class='method hidden'>parenExpr<a href='Parser_src.html#parenExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> parenExpr()</code></p>

<p>Paren grouped expression:</p>

<pre>&lt;parenExpr>    :=  &lt;unaryExpr> | &lt;castExpr> | &lt;groupedExpr>
&lt;castExpr>     :=  "(" &lt;type> ")" &lt;parenExpr>
&lt;groupedExpr>  :=  "(" &lt;expr> ")" &lt;termChain>*</pre>
</dd>
<dt id='parse' class='method'>parse<a href='Parser_src.html#parse'>Source</a></dt>
<dd>
<p><code class='sig'><a href='../sys/Void.html'>Void</a> parse()</code></p>

<p>Top level parse a compilation unit:</p>

<pre>&lt;compilationUnit> :=  [&lt;usings>] &lt;typeDef>*</pre>
</dd>
<dt id='peek' class='field hidden'>peek<a href='Parser_src.html#peek'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TokenVal.html'>TokenVal</a>? peek</code></p>
</dd>
<dt id='peekt' class='field hidden'>peekt<a href='Parser_src.html#peekt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Token.html'>Token</a>? peekt</code></p>
</dd>
<dt id='pos' class='field hidden'>pos<a href='Parser_src.html#pos'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Int.html'>Int</a> pos</code></p>
</dd>
<dt id='rangeExpr' class='method hidden'>rangeExpr<a href='Parser_src.html#rangeExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> rangeExpr()</code></p>

<p>Range expression:</p>

<pre>&lt;rangeExpr>  :=  &lt;bitOrExpr> ((".." | "...") &lt;bitOrExpr>)*</pre>
</dd>
<dt id='relationalExpr' class='method hidden'>relationalExpr<a href='Parser_src.html#relationalExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> relationalExpr()</code></p>

<p>Relational expression:</p>

<pre>&lt;relationalExpr> :=  &lt;typeCheckExpr> | &lt;compareExpr>
&lt;typeCheckExpr>  :=  &lt;rangeExpr> [("is" | "as" | "isnot") &lt;type>]
&lt;compareExpr>    :=  &lt;rangeExpr> [("&lt;" | "&lt;=" | ">" | ">=" | "&lt;=>") &lt;rangeExpr>]</pre>
</dd>
<dt id='reset' class='method hidden'>reset<a href='Parser_src.html#reset'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> reset(<a href='../sys/Int.html'>Int</a> pos)</code></p>

<p>Reset the current position to the specified tokens index.</p>
</dd>
<dt id='returnStmt' class='method hidden'>returnStmt<a href='Parser_src.html#returnStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ReturnStmt.html'>ReturnStmt</a> returnStmt()</code></p>

<p>Return statement:</p>

<pre>&lt;return>  :=  "return" [&lt;expr>] &lt;eos></pre>
</dd>
<dt id='simpleType' class='method hidden'>simpleType<a href='Parser_src.html#simpleType'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CType.html'>CType</a> simpleType()</code></p>

<p>Simple type signature:</p>

<pre>&lt;simpleType>  :=  &lt;id> ["::" &lt;id>]</pre>
</dd>
<dt id='skipUsing' class='method hidden'>skipUsing<a href='Parser_src.html#skipUsing'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> skipUsing()</code></p>
</dd>
<dt id='slotDef' class='method hidden'>slotDef<a href='Parser_src.html#slotDef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='SlotDef.html'>SlotDef</a> slotDef(<a href='TypeDef.html'>TypeDef</a> parent, <a href='../sys/Str.html'>Str</a>[]? doc)</code></p>

<p>Slot definition:</p>

<pre>&lt;slotDef> :=  &lt;fieldDef> | &lt;methodDef> | &lt;ctorDef></pre>
</dd>
<dt id='stmt' class='method hidden'>stmt<a href='Parser_src.html#stmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Stmt.html'>Stmt</a> stmt()</code></p>

<p>Statement:</p>

<pre>&lt;stmt>  :=  &lt;break> | &lt;continue> | &lt;for> | &lt;if> | &lt;return> | &lt;switch> |
            &lt;throw> | &lt;while> | &lt;try> | &lt;exprStmt> | &lt;localDef> | &lt;itAdd></pre>
</dd>
<dt id='stmtOrBlock' class='method hidden'>stmtOrBlock<a href='Parser_src.html#stmtOrBlock'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Block.html'>Block</a> stmtOrBlock()</code></p>

<p>&lt;block>  :=  &lt;stmt> | ( "{" &lt;stmts> "}" ) &lt;stmts>  :=  &lt;stmt>*</p>
</dd>
<dt id='switchBlock' class='method hidden'>switchBlock<a href='Parser_src.html#switchBlock'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Block.html'>Block</a> switchBlock()</code></p>
</dd>
<dt id='switchStmt' class='method hidden'>switchStmt<a href='Parser_src.html#switchStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='SwitchStmt.html'>SwitchStmt</a> switchStmt()</code></p>

<p>Switch statement:</p>

<pre>&lt;switch>   :=  "switch" "(" &lt;expr> ")" "{" &lt;case>* [&lt;default>] "}"
&lt;case>     :=  "case" &lt;expr> ":" &lt;stmts>
&lt;default>  :=  "default" ":" &lt;stmts></pre>
</dd>
<dt id='termBaseExpr' class='method hidden'>termBaseExpr<a href='Parser_src.html#termBaseExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> termBaseExpr()</code></p>

<p>Atomic base of a termExpr</p>

<pre>&lt;termBase>    :=  &lt;literal> | &lt;idExpr> | &lt;closure> | &lt;dsl>
&lt;literal>     :=  "null" | "this" | "super" | &lt;bool> | &lt;int> |
                  &lt;float> | &lt;str> | &lt;duration> | &lt;list> | &lt;map> | &lt;uri> |
                  &lt;typeLiteral> | &lt;slotLiteral>
&lt;typeLiteral> :=  &lt;type> "#"
&lt;slotLiteral> :=  [&lt;type>] "#" &lt;id></pre>
</dd>
<dt id='termChainExpr' class='method hidden'>termChainExpr<a href='Parser_src.html#termChainExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a>? termChainExpr(<a href='Expr.html'>Expr</a> target)</code></p>

<p>A chain expression is a piece of a term expression that may be chained together such as "call.var[x]".  If the specified target expression contains a chained access, then return the new expression, otherwise return null.</p>

<pre>&lt;termChain>      :=  &lt;compiledCall> | &lt;dynamicCall> | &lt;indexExpr>
&lt;compiledCall>   :=  "." &lt;idExpr>
&lt;dynamicCall>    :=  "->" &lt;idExpr></pre>
</dd>
<dt id='termExpr' class='method hidden'>termExpr<a href='Parser_src.html#termExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> termExpr(<a href='Expr.html'>Expr</a>? target := null)</code></p>

<p>A term is a base terminal such as a variable, call, or literal, optionally followed by a chain of accessor expressions - such as "x.y[z](a, b)".</p>

<pre>&lt;termExpr>  :=  &lt;termBase> &lt;termChain>*</pre>
</dd>
<dt id='throwStmt' class='method hidden'>throwStmt<a href='Parser_src.html#throwStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ThrowStmt.html'>ThrowStmt</a> throwStmt()</code></p>

<p>Throw statement:</p>

<pre>&lt;throw>  :=  "throw" &lt;expr> &lt;eos></pre>
</dd>
<dt id='tokens' class='field hidden'>tokens<a href='Parser_src.html#tokens'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TokenVal.html'>TokenVal</a>[] tokens</code></p>
</dd>
<dt id='tryCatch' class='method hidden'>tryCatch<a href='Parser_src.html#tryCatch'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Catch.html'>Catch</a> tryCatch()</code></p>
</dd>
<dt id='tryClosure' class='method hidden'>tryClosure<a href='Parser_src.html#tryClosure'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ClosureExpr.html'>ClosureExpr</a>? tryClosure()</code></p>

<p>Attempt to parse a closure expression or return null if we aren't positioned at the start of a closure expression.</p>
</dd>
<dt id='tryItBlock' class='method hidden'>tryItBlock<a href='Parser_src.html#tryItBlock'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='ClosureExpr.html'>ClosureExpr</a>? tryItBlock()</code></p>

<p>Parse it-block closure.</p>
</dd>
<dt id='tryStmt' class='method hidden'>tryStmt<a href='Parser_src.html#tryStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TryStmt.html'>TryStmt</a> tryStmt()</code></p>

<p>Try-catch-finally statement:</p>

<pre>&lt;try>       :=  "try" "{" &lt;stmt>* "}" &lt;catch>* [&lt;finally>]
&lt;catch>     :=  "catch" [&lt;catchDef>] "{" &lt;stmt>* "}"
&lt;catchDef>  :=  "(" &lt;type> &lt;id> ")"
&lt;finally>   :=  "finally" "{" &lt;stmt>* "}"</pre>
</dd>
<dt id='tryType' class='method hidden'>tryType<a href='Parser_src.html#tryType'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CType.html'>CType</a>? tryType()</code></p>

<p>If the current stream of tokens can be parsed as a valid type production return it.  Otherwise leave the parser positioned on the current token.</p>
</dd>
<dt id='typeBaseExpr' class='method hidden'>typeBaseExpr<a href='Parser_src.html#typeBaseExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> typeBaseExpr(<a href='Loc.html'>Loc</a> loc, <a href='CType.html'>CType</a> ctype)</code></p>

<p>Handle a term expression which begins with a type literal.</p>
</dd>
<dt id='typeDef' class='method'>typeDef<a href='Parser_src.html#typeDef'>Source</a></dt>
<dd>
<p><code class='sig'><a href='../sys/Void.html'>Void</a> typeDef()</code></p>

<p>TypeDef:</p>

<pre>&lt;typeDef>      :=  &lt;classDef> | &lt;mixinDef> | &lt;enumDef> | &lt;facetDef>

&lt;classDef>     :=  &lt;classHeader> &lt;classBody>
&lt;classHeader>  :=  [&lt;doc>] &lt;facets> &lt;typeFlags> "class" [&lt;inheritance>]
&lt;classFlags>   :=  [&lt;protection>] ["abstract"] ["final"]
&lt;classBody>    :=  "{" &lt;slotDefs> "}"

&lt;enumDef>      :=  &lt;enumHeader> &lt;enumBody>
&lt;enumHeader>   :=  [&lt;doc>] &lt;facets> &lt;protection> "enum" [&lt;inheritance>]
&lt;enumBody>     :=  "{" &lt;enumDefs> &lt;slotDefs> "}"

&lt;facetDef      :=  &lt;facetHeader> &lt;enumBody>
&lt;facetHeader>  :=  [&lt;doc>] &lt;facets> [&lt;protection>] "facet" "class" &lt;id> [&lt;inheritance>]
&lt;facetBody>    :=  "{" &lt;slotDefs> "}"

&lt;mixinDef>     :=  &lt;enumHeader> &lt;enumBody>
&lt;mixinHeader>  :=  [&lt;doc>] &lt;facets> &lt;protection> "mixin" [&lt;inheritance>]
&lt;mixinBody>    :=  "{" &lt;slotDefs> "}"

&lt;protection>   :=  "public" | "protected" | "private" | "internal"
&lt;inheritance>  :=  ":" &lt;typeList></pre>
</dd>
<dt id='typeRef' class='method hidden'>typeRef<a href='Parser_src.html#typeRef'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='TypeRef.html'>TypeRef</a> typeRef()</code></p>

<p>Parse a type production into a CType and wrap it as AST TypeRef.</p>
</dd>
<dt id='unaryExpr' class='method hidden'>unaryExpr<a href='Parser_src.html#unaryExpr'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='Expr.html'>Expr</a> unaryExpr()</code></p>

<p>Unary expression:</p>

<pre>&lt;unaryExpr>    :=  &lt;prefixExpr> | &lt;termExpr> | &lt;postfixExpr>
&lt;prefixExpr>   :=  ("!" | "+" | "-" | "~" | "++" | "--") &lt;parenExpr>
&lt;postfixExpr>  :=  &lt;termExpr> ("++" | "--")</pre>
</dd>
<dt id='unit' class='field hidden'>unit<a href='Parser_src.html#unit'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='CompilationUnit.html'>CompilationUnit</a> unit</code></p>
</dd>
<dt id='usings' class='method hidden'>usings<a href='Parser_src.html#usings'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> usings()</code></p>

<p>Parse &lt;using>* - note that we are just skipping them because they are already parsed by ScanForUsingsAndTypes.</p>

<pre>&lt;using>       :=  &lt;usingPod> | &lt;usingType> | &lt;usingAs>
&lt;usingPod>    :=  "using" &lt;podSpec> &lt;eos>
&lt;usingType>   :=  "using" &lt;podSpec> "::" &lt;id> &lt;eos>
&lt;usingAs>     :=  "using" &lt;podSpec> "::" &lt;id> "as" &lt;id> &lt;eos>
&lt;podSpec>     :=  &lt;id> | &lt;str> | &lt;ffiPodSpec>
&lt;ffiPodSpec>  := "[" &lt;id> "]" &lt;id> ("." &lt;id>)*</pre>
</dd>
<dt id='verify' class='method hidden'>verify<a href='Parser_src.html#verify'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='../sys/Void.html'>Void</a> verify(<a href='Token.html'>Token</a> kind)</code></p>

<p>Check that the current token matches the specified type, but do not consume it.</p>
</dd>
<dt id='whileStmt' class='method hidden'>whileStmt<a href='Parser_src.html#whileStmt'>Source</a></dt>
<dd class='hidden'>
<p><code class='sig'>private <a href='WhileStmt.html'>WhileStmt</a> whileStmt()</code></p>

<p>While statement:</p>

<pre>&lt;while>  :=  "while" "(" &lt;expr> ")" &lt;block></pre>
</dd>
</dl>
</div>
</div>
</div>
<div class='sidebar'>
<h2>Type</h2>
<ul class='clean'>
  <li><a href='Parser_src.html'>View Source</a></li>
  <li><a href='#' onclick='ShowSlots.toggle(event); return false;'>Show All Slots</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li><a href='#Once'>Once</a></li>
  <li><a href='#ParserFlagsMask'>ParserFlagsMask</a></li>
  <li><a href='#ProtectionMask'>ProtectionMask</a></li>
  <li><a href='#Readonly'>Readonly</a></li>
  <li class='hidden'><a href='#addExpr'>addExpr</a></li>
  <li class='hidden'><a href='#assignExpr'>assignExpr</a></li>
  <li class='hidden'><a href='#block'>block</a></li>
  <li class='hidden'><a href='#breakStmt'>breakStmt</a></li>
  <li class='hidden'><a href='#callArgs'>callArgs</a></li>
  <li class='hidden'><a href='#callExpr'>callExpr</a></li>
  <li class='hidden'><a href='#callOp'>callOp</a></li>
  <li class='hidden'><a href='#closure'>closure</a></li>
  <li class='hidden'><a href='#closureCount'>closureCount</a></li>
  <li class='hidden'><a href='#closures'>closures</a></li>
  <li class='hidden'><a href='#collectionLiteralExpr'>collectionLiteralExpr</a></li>
  <li class='hidden'><a href='#complexLiteral'>complexLiteral</a></li>
  <li class='hidden'><a href='#condAndExpr'>condAndExpr</a></li>
  <li class='hidden'><a href='#condOrExpr'>condOrExpr</a></li>
  <li class='hidden'><a href='#consume'>consume</a></li>
  <li class='hidden'><a href='#consumeId'>consumeId</a></li>
  <li class='hidden'><a href='#continueStmt'>continueStmt</a></li>
  <li class='hidden'><a href='#ctorChain'>ctorChain</a></li>
  <li class='hidden'><a href='#ctype'>ctype</a></li>
  <li class='hidden'><a href='#cur'>cur</a></li>
  <li class='hidden'><a href='#curClosure'>curClosure</a></li>
  <li class='hidden'><a href='#curSlot'>curSlot</a></li>
  <li class='hidden'><a href='#curType'>curType</a></li>
  <li class='hidden'><a href='#curt'>curt</a></li>
  <li class='hidden'><a href='#defGet'>defGet</a></li>
  <li class='hidden'><a href='#defGetAndSet'>defGetAndSet</a></li>
  <li class='hidden'><a href='#defSet'>defSet</a></li>
  <li class='hidden'><a href='#doc'>doc</a></li>
  <li class='hidden'><a href='#endOfStmt'>endOfStmt</a></li>
  <li class='hidden'><a href='#enumDef'>enumDef</a></li>
  <li class='hidden'><a href='#enumDefs'>enumDefs</a></li>
  <li class='hidden'><a href='#equalityExpr'>equalityExpr</a></li>
  <li><a href='#err'>err</a></li>
  <li class='hidden'><a href='#expr'>expr</a></li>
  <li class='hidden'><a href='#exprOrLocalDefStmt'>exprOrLocalDefStmt</a></li>
  <li class='hidden'><a href='#facets'>facets</a></li>
  <li class='hidden'><a href='#fieldDef'>fieldDef</a></li>
  <li class='hidden'><a href='#flags'>flags</a></li>
  <li class='hidden'><a href='#forStmt'>forStmt</a></li>
  <li class='hidden'><a href='#funcType'>funcType</a></li>
  <li class='hidden'><a href='#funcTypeFormal'>funcTypeFormal</a></li>
  <li class='hidden'><a href='#genSyntheticGet'>genSyntheticGet</a></li>
  <li class='hidden'><a href='#genSyntheticSet'>genSyntheticSet</a></li>
  <li class='hidden'><a href='#getOrSet'>getOrSet</a></li>
  <li class='hidden'><a href='#idExpr'>idExpr</a></li>
  <li class='hidden'><a href='#ifExpr'>ifExpr</a></li>
  <li class='hidden'><a href='#ifExprBody'>ifExprBody</a></li>
  <li class='hidden'><a href='#ifStmt'>ifStmt</a></li>
  <li class='hidden'><a href='#inFieldInit'>inFieldInit</a></li>
  <li class='hidden'><a href='#indexExpr'>indexExpr</a></li>
  <li class='hidden'><a href='#inheritType'>inheritType</a></li>
  <li class='hidden'><a href='#itAdd'>itAdd</a></li>
  <li class='hidden'><a href='#listLiteralExpr'>listLiteralExpr</a></li>
  <li class='hidden'><a href='#localDefStmt'>localDefStmt</a></li>
  <li><a href='#make'>make</a></li>
  <li class='hidden'><a href='#mapLiteralExpr'>mapLiteralExpr</a></li>
  <li class='hidden'><a href='#methodDef'>methodDef</a></li>
  <li class='hidden'><a href='#multExpr'>multExpr</a></li>
  <li class='hidden'><a href='#numTokens'>numTokens</a></li>
  <li class='hidden'><a href='#paramDef'>paramDef</a></li>
  <li class='hidden'><a href='#parenExpr'>parenExpr</a></li>
  <li><a href='#parse'>parse</a></li>
  <li class='hidden'><a href='#peek'>peek</a></li>
  <li class='hidden'><a href='#peekt'>peekt</a></li>
  <li class='hidden'><a href='#pos'>pos</a></li>
  <li class='hidden'><a href='#rangeExpr'>rangeExpr</a></li>
  <li class='hidden'><a href='#relationalExpr'>relationalExpr</a></li>
  <li class='hidden'><a href='#reset'>reset</a></li>
  <li class='hidden'><a href='#returnStmt'>returnStmt</a></li>
  <li class='hidden'><a href='#simpleType'>simpleType</a></li>
  <li class='hidden'><a href='#skipUsing'>skipUsing</a></li>
  <li class='hidden'><a href='#slotDef'>slotDef</a></li>
  <li class='hidden'><a href='#stmt'>stmt</a></li>
  <li class='hidden'><a href='#stmtOrBlock'>stmtOrBlock</a></li>
  <li class='hidden'><a href='#switchBlock'>switchBlock</a></li>
  <li class='hidden'><a href='#switchStmt'>switchStmt</a></li>
  <li class='hidden'><a href='#termBaseExpr'>termBaseExpr</a></li>
  <li class='hidden'><a href='#termChainExpr'>termChainExpr</a></li>
  <li class='hidden'><a href='#termExpr'>termExpr</a></li>
  <li class='hidden'><a href='#throwStmt'>throwStmt</a></li>
  <li class='hidden'><a href='#tokens'>tokens</a></li>
  <li class='hidden'><a href='#tryCatch'>tryCatch</a></li>
  <li class='hidden'><a href='#tryClosure'>tryClosure</a></li>
  <li class='hidden'><a href='#tryItBlock'>tryItBlock</a></li>
  <li class='hidden'><a href='#tryStmt'>tryStmt</a></li>
  <li class='hidden'><a href='#tryType'>tryType</a></li>
  <li class='hidden'><a href='#typeBaseExpr'>typeBaseExpr</a></li>
  <li><a href='#typeDef'>typeDef</a></li>
  <li class='hidden'><a href='#typeRef'>typeRef</a></li>
  <li class='hidden'><a href='#unaryExpr'>unaryExpr</a></li>
  <li class='hidden'><a href='#unit'>unit</a></li>
  <li class='hidden'><a href='#usings'>usings</a></li>
  <li class='hidden'><a href='#verify'>verify</a></li>
  <li class='hidden'><a href='#whileStmt'>whileStmt</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>

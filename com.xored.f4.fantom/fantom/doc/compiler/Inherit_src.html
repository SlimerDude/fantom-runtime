<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::Inherit</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='Inherit.html'>Inherit</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::Inherit</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    <a href='CompilerStep.html'>compiler::CompilerStep</a>
      compiler::Inherit</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//    2 Dec 05  Brian Frank  Creation (originally InitShimSlots)</span>
<span class='y'>//   23 Sep 06  Brian Frank  Ported from Java to Fan</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Inherit processes each TypeDef to resolve the inherited slots.</span>
<span class='z'>** This step is used to check invalid inheritances due to conflicting</span>
<span class='z'>** slots and invalid overrides.</span>
<span class='z'>**</span>
<span class='k'>class</span> Inherit : CompilerStep
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Run</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='run'>run</span><span class='b'>()</span>
  <span class='b'>{</span>
    log.debug<span class='b'>(</span><span class='s'>"Inherit"</span><span class='b'>)</span>

    <span class='y'>// at this point OrderByInheritance should have everything</span>
    <span class='y'>// ordered correctly to just do a simple walk</span>
    walk<span class='b'>(</span>compiler, VisitDepth.typeDef<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>override</span> Void <span id='visitTypeDef'>visitTypeDef</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// inherit all parent types</span>
    inheritType<span class='b'>(</span>t, t.base<span class='b'>)</span>
    t.mixins.each |CType m| <span class='b'>{</span> inheritType<span class='b'>(</span>t, m<span class='b'>)</span> <span class='b'>}</span>

    <span class='y'>// check overrides all overrode something</span>
    t.slotDefs.each |SlotDef slot|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>slot.isOverride &amp;&amp; !slot.overridden &amp;&amp; !slot.isAccessor<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Override of unknown virtual slot '$slot.name'"</span>, slot.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Inherit</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='inheritType'>inheritType</span><span class='b'>(</span>TypeDef t, CType? parent<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>parent == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>t.qname == <span class='s'>"sys::Obj"</span><span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>else</span> <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Illegal state"</span>, t.loc<span class='b'>)</span>
    <span class='b'>}</span>

    closure := |CSlot s|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>parent.isMixin &amp;&amp; s.parent.isObj<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>try</span>
      <span class='b'>{</span>
        inheritSlot<span class='b'>(</span>t, s<span class='b'>)</span>
      <span class='b'>}</span>
      <span class='k'>catch</span> <span class='b'>(</span>CompilerErr e<span class='b'>)</span>
      <span class='b'>{</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// inherit each slot from parent type (if test then</span>
    <span class='y'>// sort the slots to test errors in consistent order)</span>
    <span class='k'>if</span> <span class='b'>(</span>compiler.input.isTest<span class='b'>)</span>
      parent.slots.vals.sort<span class='b'>(</span>|CSlot a, CSlot b-&gt;Int| <span class='b'>{</span><span class='k'>return</span> a.name &lt;=&gt; b.name<span class='b'>})</span>.each<span class='b'>(</span>closure<span class='b'>)</span>
    <span class='k'>else</span>
      parent.slots.each<span class='b'>(</span>closure<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='inheritSlot'>inheritSlot</span><span class='b'>(</span>TypeDef t, CSlot newSlot<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// TODO: I think we need a lot more checking here, especially if</span>
    <span class='y'>// private/internal is public in the Java VM, because right now</span>
    <span class='y'>// we just ignore all ctor, privates, and internals - but they might</span>
    <span class='y'>// cause us real conflicts at JVM/IL emit time if we didn't detect</span>
    <span class='y'>// here.  Plus right now overrides of private/internal show up</span>
    <span class='y'>// as unknown virtuals, when in reality we could check them here</span>
    <span class='y'>// as scope errors.  So this method needs some refactoring to fully</span>
    <span class='y'>// handle all the cases (along with a comprehensive test)</span>

    <span class='y'>// we never inherit constructors, private slots,</span>
    <span class='y'>// or internal slots outside of the pod</span>
    <span class='k'>if</span> <span class='b'>(</span>newSlot.isCtor || newSlot.isPrivate ||
        <span class='b'>(</span>newSlot.isInternal &amp;&amp; newSlot.parent.pod != t.pod<span class='b'>))</span>
      <span class='k'>return</span>

    <span class='y'>// check if there is already a slot mapped by that name</span>
    name := newSlot.name
    oldSlot := t.slot<span class='b'>(</span>name<span class='b'>)</span>

    <span class='y'>// if a new slot, add it to the type and we are done</span>
    <span class='k'>if</span> <span class='b'>(</span>oldSlot == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      t.addSlot<span class='b'>(</span>newSlot<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// if we've inherited the exact same slot from two different</span>
    <span class='y'>// class hiearchies, then no need to continue</span>
    <span class='k'>if</span> <span class='b'>(</span>newSlot === oldSlot<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// if this is one of the type's slot definitions, then check</span>
    <span class='y'>// that we have a valid inheritance override, in which case</span>
    <span class='y'>// we leave the old slot as the definition for this slot</span>
    <span class='y'>// name - otherwise we will log and throw an error; in all</span>
    <span class='y'>// cases we mark this slot overridden so that we don't report</span>
    <span class='y'>// spurious "Override of unknown virtual slot" errors</span>
    <span class='k'>if</span> <span class='b'>(</span>oldSlot.parent === t &amp;&amp; !newSlot.isCtor<span class='b'>)</span>
    <span class='b'>{</span>
      slotDef := <span class='b'>(</span>SlotDef<span class='b'>)</span>oldSlot
      slotDef.overridden = <span class='k'>true</span>
      checkOverride<span class='b'>(</span>t, newSlot, slotDef<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// if the two slots don't have matching signatures</span>
    <span class='y'>// then this is an inheritance conflict</span>
    <span class='k'>if</span> <span class='b'>(</span>!matchingSignatures<span class='b'>(</span>oldSlot, newSlot<span class='b'>))</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Inherited slots have conflicting signatures '$oldSlot.qname' and '$newSlot.qname'"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// check if there is a clear keeper between old and new slots</span>
    keep := keep<span class='b'>(</span>oldSlot, newSlot<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>keep != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>keep === newSlot<span class='b'>)</span> t.replaceSlot<span class='b'>(</span>oldSlot, newSlot<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// if both are virtual, then subclass must remove ambiguous</span>
    <span class='k'>if</span> <span class='b'>(</span>oldSlot.isVirtual &amp;&amp; newSlot.isVirtual<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Must override ambiguous inheritance '$oldSlot.qname' and '$newSlot.qname'"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// anything else is an unfixable inheritance conflict</span>
    <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Inheritance conflict '$oldSlot.qname' and '$newSlot.qname'"</span>, t.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if two slots have matching signatures</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Bool <span id='matchingSignatures'>matchingSignatures</span><span class='b'>(</span>CSlot a, CSlot b<span class='b'>)</span>
  <span class='b'>{</span>
    fa := a <span class='k'>as</span> CField
    fb := b <span class='k'>as</span> CField
    ma := a <span class='k'>as</span> CMethod
    mb := b <span class='k'>as</span> CMethod

    <span class='k'>if</span> <span class='b'>(</span>fa != <span class='k'>null</span> &amp;&amp; fb != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> fa.fieldType == fb.fieldType

    <span class='k'>if</span> <span class='b'>(</span>ma != <span class='k'>null</span> &amp;&amp; mb != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> ma.returnType == mb.returnType &amp;&amp;
             ma.inheritedReturnType == mb.inheritedReturnType &amp;&amp;
             ma.hasSameParams<span class='b'>(</span>mb<span class='b'>)</span>

    <span class='k'>if</span> <span class='b'>(</span>fa != <span class='k'>null</span> &amp;&amp; mb != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> fa.fieldType == mb.returnType &amp;&amp;
             fa.fieldType == mb.inheritedReturnType &amp;&amp;
             mb.params.size == 0

    <span class='k'>if</span> <span class='b'>(</span>ma != <span class='k'>null</span> &amp;&amp; fb != <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>return</span> ma.returnType == fb.fieldType &amp;&amp;
             ma.inheritedReturnType == fb.fieldType &amp;&amp;
             ma.params.size == 0

    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if there is a clear keeper between a and b - if so</span>
  <span class='z'>** return the one to keep otherwise return null.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> CSlot? <span id='keep'>keep</span><span class='b'>(</span>CSlot a, CSlot b<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if one is abstract and one concrete we keep the concrete one</span>
    <span class='k'>if</span> <span class='b'>(</span>a.isAbstract &amp;&amp; !b.isAbstract<span class='b'>)</span> <span class='k'>return</span> b
    <span class='k'>if</span> <span class='b'>(</span>!a.isAbstract &amp;&amp; b.isAbstract<span class='b'>)</span> <span class='k'>return</span> a

    <span class='y'>// keep one if it is a clear override from the other</span>
    <span class='k'>if</span> <span class='b'>(</span>a.parent.fits<span class='b'>(</span>b.parent<span class='b'>))</span> <span class='k'>return</span> a
    <span class='k'>if</span> <span class='b'>(</span>b.parent.fits<span class='b'>(</span>a.parent<span class='b'>))</span> <span class='k'>return</span> b

    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Check that def is a valid override of the base slot.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='checkOverride'>checkOverride</span><span class='b'>(</span>TypeDef t, CSlot base, SlotDef def<span class='b'>)</span>
  <span class='b'>{</span>
    loc := def.loc

    <span class='y'>// check base is virtual</span>
    <span class='k'>if</span> <span class='b'>(</span>!base.isVirtual<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Cannot override non-virtual slot '$base.qname'"</span>, loc<span class='b'>)</span>

    <span class='y'>// check override keyword was specified</span>
    <span class='k'>if</span> <span class='b'>(</span>!def.isOverride<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Must specify override keyword to override '$base.qname'"</span>, loc<span class='b'>)</span>

    <span class='y'>// check protection scope</span>
    <span class='k'>if</span> <span class='b'>(</span>isOverrideProtectionErr<span class='b'>(</span>base, def<span class='b'>))</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Override narrows protection scope of '$base.qname'"</span>, loc<span class='b'>)</span>

    <span class='y'>// if overriding a FFI slot give bridge a hook</span>
    <span class='k'>if</span> <span class='b'>(</span>base.isForeign<span class='b'>)</span>
      base.bridge.checkOverride<span class='b'>(</span>t, base, def<span class='b'>)</span>

    <span class='y'>// check if this is a method/method override</span>
    <span class='k'>if</span> <span class='b'>(</span>base <span class='k'>is</span> CMethod &amp;&amp; def <span class='k'>is</span> MethodDef<span class='b'>)</span>
    <span class='b'>{</span>
      checkMethodMethodOverride<span class='b'>(</span>t, <span class='b'>(</span>CMethod<span class='b'>)</span>base, <span class='b'>(</span>MethodDef<span class='b'>)</span>def<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// check if this is a method/field override</span>
    <span class='k'>if</span> <span class='b'>(</span>base <span class='k'>is</span> CMethod &amp;&amp; def <span class='k'>is</span> FieldDef<span class='b'>)</span>
    <span class='b'>{</span>
      checkMethodFieldOverride<span class='b'>(</span>t, <span class='b'>(</span>CMethod<span class='b'>)</span>base, <span class='b'>(</span>FieldDef<span class='b'>)</span>def<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// check if this is a field/field override</span>
    <span class='k'>if</span> <span class='b'>(</span>base <span class='k'>is</span> CField &amp;&amp; def <span class='k'>is</span> FieldDef<span class='b'>)</span>
    <span class='b'>{</span>
      checkFieldFieldOverride<span class='b'>(</span>t, <span class='b'>(</span>CField<span class='b'>)</span>base, <span class='b'>(</span>FieldDef<span class='b'>)</span>def<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// TODO otherwise this is a potential inheritance conflict</span>
    <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Invalid slot override of '$base.qname'"</span>, def.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Bool <span id='isOverrideProtectionErr'>isOverrideProtectionErr</span><span class='b'>(</span>CSlot base, SlotDef def<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>def.isPublic<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>

    <span class='k'>if</span> <span class='b'>(</span>def.isProtected<span class='b'>)</span>
      <span class='k'>return</span> base.isPublic || base.isInternal

    <span class='k'>if</span> <span class='b'>(</span>def.isInternal<span class='b'>)</span>
      <span class='k'>return</span> base.isPublic || base.isProtected

    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMethodMethodOverride'>checkMethodMethodOverride</span><span class='b'>(</span>TypeDef t, CMethod base, MethodDef def<span class='b'>)</span>
  <span class='b'>{</span>
    loc := def.loc

    defRet := def.returnType
    baseRet := base.returnType

    <span class='y'>// if the base is defined as This, then all overrides must be This</span>
    <span class='k'>if</span> <span class='b'>(</span>baseRet.isThis<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!defRet.isThis<span class='b'>)</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Return in override of '$base.qname' must be This"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// check return types</span>
      <span class='k'>if</span> <span class='b'>(</span>defRet != baseRet<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='y'>// check if new return type is a subtype of original</span>
        <span class='y'>// return type (we allow covariant return types)</span>
        <span class='k'>if</span> <span class='b'>(</span>!defRet.fits<span class='b'>(</span>baseRet<span class='b'>)</span> || <span class='b'>(</span>defRet.isVoid &amp;&amp; !baseRet.isVoid<span class='b'>)</span> || defRet.isNullable != baseRet.isNullable<span class='b'>)</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Return type mismatch in override of '$base.qname' - '$baseRet.inferredAs' != '$defRet'"</span>, loc<span class='b'>)</span>

        <span class='y'>// can't use covariance with value types</span>
        <span class='k'>if</span> <span class='b'>(</span>defRet.isVal || baseRet.isVal<span class='b'>)</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Cannot use covariance with value types '$base.qname' - '$baseRet' != '$defRet'"</span>, loc<span class='b'>)</span>
      <span class='b'>}</span>

      <span class='y'>// if the definition already has a covariant return type, then</span>
      <span class='y'>// it must be exactly the same type as this new override (we</span>
      <span class='y'>// can't have conflicting covariant overrides</span>
      <span class='k'>if</span> <span class='b'>(</span>def.inheritedRet != <span class='k'>null</span> &amp;&amp; def.inheritedRet != base.inheritedReturnType<span class='b'>)</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Conflicting covariant returns: '$def.inheritedRet' and '$base.inheritedReturnType'"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// save original return type</span>
    def.inheritedRet = base.inheritedReturnType

    <span class='y'>// check that we have same parameter count</span>
    <span class='k'>if</span> <span class='b'>(</span>!base.hasSameParams<span class='b'>(</span>def<span class='b'>))</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Parameter mismatch in override of '$base.qname' - '$base.nameAndParamTypesToStr' != '$def.nameAndParamTypesToStr'"</span>, loc<span class='b'>)</span>

    <span class='y'>// correct override</span>
    <span class='k'>return</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMethodFieldOverride'>checkMethodFieldOverride</span><span class='b'>(</span>TypeDef t, CMethod base, FieldDef def<span class='b'>)</span>
  <span class='b'>{</span>
    loc := def.loc

    <span class='y'>// check that types match</span>
    ft := def.fieldType
    rt := base.returnType
    <span class='k'>if</span> <span class='b'>(</span>ft != rt<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// we allow field to be covariant typed</span>
      <span class='k'>if</span> <span class='b'>(</span>!ft.fits<span class='b'>(</span>rt<span class='b'>)</span> || ft.isNullable != rt.isNullable<span class='b'>)</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Type mismatch in override of '$base.qname' - '$rt' != '$ft'"</span>, loc<span class='b'>)</span>

      <span class='y'>// can't use covariance with value types</span>
      <span class='k'>if</span> <span class='b'>(</span>ft.isVal || rt.isVal<span class='b'>)</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Cannot use covariance with value types '$base.qname' - '$rt' != '$ft'"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check that method has no parameters</span>
    <span class='k'>if</span> <span class='b'>(</span>!base.params.isEmpty<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Field '$def.name' cannot override method with params '$base.qname'"</span>, loc<span class='b'>)</span>

    <span class='y'>// save original return type</span>
    def.inheritedRet = base.inheritedReturnType

    <span class='y'>// correct override</span>
    <span class='k'>return</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkFieldFieldOverride'>checkFieldFieldOverride</span><span class='b'>(</span>TypeDef t, CField base, FieldDef def<span class='b'>)</span>
  <span class='b'>{</span>
    loc := def.loc

    <span class='y'>// check that types match</span>
    <span class='k'>if</span> <span class='b'>(</span>base.fieldType != def.fieldType<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Type mismatch in override of '$base.qname' - '$base.fieldType' != '$def.fieldType'"</span>, loc<span class='b'>)</span>

    <span class='y'>// if overriding a field which has storage, then don't duplicate storage</span>
    <span class='k'>if</span> <span class='b'>(</span>!base.isAbstract<span class='b'>)</span>
      def.concreteBase = base

    <span class='y'>// const field cannot override a field (const fields cannot be set,</span>
    <span class='y'>// therefore they can override only methods)</span>
    <span class='k'>if</span> <span class='b'>(</span>def.isConst<span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Const field '$def.name' cannot override field '$base.qname'"</span>, loc<span class='b'>)</span>

    <span class='y'>// correct override</span>
    <span class='k'>return</span>
  <span class='b'>}</span>


<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Inherit.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#checkFieldFieldOverride'>checkFieldFieldOverride</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMethodFieldOverride'>checkMethodFieldOverride</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMethodMethodOverride'>checkMethodMethodOverride</a></li>
  <li class='hidden' style='display: block;'><a href='#checkOverride'>checkOverride</a></li>
  <li class='hidden' style='display: block;'><a href='#inheritSlot'>inheritSlot</a></li>
  <li class='hidden' style='display: block;'><a href='#inheritType'>inheritType</a></li>
  <li class='hidden' style='display: block;'><a href='#isOverrideProtectionErr'>isOverrideProtectionErr</a></li>
  <li class='hidden' style='display: block;'><a href='#keep'>keep</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li class='hidden' style='display: block;'><a href='#matchingSignatures'>matchingSignatures</a></li>
  <li style='display: block;'><a href='#run'>run</a></li>
  <li style='display: block;'><a href='#visitTypeDef'>visitTypeDef</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

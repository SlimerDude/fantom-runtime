<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::ResolveExpr</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='ResolveExpr.html'>ResolveExpr</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::ResolveExpr</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    <a href='CompilerStep.html'>compiler::CompilerStep</a>
      compiler::ResolveExpr</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   2 Dec 05  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Walk the AST to resolve:</span>
<span class='z'>**   - Manage local variable scope</span>
<span class='z'>**   - Resolve loop for breaks and continues</span>
<span class='z'>**   - Resolve LocalDefStmt.init into full assignment expression</span>
<span class='z'>**   - Resolve Expr.ctype</span>
<span class='z'>**   - Resolve UknownVarExpr -&gt; LocalVarExpr, FieldExpr, or CallExpr</span>
<span class='z'>**   - Resolve CallExpr to their CMethod</span>
<span class='z'>**</span>
<span class='k'>class</span> ResolveExpr : CompilerStep
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Run</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='run'>run</span><span class='b'>()</span>
  <span class='b'>{</span>
    log.debug<span class='b'>(</span><span class='s'>"ResolveExpr"</span><span class='b'>)</span>
    walk<span class='b'>(</span>compiler, VisitDepth.expr<span class='b'>)</span>
    bombIfErr
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Method</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='enterMethodDef'>enterMethodDef</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>super</span>.enterMethodDef<span class='b'>(</span>m<span class='b'>)</span>
    <span class='k'>this</span>.inClosure = <span class='b'>(</span>curType.isClosure &amp;&amp; curType.closure.doCall === m<span class='b'>)</span>
    initMethodVars
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Stmt</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='enterStmt'>enterStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span> <span class='b'>{</span> stmtStack.push<span class='b'>(</span>stmt<span class='b'>)</span> <span class='b'>}</span>

  <span class='k'>override</span> Stmt<span class='b'>[]</span>? <span id='visitStmt'>visitStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    stmtStack.pop
    <span class='k'>switch</span> <span class='b'>(</span>stmt.id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> StmtId.expr:         resolveExprStmt<span class='b'>((</span>ExprStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.forStmt:      resolveFor<span class='b'>((</span>ForStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.breakStmt:    resolveBreak<span class='b'>((</span>BreakStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.continueStmt: resolveContinue<span class='b'>((</span>ContinueStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.localDef:     resolveLocalVarDef<span class='b'>((</span>LocalDefStmt<span class='b'>)</span>stmt<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='resolveExprStmt'>resolveExprStmt</span><span class='b'>(</span>ExprStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// stand alone expr statements, shouldn't be left on the stack</span>
    stmt.expr = stmt.expr.noLeave
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='resolveLocalVarDef'>resolveLocalVarDef</span><span class='b'>(</span>LocalDefStmt def<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check for type inference</span>
    <span class='k'>if</span> <span class='b'>(</span>def.ctype == <span class='k'>null</span><span class='b'>)</span>
      def.ctype = def.init.ctype.inferredAs

    <span class='y'>// bind to scope as a method variable</span>
    bindToMethodVar<span class='b'>(</span>def<span class='b'>)</span>

    <span class='y'>// if init is null, then we default the variable to null (Fan</span>
    <span class='y'>// doesn't do true definite assignment checking since most local</span>
    <span class='y'>// variables use type inference anyhow)</span>
    <span class='k'>if</span> <span class='b'>(</span>def.init == <span class='k'>null</span> &amp;&amp; !def.isCatchVar<span class='b'>)</span>
      def.init = LiteralExpr.makeDefaultLiteral<span class='b'>(</span>def.loc, ns, def.ctype<span class='b'>)</span>

    <span class='y'>// turn init into full assignment</span>
    <span class='k'>if</span> <span class='b'>(</span>def.init != <span class='k'>null</span><span class='b'>)</span>
      def.init = BinaryExpr.makeAssign<span class='b'>(</span>LocalVarExpr<span class='b'>(</span>def.loc, def.var<span class='b'>)</span>, def.init<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='resolveFor'>resolveFor</span><span class='b'>(</span>ForStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// don't leave update expression on the stack</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.update != <span class='k'>null</span><span class='b'>)</span> stmt.update = stmt.update.noLeave
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='resolveBreak'>resolveBreak</span><span class='b'>(</span>BreakStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// find which loop we're inside of (checked in CheckErrors)</span>
    stmt.loop = findLoop
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='resolveContinue'>resolveContinue</span><span class='b'>(</span>ContinueStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// find which loop we're inside of (checked in CheckErrors)</span>
    stmt.loop = findLoop
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Expr</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Expr <span id='visitExpr'>visitExpr</span><span class='b'>(</span>Expr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// resolve the expression</span>
    expr = resolveExpr<span class='b'>(</span>expr<span class='b'>)</span>

    <span class='y'>// expr type must be resolved at this point</span>
    <span class='k'>if</span> <span class='b'>((</span>Obj?<span class='b'>)</span>expr.ctype == <span class='k'>null</span><span class='b'>)</span>
      <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Expr type not resolved: ${expr.id}: ${expr}"</span>, expr.loc<span class='b'>)</span>

    <span class='y'>// if we resolved to a generic parameter like V or K,</span>
    <span class='y'>// then use its real underlying type</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.ctype.isGenericParameter<span class='b'>)</span>
      expr.ctype = expr.ctype.raw

    <span class='y'>// if this expression performs assignment against a local</span>
    <span class='y'>// variable, then note the reassignment so that we know it</span>
    <span class='y'>// is not a final variable (final being like Java semanatics)</span>
    assignTarget := expr.assignTarget <span class='k'>as</span> LocalVarExpr
    <span class='k'>if</span> <span class='b'>(</span>assignTarget != <span class='k'>null</span> &amp;&amp; assignTarget.var != <span class='k'>null</span><span class='b'>)</span>
      assignTarget.var.reassigned

    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='k'>private</span> Expr <span id='resolveExpr'>resolveExpr</span><span class='b'>(</span>Expr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>expr.id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.localeLiteral:   <span class='k'>return</span> resolveLocaleLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.slotLiteral:     <span class='k'>return</span> resolveSlotLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.listLiteral:     <span class='k'>return</span> resolveList<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.mapLiteral:      <span class='k'>return</span> resolveMap<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.boolNot:
      <span class='k'>case</span> ExprId.cmpNull:
      <span class='k'>case</span> ExprId.cmpNotNull:      expr.ctype = ns.boolType
      <span class='k'>case</span> ExprId.assign:          <span class='k'>return</span> resolveAssign<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.elvis:           resolveElvis<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.same:
      <span class='k'>case</span> ExprId.notSame:
      <span class='k'>case</span> ExprId.boolOr:
      <span class='k'>case</span> ExprId.boolAnd:
      <span class='k'>case</span> ExprId.isExpr:          expr.ctype = ns.boolType
      <span class='k'>case</span> ExprId.isnotExpr:       expr.ctype = ns.boolType
      <span class='k'>case</span> ExprId.asExpr:          expr.ctype = <span class='b'>((</span>TypeCheckExpr<span class='b'>)</span>expr<span class='b'>)</span>.check.toNullable
      <span class='k'>case</span> ExprId.call:            <span class='k'>return</span> resolveCall<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.construction:    <span class='k'>return</span> resolveConstruction<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.shortcut:        <span class='k'>return</span> resolveShortcut<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.thisExpr:        <span class='k'>return</span> resolveThis<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.superExpr:       <span class='k'>return</span> resolveSuper<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.itExpr:          <span class='k'>return</span> resolveIt<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.unknownVar:      <span class='k'>return</span> resolveVar<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.storage:         <span class='k'>return</span> resolveStorage<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.coerce:          expr.ctype = <span class='b'>((</span>TypeCheckExpr<span class='b'>)</span>expr<span class='b'>)</span>.check
      <span class='k'>case</span> ExprId.ternary:         resolveTernary<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.closure:         resolveClosure<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.dsl:             <span class='k'>return</span> resolveDsl<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.throwExpr:       expr.ctype = ns.nothingType
    <span class='b'>}</span>

    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve locale literal '$&lt;pod::key=def&gt;'</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveLocaleLiteral'>resolveLocaleLiteral</span><span class='b'>(</span>LocaleLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    loc := expr.loc

    <span class='y'>// cannot define def with explicit podName</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.podName != <span class='k'>null</span> &amp;&amp; expr.def != <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Locale literal cannot specify both qualified pod and default value"</span>, loc<span class='b'>)</span>

    <span class='y'>// cannot specify using current pod if output is not pod</span>
    outputMode := compiler.input.output
    <span class='k'>if</span> <span class='b'>(</span>expr.podName == <span class='k'>null</span> &amp;&amp; outputMode != CompilerOutputMode.podFile<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Scripts cannot define non-qualified locale literals"</span>, loc<span class='b'>)</span>

    <span class='y'>// if we have a def, then add to compiler to merge into locale/en.props</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.def != <span class='k'>null</span><span class='b'>)</span> compiler.localeDefs.add<span class='b'>(</span>expr<span class='b'>)</span>

    <span class='y'>// Pod.find(podName) or curType#.pod</span>
    podTarget := expr.podName != <span class='k'>null</span> ?
      CallExpr.makeWithMethod<span class='b'>(</span>loc, <span class='k'>null</span>, ns.podFind, <span class='b'>[</span>LiteralExpr.makeStr<span class='b'>(</span>loc, ns, expr.podName<span class='b'>)])</span> :
      CallExpr.makeWithMethod<span class='b'>(</span>loc, LiteralExpr<span class='b'>(</span>loc, ExprId.typeLiteral, ns.typeType, curType<span class='b'>)</span>, ns.typePod<span class='b'>)</span>

    <span class='y'>// podTarget.locale(key [, def])</span>
    args := <span class='b'>[</span>LiteralExpr.makeStr<span class='b'>(</span>loc, ns, expr.key<span class='b'>)]</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.def != <span class='k'>null</span><span class='b'>)</span> args.add<span class='b'>(</span>LiteralExpr.makeStr<span class='b'>(</span>loc, ns, expr.def<span class='b'>))</span>
    <span class='k'>return</span> CallExpr.makeWithMethod<span class='b'>(</span>loc, podTarget, ns.podLocale, args<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve slot literal</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveSlotLiteral'>resolveSlotLiteral</span><span class='b'>(</span>SlotLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    slot := expr.parent.slot<span class='b'>(</span>expr.name<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>slot == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Unknown slot literal '${expr.parent.signature}.${expr.name}'"</span>, expr.loc<span class='b'>)</span>
      expr.ctype = ns.error
      <span class='k'>return</span> expr
    <span class='b'>}</span>
    expr.ctype = slot <span class='k'>is</span> CField ? ns.fieldType : ns.methodType
    expr.slot = slot
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve list literal</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveList'>resolveList</span><span class='b'>(</span>ListLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.explicitType != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      expr.ctype = expr.explicitType
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// infer from list item expressions</span>
      v := Expr.commonType<span class='b'>(</span>ns, expr.vals<span class='b'>)</span>
      expr.ctype = v.toListOf
    <span class='b'>}</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve map literal</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveMap'>resolveMap</span><span class='b'>(</span>MapLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.explicitType != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      expr.ctype = expr.explicitType
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// infer from key/val expressions</span>
      k := Expr.commonType<span class='b'>(</span>ns, expr.keys<span class='b'>)</span>.toNonNullable
      v := Expr.commonType<span class='b'>(</span>ns, expr.vals<span class='b'>)</span>
      expr.ctype = MapType<span class='b'>(</span>k, v<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve this keyword expression</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveThis'>resolveThis</span><span class='b'>(</span>ThisExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>inClosure<span class='b'>)</span>
    <span class='b'>{</span>
      loc := expr.loc
      closure := curType.closure

      <span class='y'>// if the closure is in a static slot, report an error</span>
      <span class='k'>if</span> <span class='b'>(</span>closure.enclosingSlot.isStatic<span class='b'>)</span>
      <span class='b'>{</span>
        expr.ctype = ns.error
        err<span class='b'>(</span><span class='s'>"Cannot access 'this' within closure of static context"</span>, loc<span class='b'>)</span>
        <span class='k'>return</span> expr
      <span class='b'>}</span>

      <span class='y'>// otherwise replace this with $this field access</span>
      <span class='k'>return</span> FieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc<span class='b'>)</span>, closure.outerThisField<span class='b'>)</span>
    <span class='b'>}</span>

    expr.ctype = curType
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve super keyword expression</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveSuper'>resolveSuper</span><span class='b'>(</span>SuperExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>inClosure<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// it would be nice to support super from within a closure,</span>
      <span class='y'>// but the Java VM has the stupid restriction that invokespecial</span>
      <span class='y'>// cannot be used outside of the class - we could potentially</span>
      <span class='y'>// work around this using a wrapper method - but for now we will</span>
      <span class='y'>// just disallow it</span>
      err<span class='b'>(</span><span class='s'>"Invalid use of 'super' within closure"</span>, expr.loc<span class='b'>)</span>
      expr.ctype = ns.error
      <span class='k'>return</span> expr
    <span class='b'>}</span>

    <span class='k'>if</span> <span class='b'>(</span>expr.explicitType != <span class='k'>null</span><span class='b'>)</span>
      expr.ctype = expr.explicitType
    <span class='k'>else</span>
      expr.ctype = curType.base

    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve it keyword expression</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveIt'>resolveIt</span><span class='b'>(</span>ItExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if inside of field setter it is our implicit val parameter</span>
    <span class='k'>if</span> <span class='b'>(</span>curMethod != <span class='k'>null</span> &amp;&amp; curMethod.isFieldSetter<span class='b'>)</span>
      <span class='k'>return</span> LocalVarExpr<span class='b'>(</span>expr.loc, curMethod.vars.first<span class='b'>)</span>

    <span class='y'>// can't use it keyword outside of an it-block</span>
    <span class='k'>if</span> <span class='b'>(</span>!inClosure || !curType.closure.isItBlock<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Invalid use of 'it' outside of it-block"</span>, expr.loc<span class='b'>)</span>
      expr.ctype = ns.error
      <span class='k'>return</span> expr
    <span class='b'>}</span>

    <span class='y'>// closure's itType should be defined at this point</span>
    expr.ctype = curType.closure.itType
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve an assignment operation</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveAssign'>resolveAssign</span><span class='b'>(</span>BinaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if lhs has synthetic coercion we need to remove it;</span>
    <span class='y'>// this can occur when resolving a FFI field - in order</span>
    <span class='y'>// for this to work there are only two possible allowed</span>
    <span class='y'>// coercions: 1) a TypeCheckExpr or 2) a CallExpr where</span>
    <span class='y'>// the non-coerced expression is the last argument</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.lhs.synthetic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>expr.lhs.id === ExprId.coerce<span class='b'>)</span>
        expr.lhs = <span class='b'>((</span>TypeCheckExpr<span class='b'>)</span>expr.lhs<span class='b'>)</span>.target
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>expr.lhs.id === ExprId.call<span class='b'>)</span>
        expr.lhs = <span class='b'>((</span>CallExpr<span class='b'>)</span>expr.lhs<span class='b'>)</span>.args.last
      <span class='k'>else</span>
        <span class='k'>throw</span> Err<span class='b'>(</span><span class='s'>"Unexpected LHS synthetic expr: $expr [$expr.loc.toLocStr]"</span><span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check for left hand side the [] shortcut, because []= is set</span>
    shortcut := expr.lhs <span class='k'>as</span> ShortcutExpr
    <span class='k'>if</span> <span class='b'>(</span>shortcut != <span class='k'>null</span> &amp;&amp; shortcut.op == ShortcutOp.get<span class='b'>)</span>
    <span class='b'>{</span>
      shortcut.op = ShortcutOp.set
      shortcut.name = <span class='s'>"set"</span>
      shortcut.args.add<span class='b'>(</span>expr.rhs<span class='b'>)</span>
      shortcut.method = <span class='k'>null</span>
      <span class='k'>return</span> resolveCall<span class='b'>(</span>shortcut<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check for left hand side the -&gt; shortcut, because a-&gt;x=b is trap.a("x", [b])</span>
    call := expr.lhs <span class='k'>as</span> CallExpr
    <span class='k'>if</span> <span class='b'>(</span>call != <span class='k'>null</span> &amp;&amp; call.isDynamic<span class='b'>)</span>
    <span class='b'>{</span>
      call.args.add<span class='b'>(</span>expr.rhs<span class='b'>)</span>
      <span class='k'>return</span> resolveCall<span class='b'>(</span>call<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// assignment is typed by lhs</span>
    expr.ctype = expr.lhs.ctype

    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve an UnknownVar to its replacement node.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveVar'>resolveVar</span><span class='b'>(</span>UnknownVarExpr var<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if there is no target, attempt to bind to local variable</span>
    <span class='k'>if</span> <span class='b'>(</span>var.target == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// attempt to a name in the current scope</span>
      binding := resolveLocal<span class='b'>(</span>var.name, var.loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>binding != <span class='k'>null</span><span class='b'>)</span>
        <span class='k'>return</span> LocalVarExpr<span class='b'>(</span>var.loc, binding<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// at this point it can't be a local variable, so it must be</span>
    <span class='y'>// a slot on either myself or the variable's target</span>
    <span class='k'>return</span> CallResolver<span class='b'>(</span>compiler, curType, curMethod, var<span class='b'>)</span>.resolve
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve storage operator</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveStorage'>resolveStorage</span><span class='b'>(</span>UnknownVarExpr var<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// resolve as normal unknown variable</span>
    resolved := resolveVar<span class='b'>(</span>var<span class='b'>)</span>

    <span class='y'>// handle case where we have a local variable hiding a</span>
    <span class='y'>// field since the *x is assumed to be this.*x</span>
    <span class='k'>if</span> <span class='b'>(</span>resolved.id === ExprId.localVar<span class='b'>)</span>
    <span class='b'>{</span>
      field := curType.field<span class='b'>(</span>var.name<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>field != <span class='k'>null</span><span class='b'>)</span>
        resolved = FieldExpr<span class='b'>(</span>var.loc, ThisExpr<span class='b'>(</span>var.loc<span class='b'>)</span>, field<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// is we can't resolve as field, then this is an error</span>
    <span class='k'>if</span> <span class='b'>(</span>resolved.id !== ExprId.field<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>resolved.ctype !== ns.error<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Invalid use of field storage operator '&amp;'"</span>, var.loc<span class='b'>)</span>
      <span class='k'>return</span> resolved
    <span class='b'>}</span>

    f := resolved <span class='k'>as</span> FieldExpr
    f.useAccessor = <span class='k'>false</span>
    <span class='k'>if</span> <span class='b'>(</span>f.field <span class='k'>is</span> FieldDef<span class='b'>)</span>
    <span class='b'>{</span>
      fd := <span class='b'>(</span>FieldDef<span class='b'>)</span>f.field
      fd.flags = fd.flags.or<span class='b'>(</span>FConst.Storage<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> f
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve "x ?: y" expression</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveElvis'>resolveElvis</span><span class='b'>(</span>BinaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    expr.ctype = CType.common<span class='b'>(</span>ns, <span class='b'>[</span>expr.lhs.ctype, expr.rhs.ctype<span class='b'>])</span>.toNullable
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve "x ? y : z" ternary expression</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveTernary'>resolveTernary</span><span class='b'>(</span>TernaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.trueExpr.id === ExprId.nullLiteral<span class='b'>)</span>
      expr.ctype = expr.falseExpr.ctype.toNullable
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>expr.falseExpr.id === ExprId.nullLiteral<span class='b'>)</span>
      expr.ctype = expr.trueExpr.ctype.toNullable
    <span class='k'>else</span>
      expr.ctype = CType.common<span class='b'>(</span>ns, <span class='b'>[</span>expr.trueExpr.ctype, expr.falseExpr.ctype<span class='b'>])</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve a call to it's Method and return type.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveCall'>resolveCall</span><span class='b'>(</span>CallExpr call<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// dynamic calls are just syntactic sugar for Obj.trap</span>
    <span class='k'>if</span> <span class='b'>(</span>call.isDynamic<span class='b'>)</span>
    <span class='b'>{</span>
      call.method = ns.objTrap
      call.ctype = ns.objType.toNullable
      <span class='k'>return</span> call
    <span class='b'>}</span>

    <span class='y'>// if this is a constructor chained call to a FFI</span>
    <span class='y'>// super-class then route to the FFI bridge to let it handle</span>
    <span class='k'>if</span> <span class='b'>(</span>call.isCtorChain &amp;&amp; curType.base.isForeign<span class='b'>)</span>
      <span class='k'>return</span> curType.base.bridge.resolveConstructorChain<span class='b'>(</span>call<span class='b'>)</span>

    <span class='y'>// if there is no target, attempt to bind to local variable</span>
    <span class='k'>if</span> <span class='b'>(</span>call.target == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// attempt to a name in the current scope</span>
      binding := resolveLocal<span class='b'>(</span>call.name, call.loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>binding != <span class='k'>null</span><span class='b'>)</span>
        <span class='k'>return</span> resolveCallOnLocalVar<span class='b'>(</span>call, LocalVarExpr<span class='b'>(</span>call.loc, binding<span class='b'>))</span>
    <span class='b'>}</span>

    <span class='k'>return</span> CallResolver<span class='b'>(</span>compiler, curType, curMethod, call<span class='b'>)</span>.resolve
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve the () operator on a local variable - if the local</span>
  <span class='z'>** is a Method, then () is syntactic sugar for Method.callx()</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveCallOnLocalVar'>resolveCallOnLocalVar</span><span class='b'>(</span>CallExpr call, LocalVarExpr binding<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if the call was generated as an it-block on local</span>
    <span class='k'>if</span> <span class='b'>(</span>call.noParens &amp;&amp; call.args.size == 1<span class='b'>)</span>
    <span class='b'>{</span>
      closure:= call.args.last <span class='k'>as</span> ClosureExpr
      <span class='k'>if</span> <span class='b'>(</span>closure != <span class='k'>null</span> &amp;&amp; closure.isItBlock<span class='b'>)</span>
        <span class='k'>return</span> closure.toWith<span class='b'>(</span>binding<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// can only handle zero to eight arguments; I could wrap up the</span>
    <span class='y'>// arguments into a List and use call(List) - but methods with</span>
    <span class='y'>// that many arguments are just inane so tough luck</span>
    <span class='k'>if</span> <span class='b'>(</span>call.args.size &gt; 8<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Tough luck - cannot use () operator with more than 8 arguments, use call(List)"</span>, call.loc<span class='b'>)</span>
      call.ctype = ns.error
      <span class='k'>return</span> call
    <span class='b'>}</span>

    <span class='y'>// invoking the () operator on a sys::Func is syntactic</span>
    <span class='y'>// sugar for invoking one of the Func.call methods</span>
    callMethod := binding.ctype.method<span class='b'>(</span><span class='s'>"call"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>callMethod == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>binding.ctype != ns.error<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot use () call operator on non-func type '$binding.ctype'"</span>, call.loc<span class='b'>)</span>
      call.ctype = ns.error
      <span class='k'>return</span> call
    <span class='b'>}</span>
    call = CallExpr.makeWithMethod<span class='b'>(</span>call.loc, binding, callMethod, call.args<span class='b'>)</span>
    call.isCallOp = <span class='k'>true</span>
    <span class='k'>return</span> call
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve a construction call Type(args)</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveConstruction'>resolveConstruction</span><span class='b'>(</span>CallExpr call<span class='b'>)</span>
  <span class='b'>{</span>
    base := call.target.ctype

    <span class='y'>// route FFI constructors to bridge</span>
    <span class='k'>if</span> <span class='b'>(</span>base.isForeign<span class='b'>)</span> <span class='k'>return</span> base.bridge.resolveConstruction<span class='b'>(</span>call<span class='b'>)</span>

    <span class='y'>// construction always resolves to base type (we</span>
    <span class='y'>// double check this in CheckErrors)</span>
    call.ctype = base

    <span class='y'>// check for fromStr</span>
    <span class='k'>if</span> <span class='b'>(</span>call.args.size == 1 &amp;&amp; call.args.first.ctype.isStr<span class='b'>)</span>
    <span class='b'>{</span>
      fromStr := base.method<span class='b'>(</span><span class='s'>"fromStr"</span><span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>fromStr != <span class='k'>null</span> &amp;&amp; fromStr.parent == base<span class='b'>)</span>
      <span class='b'>{</span>
        call.method = fromStr
        <span class='k'>return</span> call
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// resolve make</span>
    call.method = base.method<span class='b'>(</span><span class='s'>"make"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>call.method == <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Unknown construction method '${base.qname}.make'"</span>, call.loc<span class='b'>)</span>

    <span class='y'>// hook to infer closure type from call or to</span>
    <span class='y'>// translateinto an implicit call to Obj.with</span>
    <span class='k'>return</span> CallResolver.inferClosureTypeFromCall<span class='b'>(</span><span class='k'>this</span>, call, base<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve ShortcutExpr.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveShortcut'>resolveShortcut</span><span class='b'>(</span>ShortcutExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if this is an indexed assigment such as x[y] += z</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.isAssign &amp;&amp; expr.target.id === ExprId.shortcut<span class='b'>)</span>
      <span class='k'>return</span> resolveIndexedAssign<span class='b'>(</span>expr<span class='b'>)</span>

    <span class='y'>// string concat is always optimized, and performs a bit</span>
    <span class='y'>// different since a non-string can be used as the lhs</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.isStrConcat<span class='b'>)</span>
    <span class='b'>{</span>
      expr.ctype  = ns.strType
      expr.method = ns.strPlus
      <span class='k'>return</span> ConstantFolder<span class='b'>(</span>compiler<span class='b'>)</span>.fold<span class='b'>(</span>expr<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if a binary operation</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.args.size == 1 &amp;&amp; expr.op.isOperator<span class='b'>)</span>
    <span class='b'>{</span>
      method := resolveBinaryOperator<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>method == <span class='k'>null</span><span class='b'>)</span> <span class='b'>{</span> expr.ctype = ns.error; <span class='k'>return</span> expr <span class='b'>}</span>
      expr.method = method
      expr.name   = method.name
    <span class='b'>}</span>

    <span class='y'>// resolve the call, if optimized, then return it immediately</span>
    result := resolveCall<span class='b'>(</span>expr<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>result !== expr<span class='b'>)</span> <span class='k'>return</span> result

    <span class='y'>// check that method has Operator facet</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.method != <span class='k'>null</span> &amp;&amp; expr.op.isOperator &amp;&amp; !expr.method.hasFacet<span class='b'>(</span><span class='s'>"sys::Operator"</span><span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Mising Operator facet: $expr.method.qname"</span>, expr.loc<span class='b'>)</span>

    <span class='y'>// the comparision operations are special case that call a method</span>
    <span class='y'>// that return an Int, but leave a Bool on the stack (we also handle</span>
    <span class='y'>// specially in assembler)</span>
    <span class='k'>switch</span> <span class='b'>(</span>expr.opToken<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> Token.lt:
      <span class='k'>case</span> Token.ltEq:
      <span class='k'>case</span> Token.gt:
      <span class='k'>case</span> Token.gtEq:
        expr.ctype = ns.boolType
    <span class='b'>}</span>

    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Given a shortcut method such as 'lhs op rhs' figure</span>
  <span class='z'>** out which method to use for the operator symbol.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> CMethod? <span id='resolveBinaryOperator'>resolveBinaryOperator</span><span class='b'>(</span>ShortcutExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    op := expr.op
    lhs := expr.target.ctype
    rhs := expr.args.first

    <span class='k'>if</span> <span class='b'>(</span>lhs === ns.error || rhs.ctype === ns.error<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>

    <span class='y'>// get matching operators for the method name</span>
    matches := lhs.operators.find<span class='b'>(</span>op.methodName<span class='b'>)</span>

    <span class='y'>// if multiple matches, attempt to narrow by argument type</span>
    <span class='k'>if</span> <span class='b'>(</span>matches.size &gt; 1<span class='b'>)</span>
    <span class='b'>{</span>
      matches = matches.findAll |m|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>m.params.size != 1<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
        paramType := m.params.first.paramType
        match := <span class='k'>true</span>
        CheckErrors.coerce<span class='b'>(</span>rhs, paramType, |-&gt;| <span class='b'>{</span> match = <span class='k'>false</span> <span class='b'>})</span>
        <span class='k'>return</span> match
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// if no matches bail</span>
    <span class='k'>if</span> <span class='b'>(</span>matches.isEmpty<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"No operator method found: ${op.formatErr(lhs, rhs.ctype)}"</span>, expr.loc<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>null</span>
    <span class='b'>}</span>

    <span class='y'>// if we have one match, we are golden</span>
    <span class='k'>if</span> <span class='b'>(</span>matches.size == 1<span class='b'>)</span> <span class='k'>return</span> matches.first

    <span class='y'>// still have an ambiguous operator method call</span>
    names := <span class='b'>(</span>matches.map |CMethod m-&gt;Str| <span class='b'>{</span> m.name <span class='b'>})</span>.join<span class='b'>(</span><span class='s'>", "</span><span class='b'>)</span>
    err<span class='b'>(</span><span class='s'>"Ambiguous operator method: ${op.formatErr(lhs, rhs.ctype)} ($names)"</span>, expr.loc<span class='b'>)</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If we have an assignment against an indexed shortcut</span>
  <span class='z'>** such as x[y] += z, then process specially to return</span>
  <span class='z'>** a IndexedAssignExpr subclass of ShortcutExpr.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveIndexedAssign'>resolveIndexedAssign</span><span class='b'>(</span>ShortcutExpr orig<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if target is in error, don't bother</span>
    <span class='k'>if</span> <span class='b'>(</span>orig.target.ctype === ns.error<span class='b'>)</span>
    <span class='b'>{</span>
      orig.ctype = ns.error
      <span class='k'>return</span> orig
    <span class='b'>}</span>

    <span class='y'>// we better have a x[y] indexed get expression</span>
    <span class='k'>if</span> <span class='b'>(</span>orig.target.id != ExprId.shortcut &amp;&amp; orig.target-&gt;op === ShortcutOp.get<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Expected indexed expression"</span>, orig.loc<span class='b'>)</span>
      <span class='k'>return</span> orig
    <span class='b'>}</span>

    <span class='y'>// wrap the shorcut as an IndexedAssignExpr</span>
    expr := IndexedAssignExpr.makeFrom<span class='b'>(</span>orig<span class='b'>)</span>

    <span class='y'>// resolve it normally - if the orig is "x[y] += z" then we</span>
    <span class='y'>// are resolving Int.plus here - the target is "x[y]" and should</span>
    <span class='y'>// already be resolved</span>
    resolveCall<span class='b'>(</span>expr<span class='b'>)</span>

    <span class='y'>// resolve the set method which matches</span>
    <span class='y'>// the get method on the target</span>
    get := <span class='b'>((</span>ShortcutExpr<span class='b'>)</span>expr.target<span class='b'>)</span>.method
    set := get.parent.method<span class='b'>(</span><span class='s'>"set"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>set == <span class='k'>null</span> || set.params.size != 2 || set.isStatic ||
        set.params<span class='b'>[</span>0<span class='b'>]</span>.paramType.toNonNullable != get.params<span class='b'>[</span>0<span class='b'>]</span>.paramType.toNonNullable ||
        set.params<span class='b'>[</span>1<span class='b'>]</span>.paramType.toNonNullable != get.returnType.toNonNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"No matching 'set' method for '$get.qname'"</span>, orig.loc<span class='b'>)</span>
    <span class='k'>else</span>
      expr.setMethod = set

    <span class='y'>// return the new IndexedAssignExpr</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** ClosureExpr will just output its substitute expression.  But we take</span>
  <span class='z'>** this opportunity to capture the local variables in the closure's scope</span>
  <span class='z'>** and cache them on the ClosureExpr.  We also do variable name checking.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='resolveClosure'>resolveClosure</span><span class='b'>(</span>ClosureExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// save away current locals in scope</span>
    expr.enclosingVars = localsInScope

    <span class='y'>// make sure none of the closure's parameters</span>
    <span class='y'>// conflict with the locals in scope</span>
    expr.doCall.paramDefs.each |ParamDef p|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>expr.enclosingVars.containsKey<span class='b'>(</span>p.name<span class='b'>)</span> &amp;&amp; p.name != <span class='s'>"it"</span><span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Closure parameter '$p.name' is already defined in current block"</span>, p.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve a DSL</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='resolveDsl'>resolveDsl</span><span class='b'>(</span>DslExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    plugin := DslPlugin.find<span class='b'>(</span><span class='k'>this</span>, expr.loc, expr.anchorType<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>plugin == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      expr.ctype = ns.error
      <span class='k'>return</span> expr
    <span class='b'>}</span>

    origNumErrs := compiler.errs.size
    expr.ctype = ns.error
    <span class='k'>try</span>
    <span class='b'>{</span>
      result := plugin.compile<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>result === expr<span class='b'>)</span> <span class='k'>return</span> result
      <span class='k'>return</span> visitExpr<span class='b'>(</span>result<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='b'>(</span>CompilerErr e<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>compiler.errs.size == origNumErrs<span class='b'>)</span> errReport<span class='b'>(</span>e<span class='b'>)</span>
      <span class='k'>return</span> expr
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='b'>(</span>Err e<span class='b'>)</span>
    <span class='b'>{</span>
      errReport<span class='b'>(</span>CompilerErr<span class='b'>(</span><span class='s'>"Internal error in DslPlugin '$plugin.typeof': $e"</span>, expr.loc, e<span class='b'>))</span>
      e.trace
      <span class='k'>return</span> expr
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Scope</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Setup the MethodVars for the parameters.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='initMethodVars'>initMethodVars</span><span class='b'>()</span>
  <span class='b'>{</span>
    m := curMethod
    reg := m.isStatic ?  0 : 1

    m.paramDefs.each |ParamDef p|
    <span class='b'>{</span>
      var := MethodVar.makeForParam<span class='b'>(</span>m, reg++, p, p.paramType.parameterizeThis<span class='b'>(</span>curType<span class='b'>))</span>
      m.vars.add<span class='b'>(</span>var<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Bind the specified local variable definition to a</span>
  <span class='z'>** MethodVar (and register number).</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='bindToMethodVar'>bindToMethodVar</span><span class='b'>(</span>LocalDefStmt def<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// make sure it doesn't exist in the current scope</span>
    <span class='k'>if</span> <span class='b'>(</span>resolveLocal<span class='b'>(</span>def.name, def.loc<span class='b'>)</span> != <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Variable '$def.name' is already defined in current block"</span>, def.loc<span class='b'>)</span>

    <span class='y'>// create and add it</span>
    def.var = curMethod.addLocalVarForDef<span class='b'>(</span>def, currentBlock<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve a local variable using current scope based on</span>
  <span class='z'>** the block stack and possibly the scope of a closure.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> MethodVar? <span id='resolveLocal'>resolveLocal</span><span class='b'>(</span>Str name, Loc loc<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if not in method, then we can't have a local</span>
    <span class='k'>if</span> <span class='b'>(</span>curMethod == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>

    <span class='y'>// attempt to bind a name in the current scope</span>
    binding := curMethod.vars.find |MethodVar var-&gt;Bool|
    <span class='b'>{</span>
      <span class='k'>return</span> var.name == name &amp;&amp; isBlockInScope<span class='b'>(</span>var.scope<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>binding != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> binding

    <span class='y'>// if a closure, check parent scope</span>
    <span class='k'>if</span> <span class='b'>(</span>inClosure<span class='b'>)</span>
    <span class='b'>{</span>
      closure := curType.closure
      binding = closure.enclosingVars<span class='b'>[</span>name<span class='b'>]</span>
      <span class='k'>if</span> <span class='b'>(</span>binding != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        <span class='y'>// mark the enclosing method and var as being used in a closure</span>
        binding.method.usesCvars = <span class='k'>true</span>
        binding.usedInClosure = <span class='k'>true</span>

        <span class='y'>// create new "shadow" local var in closure body which</span>
        <span class='y'>// shadows the enclosed variable from parent scope,</span>
        <span class='y'>// we'll do further processing in ClosureVars</span>
        shadow := curMethod.addLocalVar<span class='b'>(</span>binding.ctype, binding.name, currentBlock<span class='b'>)</span>
        shadow.usedInClosure = <span class='k'>true</span>
        shadow.shadows = binding

        <span class='y'>// if there are intervening closure scopes between</span>
        <span class='y'>// the original scope and current scope, then we need to</span>
        <span class='y'>// add a pass-thru variable in each scope</span>
        last := shadow
        <span class='k'>for</span> <span class='b'>(</span>p := closure.enclosingClosure; p != <span class='k'>null</span>; p = p.enclosingClosure<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>binding.method === p.doCall<span class='b'>)</span> <span class='k'>break</span>
          passThru := p.doCall.addLocalVar<span class='b'>(</span>binding.ctype, binding.name, p.doCall.code<span class='b'>)</span>
          passThru.usedInClosure = <span class='k'>true</span>
          passThru.shadows = binding
          passThru.usedInClosure = <span class='k'>true</span>
          last.shadows = passThru
          last = passThru
        <span class='b'>}</span>

        <span class='k'>return</span> shadow
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// not found</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get a list of all the local method variables that</span>
  <span class='z'>** are currently in scope.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Str:MethodVar <span id='localsInScope'>localsInScope</span><span class='b'>()</span>
  <span class='b'>{</span>
    Str:MethodVar acc := inClosure ?
      curType.closure.enclosingVars.dup :
      Str:MethodVar<span class='b'>[</span>:<span class='b'>]</span>

    curMethod.vars.each |MethodVar var|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isBlockInScope<span class='b'>(</span>var.scope<span class='b'>))</span>
        acc<span class='b'>[</span>var.name<span class='b'>]</span> = var
    <span class='b'>}</span>

    <span class='k'>return</span> acc
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get the current block which defines our scope.  We make</span>
  <span class='z'>** a special case for "for" loops which can declare variables.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Block <span id='currentBlock'>currentBlock</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmtStack.peek <span class='k'>is</span> ForStmt<span class='b'>)</span>
      <span class='k'>return</span> <span class='b'>((</span>ForStmt<span class='b'>)</span>stmtStack.peek<span class='b'>)</span>.block
    <span class='k'>else</span>
      <span class='k'>return</span> blockStack.peek
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Check if the specified block is currently in scope.  We make</span>
  <span class='z'>** a specialcase for "for" loops which can declare variables.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Bool <span id='isBlockInScope'>isBlockInScope</span><span class='b'>(</span>Block? block<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// the null block within the whole method (ctorChains or defaultParams)</span>
    <span class='k'>if</span> <span class='b'>(</span>block == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// special case for "for" loops</span>
    <span class='k'>if</span> <span class='b'>(</span>stmtStack.peek <span class='k'>is</span> ForStmt<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(((</span>ForStmt<span class='b'>)</span>stmtStack.peek<span class='b'>)</span>.block === block<span class='b'>)</span>
        <span class='k'>return</span> <span class='k'>true</span>
    <span class='b'>}</span>

    <span class='y'>// look in block stack which models scope chain</span>
    <span class='k'>return</span> blockStack.any |Block b-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> b === block <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// StmtStack</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Stmt? <span id='findLoop'>findLoop</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=stmtStack.size-1; i&gt;=0; --i<span class='b'>)</span>
    <span class='b'>{</span>
      stmt := stmtStack<span class='b'>[</span>i<span class='b'>]</span>
      <span class='k'>if</span> <span class='b'>(</span>stmt.id === StmtId.whileStmt<span class='b'>)</span> <span class='k'>return</span> stmt
      <span class='k'>if</span> <span class='b'>(</span>stmt.id === StmtId.forStmt<span class='b'>)</span>   <span class='k'>return</span> stmt
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// BlockStack</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='enterBlock'>enterBlock</span><span class='b'>(</span>Block block<span class='b'>)</span> <span class='b'>{</span> blockStack.push<span class='b'>(</span>block<span class='b'>)</span> <span class='b'>}</span>
  <span class='k'>override</span> Void <span id='exitBlock'>exitBlock</span><span class='b'>(</span>Block block<span class='b'>)</span>  <span class='b'>{</span> blockStack.pop <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  Stmt<span class='b'>[]</span> <span id='stmtStack'>stmtStack</span>  := Stmt<span class='b'>[</span>,<span class='b'>]</span>    <span class='y'>// statement stack</span>
  Block<span class='b'>[]</span> <span id='blockStack'>blockStack</span> := Block<span class='b'>[</span>,<span class='b'>]</span>  <span class='y'>// block stack used for scoping</span>
  Bool <span id='inClosure'>inClosure</span> := <span class='k'>false</span>         <span class='y'>// are we inside a closure's block</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='ResolveExpr.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#bindToMethodVar'>bindToMethodVar</a></li>
  <li style='display: block;'><a href='#blockStack'>blockStack</a></li>
  <li class='hidden' style='display: block;'><a href='#currentBlock'>currentBlock</a></li>
  <li style='display: block;'><a href='#enterBlock'>enterBlock</a></li>
  <li style='display: block;'><a href='#enterMethodDef'>enterMethodDef</a></li>
  <li style='display: block;'><a href='#enterStmt'>enterStmt</a></li>
  <li style='display: block;'><a href='#exitBlock'>exitBlock</a></li>
  <li class='hidden' style='display: block;'><a href='#findLoop'>findLoop</a></li>
  <li style='display: block;'><a href='#inClosure'>inClosure</a></li>
  <li class='hidden' style='display: block;'><a href='#initMethodVars'>initMethodVars</a></li>
  <li class='hidden' style='display: block;'><a href='#isBlockInScope'>isBlockInScope</a></li>
  <li class='hidden' style='display: block;'><a href='#localsInScope'>localsInScope</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveAssign'>resolveAssign</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveBinaryOperator'>resolveBinaryOperator</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveBreak'>resolveBreak</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveCall'>resolveCall</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveCallOnLocalVar'>resolveCallOnLocalVar</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveClosure'>resolveClosure</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveConstruction'>resolveConstruction</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveContinue'>resolveContinue</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveDsl'>resolveDsl</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveElvis'>resolveElvis</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveExpr'>resolveExpr</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveExprStmt'>resolveExprStmt</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveFor'>resolveFor</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveIndexedAssign'>resolveIndexedAssign</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveIt'>resolveIt</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveList'>resolveList</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveLocal'>resolveLocal</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveLocalVarDef'>resolveLocalVarDef</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveLocaleLiteral'>resolveLocaleLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveMap'>resolveMap</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveShortcut'>resolveShortcut</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveSlotLiteral'>resolveSlotLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveStorage'>resolveStorage</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveSuper'>resolveSuper</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveTernary'>resolveTernary</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveThis'>resolveThis</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveVar'>resolveVar</a></li>
  <li style='display: block;'><a href='#run'>run</a></li>
  <li style='display: block;'><a href='#stmtStack'>stmtStack</a></li>
  <li style='display: block;'><a href='#visitExpr'>visitExpr</a></li>
  <li style='display: block;'><a href='#visitStmt'>visitStmt</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::CheckErrors</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='CheckErrors.html'>CheckErrors</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::CheckErrors</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    <a href='CompilerStep.html'>compiler::CompilerStep</a>
      compiler::CheckErrors</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//    2 Dec 05  Brian Frank  Creation</span>
<span class='y'>//   17 Sep 06  Brian Frank  Ported from Java to Fan</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** CheckErrors walks the tree of statements and expressions looking</span>
<span class='z'>** for errors the compiler can detect such as invalid type usage.  We</span>
<span class='z'>** attempt to leave all the error reporting to this step, so that we</span>
<span class='z'>** can batch report as many errors as possible.</span>
<span class='z'>**</span>
<span class='z'>** Since CheckErrors already performs a full tree walk down to each leaf</span>
<span class='z'>** expression, we also do a couple of other AST decorations in this step:</span>
<span class='z'>**   1) add temp local for field assignments like return ++x</span>
<span class='z'>**   2) add temp local for returns inside protected region</span>
<span class='z'>**   3) check for field accessor optimization</span>
<span class='z'>**   4) check for field storage requirements</span>
<span class='z'>**   5) add implicit coersions: auto-casts, boxing, to non-nullable</span>
<span class='z'>**   6) implicit call to toImmutable when assigning to const field</span>
<span class='z'>**   7) mark ClosureExpr.setsConst</span>
<span class='z'>**</span>
<span class='k'>class</span> CheckErrors : CompilerStep
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.isSys = compiler.isSys
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Run</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='run'>run</span><span class='b'>()</span>
  <span class='b'>{</span>
    log.debug<span class='b'>(</span><span class='s'>"CheckErrors"</span><span class='b'>)</span>
    checkPodDef<span class='b'>(</span>pod<span class='b'>)</span>
    walk<span class='b'>(</span>compiler, VisitDepth.expr<span class='b'>)</span>
    bombIfErr
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// PodDef</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  Void <span id='checkPodDef'>checkPodDef</span><span class='b'>(</span>PodDef pod<span class='b'>)</span>
  <span class='b'>{</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// TypeDef</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='visitTypeDef'>visitTypeDef</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check type flags</span>
    checkTypeFlags<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// facets</span>
    checkFacets<span class='b'>(</span>t.facets<span class='b'>)</span>

    <span class='y'>// check for abstract slots in concrete class</span>
    checkAbstractSlots<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// check for const slots in const class</span>
    checkConstType<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// verify we don't use a restricted name</span>
    <span class='k'>if</span> <span class='b'>(</span>isRestrictedName<span class='b'>(</span>t.name<span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Type name '$t.name' is restricted"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// verify type name doesn't conflict with resource name</span>
    checkResConflicts<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// if type extends from any FFI types then give bridge a hook</span>
    foreign := t.foreignInheritance
    <span class='k'>if</span> <span class='b'>(</span>foreign != <span class='k'>null</span><span class='b'>)</span> foreign.bridge.checkType<span class='b'>(</span>t<span class='b'>)</span>

    <span class='y'>// check some knuckle head doesn't override type</span>
    <span class='k'>if</span> <span class='b'>(</span>t.slotDef<span class='b'>(</span><span class='s'>"typeof"</span><span class='b'>)</span> != <span class='k'>null</span> &amp;&amp; !isSys<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot override Obj.typeof()"</span>, t.slotDef<span class='b'>(</span><span class='s'>"typeof"</span><span class='b'>)</span>.loc<span class='b'>)</span>

    <span class='y'>// check inheritance</span>
    <span class='k'>if</span> <span class='b'>(</span>t.base != <span class='k'>null</span><span class='b'>)</span> checkBase<span class='b'>(</span>t, t.base<span class='b'>)</span>
    t.mixins.each |CType m| <span class='b'>{</span> checkMixin<span class='b'>(</span>t, m<span class='b'>)</span> <span class='b'>}</span>

    <span class='y'>// check definite assignment of static fields</span>
    checkDefiniteAssign<span class='b'>(</span>t.staticInit<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>static</span> Bool <span id='isRestrictedName'>isRestrictedName</span><span class='b'>(</span>Str name<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// disallow types to conflict with docs URI</span>
    <span class='k'>return</span> name == <span class='s'>"pod"</span> || name == <span class='s'>"index"</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkResConflicts'>checkResConflicts</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    compiler.input.resFiles?.each |uri|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>uri.path.first == t.name<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Resource `$uri` conflicts with type name '$t.name'"</span>, t.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTypeFlags'>checkTypeFlags</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    flags := t.flags
    loc := t.loc

    <span class='y'>// these modifiers are never allowed on a type</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Ctor<span class='b'>)</span> != 0<span class='b'>)</span>      err<span class='b'>(</span><span class='s'>"Cannot use 'new' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span>      err<span class='b'>(</span><span class='s'>"Cannot use 'once' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Override<span class='b'>)</span> != 0<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Cannot use 'override' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Private<span class='b'>)</span> != 0<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Cannot use 'private' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Protected<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Cannot use 'protected' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Cannot use 'static' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Virtual<span class='b'>)</span> != 0<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Cannot use 'virtual' modifier on type"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Readonly<span class='b'>)</span> != 0<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Cannot use 'readonly' modifier on type"</span>, loc<span class='b'>)</span>

    <span class='y'>// check invalid protection combinations</span>
    checkProtectionFlags<span class='b'>(</span>flags, loc<span class='b'>)</span>

    <span class='y'>// check abstract and final</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0 &amp;&amp; flags.and<span class='b'>(</span>FConst.Final<span class='b'>)</span> != 0<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Invalid combination of 'abstract' and 'final' modifiers"</span>, loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkAbstractSlots'>checkAbstractSlots</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if already abstract, nothing to check</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isAbstract<span class='b'>)</span> <span class='k'>return</span>

    errForDef := <span class='k'>false</span>
    closure := |CSlot slot|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!slot.isAbstract<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>if</span> <span class='b'>(</span>slot.parent === t<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>!errForDef<span class='b'>)</span>
        <span class='b'>{</span>
          err<span class='b'>(</span><span class='s'>"Class '$t.name' must be abstract since it contains abstract slots"</span>, t.loc<span class='b'>)</span>
          errForDef = <span class='k'>true</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Class '$t.name' must be abstract since it inherits but doesn't override '$slot.qname'"</span>, t.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='k'>if</span> <span class='b'>(</span>compiler.input.isTest<span class='b'>)</span>
      t.slots.vals.sort.each<span class='b'>(</span>closure<span class='b'>)</span>
    <span class='k'>else</span>
      t.slots.each<span class='b'>(</span>closure<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkConstType'>checkConstType</span><span class='b'>(</span>TypeDef t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if not const then nothing to check</span>
    <span class='k'>if</span> <span class='b'>(</span>!t.isConst<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// const class cannot inherit from non-const class</span>
    <span class='k'>if</span> <span class='b'>(</span>t.base != <span class='k'>null</span> &amp;&amp; t.base != ns.objType &amp;&amp; !t.base.isConst<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Const type '$t.name' cannot subclass non-const class '$t.base.name'"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// check that each field is const or has no storage; don't</span>
    <span class='y'>// worry about statics because they are forced to be const</span>
    <span class='y'>// in another check</span>
    t.fieldDefs.each |FieldDef f|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!f.isConst &amp;&amp; !f.isStatic &amp;&amp; f.isStorage &amp;&amp; !isSys<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Const type '$t.name' cannot contain non-const field '$f.name'"</span>, f.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check that no once methods</span>
    t.methodDefs.each |MethodDef m|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>m.isOnce<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Const type '$t.name' cannot contain once method '$m.name'"</span>, m.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkBase'>checkBase</span><span class='b'>(</span>TypeDef t, CType base<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that a public class doesn't subclass from internal classes</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isPublic &amp;&amp; !base.isPublic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Public type '$t.name' cannot extend from internal class '$base.name'"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// if base is const, then t must be const</span>
    <span class='k'>if</span> <span class='b'>(</span>!t.isConst &amp;&amp; base.isConst<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Non-const type '$t.name' cannot subclass const class '$base.name'"</span>, t.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMixin'>checkMixin</span><span class='b'>(</span>TypeDef t, CType m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that a public class doesn't implement from internal mixin</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isPublic &amp;&amp; !m.isPublic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Public type '$t.name' cannot implement internal mixin '$m.name'"</span>, t.loc<span class='b'>)</span>

    <span class='y'>// if mixin is const, then t must be const</span>
    <span class='k'>if</span> <span class='b'>(</span>!t.isConst &amp;&amp; m.isConst<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Non-const type '$t.name' cannot implement const mixin '$m.name'"</span>, t.loc<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// FieldDef</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='visitFieldDef'>visitFieldDef</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if this field overrides a concrete field,</span>
    <span class='y'>// then it never gets its own storage</span>
    <span class='k'>if</span> <span class='b'>(</span>f.concreteBase != <span class='k'>null</span><span class='b'>)</span>
      f.flags = f.flags.and<span class='b'>(</span>FConst.Storage.not<span class='b'>)</span>

    <span class='y'>// check for invalid flags</span>
    checkFieldFlags<span class='b'>(</span>f<span class='b'>)</span>

    <span class='y'>// facets</span>
    checkFacets<span class='b'>(</span>f.facets<span class='b'>)</span>

    <span class='y'>// mixins cannot have non-abstract fields</span>
    <span class='k'>if</span> <span class='b'>(</span>curType.isMixin &amp;&amp; !f.isAbstract &amp;&amp; !f.isStatic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Mixin field '$f.name' must be abstract"</span>, f.loc<span class='b'>)</span>

    <span class='y'>// abstract field cannot have initialization</span>
    <span class='k'>if</span> <span class='b'>(</span>f.isAbstract &amp;&amp; f.init != <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Abstract field '$f.name' cannot have initializer"</span>, f.init.loc<span class='b'>)</span>

    <span class='y'>// abstract field cannot have getter/setter</span>
    <span class='k'>if</span> <span class='b'>(</span>f.isAbstract &amp;&amp; <span class='b'>(</span>f.hasGet || f.hasSet<span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Abstract field '$f.name' cannot have getter or setter"</span>, f.loc<span class='b'>)</span>

    <span class='y'>// check internal type</span>
    checkTypeProtection<span class='b'>(</span>f.fieldType, f.loc<span class='b'>)</span>

    <span class='y'>// check that public field isn't using internal type</span>
    <span class='k'>if</span> <span class='b'>(</span>curType.isPublic &amp;&amp; <span class='b'>(</span>f.isPublic || f.isProtected<span class='b'>)</span> &amp;&amp; !f.fieldType.isPublic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Public field '${curType.name}.${f.name}' cannot use internal type '$f.fieldType'"</span>, f.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkFieldFlags'>checkFieldFlags</span><span class='b'>(</span>FieldDef f<span class='b'>)</span>
  <span class='b'>{</span>
    flags := f.flags
    loc   := f.loc

    <span class='y'>// these modifiers are never allowed on a field</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Ctor<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Cannot use 'new' modifier on field"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Final<span class='b'>)</span> != 0<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Cannot use 'final' modifier on field"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Cannot use 'once' modifier on field"</span>, loc<span class='b'>)</span>

    <span class='y'>// check invalid protection combinations</span>
    checkProtectionFlags<span class='b'>(</span>flags, loc<span class='b'>)</span>

    <span class='y'>// if native</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Native<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Const<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'native' and 'const' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'native' and 'abstract' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'native' and 'static' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if const</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Const<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// invalid const flag combo</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'const' and 'abstract' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Virtual<span class='b'>)</span> != 0 &amp;&amp; flags.and<span class='b'>(</span>FConst.Override<span class='b'>)</span> == 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'const' and 'virtual' modifiers"</span>, loc<span class='b'>)</span>

      <span class='y'>// invalid type</span>
      <span class='k'>if</span> <span class='b'>(</span>!f.fieldType.isConstFieldType<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Const field '$f.name' has non-const type '$f.fieldType'"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// static fields must be const</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Static field '$f.name' must be const"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check invalid protection combinations on setter (getter</span>
    <span class='y'>// can no modifiers which is checked in the parser)</span>
    <span class='k'>if</span> <span class='b'>(</span>f.setter != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      fieldProtection  := flags.and<span class='b'>(</span>Parser.ProtectionMask.not<span class='b'>)</span>
      setterProtection := f.set.flags.and<span class='b'>(</span>Parser.ProtectionMask.not<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>fieldProtection != setterProtection<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='y'>// verify protection flag combinations</span>
        checkProtectionFlags<span class='b'>(</span>f.set.flags, loc<span class='b'>)</span>

        <span class='y'>// verify that setter has narrowed protection</span>
        <span class='k'>if</span> <span class='b'>(</span>fieldProtection.and<span class='b'>(</span>FConst.Private<span class='b'>)</span> != 0<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Public<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Protected<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Internal<span class='b'>)</span> != 0<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
        <span class='b'>}</span>
        <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>fieldProtection.and<span class='b'>(</span>FConst.Internal<span class='b'>)</span> != 0<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Public<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Protected<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
        <span class='b'>}</span>
        <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>fieldProtection.and<span class='b'>(</span>FConst.Protected<span class='b'>)</span> != 0<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>setterProtection.and<span class='b'>(</span>FConst.Public<span class='b'>)</span> != 0<span class='b'>)</span>    err<span class='b'>(</span><span class='s'>"Setter cannot have wider visibility than the field"</span>, loc<span class='b'>)</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// MethodDef</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='visitMethodDef'>visitMethodDef</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check invalid use of flags</span>
    checkMethodFlags<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// facets</span>
    checkFacets<span class='b'>(</span>m.facets<span class='b'>)</span>

    <span class='y'>// check parameters</span>
    checkParams<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// check return</span>
    checkMethodReturn<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// check ctors call super (or another this) ctor</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isCtor<span class='b'>)</span> checkCtor<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// if method has operator facet, check it</span>
    <span class='k'>if</span> <span class='b'>(</span>m.hasFacet<span class='b'>(</span><span class='s'>"sys::Operator"</span><span class='b'>))</span> checkOperatorMethod<span class='b'>(</span>m<span class='b'>)</span>

    <span class='y'>// check types used in signature</span>
    <span class='k'>if</span> <span class='b'>(</span>!m.isAccessor<span class='b'>)</span>
    <span class='b'>{</span>
      checkTypeProtection<span class='b'>(</span>m.returnType, m.loc<span class='b'>)</span>
      m.paramDefs.each |ParamDef p| <span class='b'>{</span> checkTypeProtection<span class='b'>(</span>p.paramType, p.loc<span class='b'>)</span> <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// check that public method isn't using internal types in its signature</span>
    <span class='k'>if</span> <span class='b'>(</span>!m.isAccessor &amp;&amp; curType.isPublic &amp;&amp; <span class='b'>(</span>m.isPublic || m.isProtected<span class='b'>))</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!m.returnType.isPublic<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Public method '${curType.name}.${m.name}' cannot use internal type '$m.returnType'"</span>, m.loc<span class='b'>)</span>;
      m.paramDefs.each |ParamDef p|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>!p.paramType.isPublic<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Public method '${curType.name}.${m.name}' cannot use internal type '$p.paramType'"</span>, m.loc<span class='b'>)</span>;
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMethodFlags'>checkMethodFlags</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check field accessors in checkFieldFlags</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isFieldAccessor<span class='b'>)</span> <span class='k'>return</span>

    flags := m.flags
    loc := m.loc

    <span class='y'>// these modifiers are never allowed on a method</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Final<span class='b'>)</span> != 0<span class='b'>)</span>     err<span class='b'>(</span><span class='s'>"Cannot use 'final' modifier on method"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Const<span class='b'>)</span> != 0<span class='b'>)</span>     err<span class='b'>(</span><span class='s'>"Cannot use 'const' modifier on method"</span>, loc<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Readonly<span class='b'>)</span> != 0<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Cannot use 'readonly' modifier on method"</span>, loc<span class='b'>)</span>

    <span class='y'>// check invalid protection combinations</span>
    checkProtectionFlags<span class='b'>(</span>flags, loc<span class='b'>)</span>

    <span class='y'>// check invalid constructor flags</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Ctor<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'abstract' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Override<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'override' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Virtual<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'virtual' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span>     err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'once' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Native<span class='b'>)</span> != 0<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'native' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Invalid combination of 'new' and 'static' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check invalid static flags</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'static' and 'abstract' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Override<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'static' and 'override' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Virtual<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'static' and 'virtual' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'static' and 'once' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check invalid abstract flags</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>FConst.Native<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'abstract' and 'native' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'abstract' and 'once' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// mixins cannot have once methods</span>
    <span class='k'>if</span> <span class='b'>(</span>flags.and<span class='b'>(</span>Parser.Once<span class='b'>)</span> != 0<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>curType.isMixin<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Mixins cannot have once methods"</span>, m.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// normalize method flags after checking</span>
    <span class='k'>if</span> <span class='b'>(</span>m.flags.and<span class='b'>(</span>FConst.Static<span class='b'>)</span> != 0<span class='b'>)</span>
      m.flags = flags.or<span class='b'>(</span>FConst.Const<span class='b'>)</span>;
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkParams'>checkParams</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that defs are contiguous after first one</span>
    seenDef := <span class='k'>false</span>
    m.paramDefs.each |ParamDef p|
    <span class='b'>{</span>
      checkParam<span class='b'>(</span>p<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>seenDef<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>p.def == <span class='k'>null</span><span class='b'>)</span>
          err<span class='b'>(</span><span class='s'>"Parameter '$p.name' must have default"</span>, p.loc<span class='b'>)</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        seenDef = p.def != <span class='k'>null</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkParam'>checkParam</span><span class='b'>(</span>ParamDef p<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check type</span>
    t := p.paramType
    <span class='k'>if</span> <span class='b'>(</span>t.isVoid<span class='b'>)</span> <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use Void as parameter type"</span>, p.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isThis<span class='b'>)</span>  <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use This as parameter type"</span>, p.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>t.toNonNullable.signature != <span class='s'>"|sys::This-&gt;sys::Void|"</span><span class='b'>)</span> checkValidType<span class='b'>(</span>p.loc, t<span class='b'>)</span>

    <span class='y'>// check parameter default type</span>
    <span class='k'>if</span> <span class='b'>(</span>p.def != <span class='k'>null</span> &amp;&amp; !p.paramType.isGenericParameter<span class='b'>)</span>
    <span class='b'>{</span>
      p.def = coerce<span class='b'>(</span>p.def, p.paramType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"'$p.def.toTypeStr' is not assignable to '$p.paramType'"</span>, p.def.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMethodReturn'>checkMethodReturn</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>m.ret.isThis<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>m.isStatic<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot return This from static method"</span>, m.loc<span class='b'>)</span>

      <span class='k'>if</span> <span class='b'>(</span>m.ret.isNullable<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"This type cannot be nullable"</span>, m.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='k'>if</span> <span class='b'>(</span>!m.ret.isThis &amp;&amp; !m.ret.isVoid<span class='b'>)</span>
      checkValidType<span class='b'>(</span>m.loc, m.ret<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkCtor'>checkCtor</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// mixins cannot have constructors</span>
    <span class='k'>if</span> <span class='b'>(</span>curType.isMixin<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Mixins cannot have constructors"</span>, m.loc<span class='b'>)</span>

    <span class='y'>// ensure super/this constructor is called</span>
    <span class='k'>if</span> <span class='b'>(</span>m.ctorChain == <span class='k'>null</span> &amp;&amp; !compiler.isSys &amp;&amp; !curType.base.isObj &amp;&amp; !curType.isSynthetic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Must call super class constructor in '$m.name'"</span>, m.loc<span class='b'>)</span>

    <span class='y'>// if this constructor doesn't call a this</span>
    <span class='y'>// constructor, then check for definite assignment</span>
    <span class='k'>if</span> <span class='b'>(</span>m.ctorChain?.target?.id !== ExprId.thisExpr<span class='b'>)</span>
      checkDefiniteAssign<span class='b'>(</span>m<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkDefiniteAssign'>checkDefiniteAssign</span><span class='b'>(</span>MethodDef? m<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>isSys<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// get fields which:</span>
    <span class='y'>//   - instance or static fields based on ctor or static {}</span>
    <span class='y'>//   - aren't abstract, override, or native</span>
    <span class='y'>//   - not a calculated field (has storage)</span>
    <span class='y'>//   - have a non-nullable, non-value type</span>
    <span class='y'>//   - don't have have an init expression</span>
    isStaticInit  := m == <span class='k'>null</span> || m.isStatic
    fields := curType.fieldDefs.findAll |FieldDef f-&gt;Bool|
    <span class='b'>{</span>
      f.isStatic == isStaticInit &amp;&amp;
      !f.isAbstract &amp;&amp; !f.isOverride &amp;&amp; !f.isNative &amp;&amp; f.isStorage &amp;&amp;
      !f.fieldType.isNullable &amp;&amp; !f.fieldType.isVal &amp;&amp; f.init == <span class='k'>null</span>
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>fields.isEmpty<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// check that each one is definitely assigned</span>
    fields.each |FieldDef f|
    <span class='b'>{</span>
      definite := m != <span class='k'>null</span> &amp;&amp; m.code.isDefiniteAssign |Expr lhs-&gt;Bool|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>lhs.id !== ExprId.field<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
        fe := <span class='b'>(</span>FieldExpr<span class='b'>)</span>lhs
        <span class='k'>if</span> <span class='b'>(</span>!isStaticInit &amp;&amp; fe.target?.id !== ExprId.thisExpr<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
        <span class='k'>return</span> fe.field.qname == f.qname
      <span class='b'>}</span>
      <span class='k'>if</span> <span class='b'>(</span>definite<span class='b'>)</span> <span class='k'>return</span>

      <span class='y'>// if we didn't have a definite assignment on an it-block</span>
      <span class='y'>// constructor that is ok, we just mark the field as requiring</span>
      <span class='y'>// a runtime check in ConstChecks step</span>
      <span class='k'>if</span> <span class='b'>(</span>m != <span class='k'>null</span> &amp;&amp; m.isItBlockCtor<span class='b'>)</span> <span class='b'>{</span> f.requiresNullCheck = <span class='k'>true</span>; <span class='k'>return</span> <span class='b'>}</span>

      <span class='y'>// report error</span>
      <span class='k'>if</span> <span class='b'>(</span>isStaticInit<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Non-nullable field '$f.name' must be assigned in static initializer"</span>, f.loc<span class='b'>)</span>
      <span class='k'>else</span>
        err<span class='b'>(</span><span class='s'>"Non-nullable field '$f.name' must be assigned in constructor '$m.name'"</span>, m.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkOperatorMethod'>checkOperatorMethod</span><span class='b'>(</span>MethodDef m<span class='b'>)</span>
  <span class='b'>{</span>
    prefix := COperators.toPrefix<span class='b'>(</span>m.name<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>prefix == <span class='k'>null</span><span class='b'>)</span> <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Operator method '$m.name' has invalid name"</span>, m.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    op := ShortcutOp.fromPrefix<span class='b'>(</span>prefix<span class='b'>)</span>

    <span class='k'>if</span> <span class='b'>(</span>m.returnType.isVoid &amp;&amp; op !== ShortcutOp.set<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Operator method '$m.name' cannot return Void"</span>, m.loc<span class='b'>)</span>

    <span class='k'>if</span> <span class='b'>(</span>m.params.size+1 != op.degree &amp;&amp; !<span class='b'>(</span>m.params.getSafe<span class='b'>(</span>op.degree-1<span class='b'>)</span>?.hasDefault ?: <span class='k'>false</span><span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Operator method '$m.name' has wrong number of parameters"</span>, m.loc<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Facets</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  Void <span id='checkFacets'>checkFacets</span><span class='b'>(</span>FacetDef<span class='b'>[]</span>? facets<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>facets == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// check each facet (and for dups)</span>
    <span class='k'>for</span> <span class='b'>(</span>i := 0; i &lt; facets.size; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      f := facets<span class='b'>[</span>i<span class='b'>]</span>
      checkFacet<span class='b'>(</span>f<span class='b'>)</span>
      <span class='k'>for</span> <span class='b'>(</span>j := i+1; j &lt; facets.size; ++j<span class='b'>)</span>
        <span class='k'>if</span> <span class='b'>(</span>f.type.qname == facets<span class='b'>[</span>j<span class='b'>]</span>.type.qname<span class='b'>)</span>
          err<span class='b'>(</span><span class='s'>"Duplicate facet '$f.type'"</span>, f.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  Void <span id='checkFacet'>checkFacet</span><span class='b'>(</span>FacetDef f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that facet type is actually a facet</span>
    <span class='k'>if</span> <span class='b'>(</span>!f.type.fits<span class='b'>(</span>ns.facetType<span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Not a facet type '$f.type'"</span>, f.loc<span class='b'>)</span>

    <span class='y'>// check facet field assignments</span>
    f.names.each |name, i|
    <span class='b'>{</span>
      val := f.vals<span class='b'>[</span>i<span class='b'>]</span>

      <span class='y'>// check that field exists</span>
      field := f.type.field<span class='b'>(</span>name<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>field == <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Unknown facet field '${f.type}.$name'"</span>, val.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>

      <span class='y'>// check field type</span>
      <span class='k'>if</span> <span class='b'>(</span>!val.ctype.fits<span class='b'>(</span>field.fieldType.inferredAs<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Invalid type for facet field '$name': expected '$field.fieldType' not '$val.ctype'"</span>, val.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Statements</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Void <span id='enterStmt'>enterStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.id == StmtId.tryStmt<span class='b'>)</span> protectedRegionDepth++
  <span class='b'>}</span>

  <span class='k'>override</span> Void <span id='exitStmt'>exitStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.id == StmtId.tryStmt<span class='b'>)</span> protectedRegionDepth--
  <span class='b'>}</span>

  <span class='k'>override</span> Void <span id='enterFinally'>enterFinally</span><span class='b'>(</span>TryStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    finallyDepth++
  <span class='b'>}</span>

  <span class='k'>override</span> Void <span id='exitFinally'>exitFinally</span><span class='b'>(</span>TryStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    finallyDepth--
  <span class='b'>}</span>

  <span class='k'>override</span> Stmt<span class='b'>[]</span>? <span id='visitStmt'>visitStmt</span><span class='b'>(</span>Stmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>stmt.id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> StmtId.expr:          checkExprStmt<span class='b'>((</span>ExprStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.localDef:      checkLocalDef<span class='b'>((</span>LocalDefStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.ifStmt:        checkIf<span class='b'>((</span>IfStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.returnStmt:    checkReturn<span class='b'>((</span>ReturnStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.throwStmt:     checkThrow<span class='b'>((</span>ThrowStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.forStmt:       checkFor<span class='b'>((</span>ForStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.whileStmt:     checkWhile<span class='b'>((</span>WhileStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.breakStmt:     checkBreak<span class='b'>((</span>BreakStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.continueStmt:  checkContinue<span class='b'>((</span>ContinueStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.tryStmt:       checkTry<span class='b'>((</span>TryStmt<span class='b'>)</span>stmt<span class='b'>)</span>
      <span class='k'>case</span> StmtId.switchStmt:    checkSwitch<span class='b'>((</span>SwitchStmt<span class='b'>)</span>stmt<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkExprStmt'>checkExprStmt</span><span class='b'>(</span>ExprStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!stmt.expr.isStmt<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Not a statement"</span>, stmt.expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkLocalDef'>checkLocalDef</span><span class='b'>(</span>LocalDefStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check not Void</span>
    t := stmt.ctype
    <span class='k'>if</span> <span class='b'>(</span>t.isVoid<span class='b'>)</span> <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use Void as local variable type"</span>, stmt.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isThis<span class='b'>)</span> <span class='b'>{</span> err<span class='b'>(</span><span class='s'>"Cannot use This as local variable type"</span>, stmt.loc<span class='b'>)</span>; <span class='k'>return</span> <span class='b'>}</span>
    checkValidType<span class='b'>(</span>stmt.loc, t<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkIf'>checkIf</span><span class='b'>(</span>IfStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    stmt.condition = coerce<span class='b'>(</span>stmt.condition, ns.boolType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"If condition must be Bool, not '$stmt.condition.ctype'"</span>, stmt.condition.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkThrow'>checkThrow</span><span class='b'>(</span>ThrowStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    stmt.exception = coerce<span class='b'>(</span>stmt.exception, ns.errType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Must throw Err, not '$stmt.exception.ctype'"</span>, stmt.exception.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkFor'>checkFor</span><span class='b'>(</span>ForStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.condition != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      stmt.condition = coerce<span class='b'>(</span>stmt.condition, ns.boolType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"For condition must be Bool, not '$stmt.condition.ctype'"</span>, stmt.condition.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkWhile'>checkWhile</span><span class='b'>(</span>WhileStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    stmt.condition = coerce<span class='b'>(</span>stmt.condition, ns.boolType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"While condition must be Bool, not '$stmt.condition.ctype'"</span>, stmt.condition.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkBreak'>checkBreak</span><span class='b'>(</span>BreakStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.loop == <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Break outside of loop (break is implicit in switch)"</span>, stmt.loc<span class='b'>)</span>

    <span class='y'>// can't leave control of a finally block</span>
    <span class='k'>if</span> <span class='b'>(</span>finallyDepth &gt; 0<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot leave finally block"</span>, stmt.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkContinue'>checkContinue</span><span class='b'>(</span>ContinueStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.loop == <span class='k'>null</span><span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Continue outside of loop"</span>, stmt.loc<span class='b'>)</span>

    <span class='y'>// can't leave control of a finally block</span>
    <span class='k'>if</span> <span class='b'>(</span>finallyDepth &gt; 0<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot leave finally block"</span>, stmt.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkReturn'>checkReturn</span><span class='b'>(</span>ReturnStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    ret := curMethod.ret
    <span class='k'>if</span> <span class='b'>(</span>stmt.expr == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// this is just a sanity check - it should be caught in parser</span>
      <span class='k'>if</span> <span class='b'>(</span>!ret.isVoid<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Must return a value from non-Void method"</span>, stmt.loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>ret.isThis<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!stmt.expr.ctype.fits<span class='b'>(</span>curType<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Cannot return '$stmt.expr.toTypeStr' as $curType This"</span>, stmt.expr.loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      stmt.expr = coerce<span class='b'>(</span>stmt.expr, ret<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Cannot return '$stmt.expr.toTypeStr' as '$ret'"</span>, stmt.expr.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// can't use return inside an it-block (might be confusing)</span>
    <span class='k'>if</span> <span class='b'>(</span>!stmt.isSynthetic &amp;&amp; curType.isClosure &amp;&amp; curType.closure.isItBlock<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use return inside it-block"</span>, stmt.loc<span class='b'>)</span>

    <span class='y'>// can't leave control of a finally block</span>
    <span class='k'>if</span> <span class='b'>(</span>finallyDepth &gt; 0<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot leave finally block"</span>, stmt.loc<span class='b'>)</span>

    <span class='y'>// add temp local var if returning from a protected region,</span>
    <span class='y'>// we always call this variable "$return" and reuse it if</span>
    <span class='y'>// already declared by a previous return</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.expr != <span class='k'>null</span> &amp;&amp; protectedRegionDepth &gt; 0<span class='b'>)</span>
    <span class='b'>{</span>
      v := curMethod.vars.find |MethodVar v-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> v.name == <span class='s'>"\$return"</span> <span class='b'>}</span>
      <span class='k'>if</span> <span class='b'>(</span>v == <span class='k'>null</span><span class='b'>)</span> v = curMethod.addLocalVar<span class='b'>(</span>stmt.expr.ctype, <span class='s'>"\$return"</span>, <span class='k'>null</span><span class='b'>)</span>
      stmt.leaveVar = v
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTry'>checkTry</span><span class='b'>(</span>TryStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that try block not empty</span>
    <span class='k'>if</span> <span class='b'>(</span>stmt.block.isEmpty<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Try block cannot be empty"</span>, stmt.loc<span class='b'>)</span>

    <span class='y'>// check each catch</span>
    caught := CType<span class='b'>[</span>,<span class='b'>]</span>
    stmt.catches.each |Catch c|
    <span class='b'>{</span>
      CType? errType := c.errType
      <span class='k'>if</span> <span class='b'>(</span>errType == <span class='k'>null</span><span class='b'>)</span> errType = ns.errType
      <span class='k'>if</span> <span class='b'>(</span>!errType.fits<span class='b'>(</span>ns.errType<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Must catch Err, not '$c.errType'"</span>, c.errType.loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>errType.fitsAny<span class='b'>(</span>caught<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Already caught '$errType'"</span>, c.loc<span class='b'>)</span>
      caught.add<span class='b'>(</span>errType<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkSwitch'>checkSwitch</span><span class='b'>(</span>SwitchStmt stmt<span class='b'>)</span>
  <span class='b'>{</span>
    dups := Int:Int<span class='b'>[</span>:<span class='b'>]</span>

    stmt.cases.each |Case c|
    <span class='b'>{</span>
      <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;c.cases.size; ++i<span class='b'>)</span>
      <span class='b'>{</span>
        expr := c.cases<span class='b'>[</span>i<span class='b'>]</span>

        <span class='y'>// check comparability of condition and each case</span>
        checkCompare<span class='b'>(</span>expr, stmt.condition<span class='b'>)</span>

        <span class='y'>// check for dups</span>
        literal := expr.asTableSwitchCase
        <span class='k'>if</span> <span class='b'>(</span>literal != <span class='k'>null</span><span class='b'>)</span>
        <span class='b'>{</span>
          <span class='k'>if</span> <span class='b'>(</span>dups<span class='b'>[</span>literal<span class='b'>]</span> == <span class='k'>null</span><span class='b'>)</span>
            dups<span class='b'>[</span>literal<span class='b'>]</span> = literal
          <span class='k'>else</span>
            err<span class='b'>(</span><span class='s'>"Duplicate case label"</span>, expr.loc<span class='b'>)</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Expr</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>override</span> Expr <span id='visitExpr'>visitExpr</span><span class='b'>(</span>Expr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>expr.id<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> ExprId.typeLiteral:    checkTypeLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.slotLiteral:    checkSlotLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.listLiteral:    checkListLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.mapLiteral:     checkMapLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.rangeLiteral:   checkRangeLiteral<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.boolNot:        checkBool<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.cmpNull:
      <span class='k'>case</span> ExprId.cmpNotNull:     checkCompareNull<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.assign:         checkAssign<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.elvis:          checkElvis<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.boolOr:
      <span class='k'>case</span> ExprId.boolAnd:        checkBools<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.same:
      <span class='k'>case</span> ExprId.notSame:        checkSame<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.shortcut:       checkShortcut<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.call:           checkCall<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.construction:   checkConstruction<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.field:          checkField<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.thisExpr:       checkThis<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.superExpr:      checkSuper<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.isExpr:
      <span class='k'>case</span> ExprId.isnotExpr:
      <span class='k'>case</span> ExprId.asExpr:
      <span class='k'>case</span> ExprId.coerce:         checkTypeCheck<span class='b'>(</span>expr<span class='b'>)</span>
      <span class='k'>case</span> ExprId.ternary:        checkTernary<span class='b'>(</span>expr<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTypeLiteral'>checkTypeLiteral</span><span class='b'>(</span>LiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    checkTypeProtection<span class='b'>((</span>CType<span class='b'>)</span>expr.val, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkSlotLiteral'>checkSlotLiteral</span><span class='b'>(</span>SlotLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    checkSlotProtection<span class='b'>(</span>expr.slot, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkListLiteral'>checkListLiteral</span><span class='b'>(</span>ListLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check the types and ensure that everything gets boxed</span>
    listType := <span class='b'>(</span>ListType<span class='b'>)</span>expr.ctype
    valType := listType.v
    expr.vals.each |Expr val, Int i|
    <span class='b'>{</span>
      expr.vals<span class='b'>[</span>i<span class='b'>]</span> = coerceBoxed<span class='b'>(</span>val, valType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Invalid value type '$val.toTypeStr' for list of '$valType'"</span>, val.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkMapLiteral'>checkMapLiteral</span><span class='b'>(</span>MapLiteralExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check the types and ensure that everything gets boxed</span>
    mapType := <span class='b'>(</span>MapType<span class='b'>)</span>expr.ctype
    keyType := mapType.k
    valType := mapType.v
    expr.keys.each |Expr key, Int i|
    <span class='b'>{</span>
      expr.keys<span class='b'>[</span>i<span class='b'>]</span> = coerceBoxed<span class='b'>(</span>key, keyType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Invalid key type '$key.toTypeStr' for map type '$mapType'"</span>, key.loc<span class='b'>)</span>
      <span class='b'>}</span>

      val := expr.vals<span class='b'>[</span>i<span class='b'>]</span>
      expr.vals<span class='b'>[</span>i<span class='b'>]</span> = coerceBoxed<span class='b'>(</span>val, valType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Invalid value type '$val.toTypeStr' for map type '$mapType'"</span>, val.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkRangeLiteral'>checkRangeLiteral</span><span class='b'>(</span>RangeLiteralExpr range<span class='b'>)</span>
  <span class='b'>{</span>
    range.start = coerce<span class='b'>(</span>range.start, ns.intType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Range must be Int..Int, not '${range.start.ctype}..${range.end.ctype}'"</span>, range.loc<span class='b'>)</span>
    <span class='b'>}</span>
    range.end = coerce<span class='b'>(</span>range.end, ns.intType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Range must be Int..Int, not '${range.start.ctype}..${range.end.ctype}'"</span>, range.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkBool'>checkBool</span><span class='b'>(</span>UnaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    expr.operand = coerce<span class='b'>(</span>expr.operand, ns.boolType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Cannot apply '$expr.opToken.symbol' operator to '$expr.operand.ctype'"</span>, expr.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkCompareNull'>checkCompareNull</span><span class='b'>(</span>UnaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    t := expr.operand.ctype
    <span class='k'>if</span> <span class='b'>(</span>!t.isNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Comparison of non-nullable type '$t' to null"</span>, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkBools'>checkBools</span><span class='b'>(</span>CondExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    expr.operands.each |Expr operand, Int i|
    <span class='b'>{</span>
      expr.operands<span class='b'>[</span>i<span class='b'>]</span> = coerce<span class='b'>(</span>operand, ns.boolType<span class='b'>)</span> |-&gt;|
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Cannot apply '$expr.opToken.symbol' operator to '$operand.ctype'"</span>, operand.loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkSame'>checkSame</span><span class='b'>(</span>BinaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    checkCompare<span class='b'>(</span>expr.lhs, expr.rhs<span class='b'>)</span>

    <span class='y'>// don't allow for value types</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.lhs.ctype.isVal || expr.rhs.ctype.isVal<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use '$expr.opToken.symbol' operator with value types"</span>, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Bool <span id='checkCompare'>checkCompare</span><span class='b'>(</span>Expr lhs, Expr rhs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!lhs.ctype.fits<span class='b'>(</span>rhs.ctype<span class='b'>)</span> &amp;&amp; !rhs.ctype.fits<span class='b'>(</span>lhs.ctype<span class='b'>))</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Incomparable types '$lhs.ctype' and '$rhs.ctype'"</span>, lhs.loc<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkAssign'>checkAssign</span><span class='b'>(</span>BinaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check that rhs is assignable to lhs</span>
    expr.rhs = coerce<span class='b'>(</span>expr.rhs, expr.lhs.ctype<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"'$expr.rhs.toTypeStr' is not assignable to '$expr.lhs.ctype'"</span>, expr.rhs.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// check that lhs is assignable</span>
    <span class='k'>if</span> <span class='b'>(</span>!expr.lhs.isAssignable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Left hand side is not assignable"</span>, expr.lhs.loc<span class='b'>)</span>

    <span class='y'>// check not assigning to same variable</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.lhs.sameVarAs<span class='b'>(</span>expr.rhs<span class='b'>))</span>
      err<span class='b'>(</span><span class='s'>"Self assignment"</span>, expr.lhs.loc<span class='b'>)</span>

    <span class='y'>// check left hand side field (common code with checkShortcut)</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.lhs.id === ExprId.field<span class='b'>)</span>
      expr.rhs = checkAssignField<span class='b'>((</span>FieldExpr<span class='b'>)</span>expr.lhs, expr.rhs<span class='b'>)</span>

    <span class='y'>// check that no safe calls used on entire left hand side</span>
    checkNoNullSafes<span class='b'>(</span>expr.lhs<span class='b'>)</span>

    <span class='y'>// take this opportunity to generate a temp local variable if needed</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.leave &amp;&amp; expr.lhs.assignRequiresTempVar<span class='b'>)</span>
      expr.tempVar = curMethod.addLocalVar<span class='b'>(</span>expr.lhs.ctype, <span class='k'>null</span>, <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkElvis'>checkElvis</span><span class='b'>(</span>BinaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!expr.lhs.ctype.isNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use '?:' operator on non-nullable type '$expr.lhs.ctype'"</span>, expr.loc<span class='b'>)</span>

    expr.rhs = coerce<span class='b'>(</span>expr.rhs, expr.ctype<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Cannot coerce '$expr.rhs.toTypeStr' to '$expr.ctype'"</span>, expr.rhs.loc<span class='b'>)</span>;
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkNoNullSafes'>checkNoNullSafes</span><span class='b'>(</span>Expr? x<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>while</span> <span class='b'>(</span>x <span class='k'>is</span> NameExpr<span class='b'>)</span>
    <span class='b'>{</span>
      ne := <span class='b'>(</span>NameExpr<span class='b'>)</span>x
      <span class='k'>if</span> <span class='b'>(</span>ne.isSafe<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Null-safe operator on left hand side of assignment"</span>, x.loc<span class='b'>)</span>
      x = ne.target
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkShortcut'>checkShortcut</span><span class='b'>(</span>ShortcutExpr shortcut<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>shortcut.opToken<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// comparable</span>
      <span class='k'>case</span> Token.eq: <span class='k'>case</span> Token.notEq:
      <span class='k'>case</span> Token.gt: <span class='k'>case</span> Token.gtEq:
      <span class='k'>case</span> Token.lt: <span class='k'>case</span> Token.ltEq:
      <span class='k'>case</span> Token.cmp:
        <span class='k'>if</span> <span class='b'>(</span>!checkCompare<span class='b'>(</span>shortcut.target, shortcut.args.first<span class='b'>))</span> <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// if assignment</span>
    <span class='k'>if</span> <span class='b'>(</span>shortcut.isAssign<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// check that lhs is assignable</span>
      <span class='k'>if</span> <span class='b'>(</span>!shortcut.target.isAssignable<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Target is not assignable"</span>, shortcut.target.loc<span class='b'>)</span>

      <span class='y'>// check left hand side field (common code with checkAssign)</span>
      <span class='k'>if</span> <span class='b'>(</span>shortcut.target.id === ExprId.field<span class='b'>)</span>
        checkAssignField<span class='b'>((</span>FieldExpr<span class='b'>)</span>shortcut.target, shortcut.args.first<span class='b'>)</span>

      <span class='y'>// check that no safe calls used on entire left hand side</span>
      checkNoNullSafes<span class='b'>(</span>shortcut.target<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// take this oppotunity to generate a temp local variable if needed</span>
    <span class='k'>if</span> <span class='b'>(</span>shortcut.leave &amp;&amp; shortcut.isAssign &amp;&amp; shortcut.target.assignRequiresTempVar<span class='b'>)</span>
      shortcut.tempVar = curMethod.addLocalVar<span class='b'>(</span>shortcut.ctype, <span class='k'>null</span>, <span class='k'>null</span><span class='b'>)</span>

    <span class='y'>// we need two scratch variables to manipulate the stack cause</span>
    <span class='y'>// .NET is lame when it comes to doing anything with the stack</span>
    <span class='y'>//   - scratchA: target collection</span>
    <span class='y'>//   - scratchB: index</span>
    indexedAssign := shortcut <span class='k'>as</span> IndexedAssignExpr
    <span class='k'>if</span> <span class='b'>(</span>indexedAssign != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      target := <span class='b'>(</span>ShortcutExpr<span class='b'>)</span>indexedAssign.target
      indexedAssign.scratchA = curMethod.addLocalVar<span class='b'>(</span>target.target.ctype, <span class='k'>null</span>, <span class='k'>null</span><span class='b'>)</span>
      indexedAssign.scratchB = curMethod.addLocalVar<span class='b'>(</span>target.args<span class='b'>[</span>0<span class='b'>]</span>.ctype, <span class='k'>null</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// perform normal call checking</span>
    <span class='k'>if</span> <span class='b'>(</span>!shortcut.isCompare<span class='b'>)</span>
      checkCall<span class='b'>(</span>shortcut<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>** Check if field is assignable, return new rhs.</span>
  <span class='k'>private</span> Expr? <span id='checkAssignField'>checkAssignField</span><span class='b'>(</span>FieldExpr lhs, Expr? rhs<span class='b'>)</span>
  <span class='b'>{</span>
    field := <span class='b'>((</span>FieldExpr<span class='b'>)</span>lhs<span class='b'>)</span>.field

    <span class='y'>// check protection scope (which might be more narrow than the scope</span>
    <span class='y'>// of the entire field as checked in checkProtection by checkField)</span>
    <span class='k'>if</span> <span class='b'>(</span>field.setter != <span class='k'>null</span> &amp;&amp; slotProtectionErr<span class='b'>(</span>field<span class='b'>)</span> == <span class='k'>null</span><span class='b'>)</span>
      checkSlotProtection<span class='b'>(</span>field.setter, lhs.loc, <span class='k'>true</span><span class='b'>)</span>

    <span class='y'>// if not-const we are done</span>
    <span class='k'>if</span> <span class='b'>(</span>!field.isConst<span class='b'>)</span> <span class='k'>return</span> rhs

    <span class='y'>// for purposes of const field checking, consider closures</span>
    <span class='y'>// inside a constructor or static initializer to be ok</span>
    inType := curType
    inMethod := curMethod
    <span class='k'>if</span> <span class='b'>(</span>inType.isClosure<span class='b'>)</span>
    <span class='b'>{</span>
      curType.closure.setsConst = <span class='k'>true</span>
      inType = inType.closure.enclosingType
      inMethod = <span class='b'>(</span>curType.closure.enclosingSlot <span class='k'>as</span> MethodDef<span class='b'>)</span> ?: curMethod
    <span class='b'>}</span>

    <span class='y'>// check attempt to set static field outside of static initializer</span>
    <span class='k'>if</span> <span class='b'>(</span>field.isStatic &amp;&amp; !inMethod.isStaticInit<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Cannot set const static field '$field.name' outside of static initializer"</span>, lhs.loc<span class='b'>)</span>
      <span class='k'>return</span> rhs
    <span class='b'>}</span>

    <span class='y'>// we allow setting an instance ctor field in an</span>
    <span class='y'>// it-block, otherwise dive in for further checking</span>
    <span class='k'>if</span> <span class='b'>(</span>!<span class='b'>(</span>curType.isClosure &amp;&amp; curType.closure.isItBlock<span class='b'>))</span>
    <span class='b'>{</span>
      <span class='y'>// check attempt to set field outside of owning class or subclass</span>
      <span class='k'>if</span> <span class='b'>(</span>inType != field.parent<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>!inType.fits<span class='b'>(</span>field.parent<span class='b'>)</span> || !inMethod.isCtor<span class='b'>)</span>
        <span class='b'>{</span>
          err<span class='b'>(</span><span class='s'>"Cannot set const field '$field.qname'"</span>, lhs.loc<span class='b'>)</span>
          <span class='k'>return</span> rhs
        <span class='b'>}</span>
      <span class='b'>}</span>

      <span class='y'>// check attempt to set instance field outside of ctor</span>
      <span class='k'>if</span> <span class='b'>(</span>!field.isStatic &amp;&amp; !<span class='b'>(</span>inMethod.isInstanceInit || inMethod.isCtor<span class='b'>))</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Cannot set const field '$field.name' outside of constructor"</span>, lhs.loc<span class='b'>)</span>
        <span class='k'>return</span> rhs
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// any other errors should already be logged at this point (see isConstFieldType)</span>

    <span class='y'>// if non-const make an implicit call toImmutable</span>
    ftype := field.fieldType
    <span class='k'>if</span> <span class='b'>(</span>ftype.isConst<span class='b'>)</span>
      <span class='k'>return</span> rhs
    <span class='k'>else</span>
      <span class='k'>return</span> implicitToImmutable<span class='b'>(</span>ftype, rhs<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Expr <span id='implicitToImmutable'>implicitToImmutable</span><span class='b'>(</span>CType fieldType, Expr rhs<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// leave null literal as is</span>
    <span class='k'>if</span> <span class='b'>(</span>rhs.id == ExprId.nullLiteral<span class='b'>)</span> <span class='k'>return</span> rhs

    <span class='y'>// wrap existing assigned with call toImmutable</span>
    call := CallExpr.makeWithMethod<span class='b'>(</span>rhs.loc, rhs, ns.objToImmutable<span class='b'>)</span> <span class='b'>{</span> isSafe = <span class='k'>true</span> <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>fieldType.toNonNullable.isObj<span class='b'>)</span> <span class='k'>return</span> call
    <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>call, fieldType<span class='b'>)</span>

  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkConstruction'>checkConstruction</span><span class='b'>(</span>CallExpr call<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!call.method.isCtor<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// check that ctor method is the expected type</span>
      <span class='k'>if</span> <span class='b'>(</span>call.ctype.toNonNullable != call.method.returnType.toNonNullable<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Construction method '$call.method.qname' must return '$call.ctype.name'"</span>, call.loc<span class='b'>)</span>

      <span class='y'>// but allow ctor to be typed as nullable</span>
      call.ctype = call.method.returnType
    <span class='b'>}</span>

    checkCall<span class='b'>(</span>call<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkCall'>checkCall</span><span class='b'>(</span>CallExpr call<span class='b'>)</span>
  <span class='b'>{</span>
    m := call.method
    <span class='k'>if</span> <span class='b'>(</span>m == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Something wrong with method call?"</span>, call.loc<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    name := m.name

    <span class='y'>// can't call method on Void</span>
    <span class='k'>if</span> <span class='b'>(</span>call.target != <span class='k'>null</span> &amp;&amp; call.target.ctype.isVoid<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Cannot call method on Void"</span>, call.loc<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// check protection scope</span>
    checkSlotProtection<span class='b'>(</span>call.method, call.loc<span class='b'>)</span>

    <span class='y'>// if a foreign function, then verify we aren't using unsupported types</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isForeign<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// just log one use of unsupported return or param type and return</span>
      <span class='k'>if</span> <span class='b'>(</span>!m.returnType.isSupported<span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Method '$name' uses unsupported type '$m.returnType'"</span>, call.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>
      unsupported := m.params.find |CParam p-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> !p.paramType.isSupported <span class='b'>}</span>
      <span class='k'>if</span> <span class='b'>(</span>unsupported != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Method '$name' uses unsupported type '$unsupported.paramType'"</span>, call.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// arguments</span>
    <span class='k'>if</span> <span class='b'>(</span>!call.isDynamic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// do normal call checking and coercion</span>
      checkArgs<span class='b'>(</span>call<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// if dynamic all ensure all the args are boxed</span>
      call.args.each |Expr arg, Int i| <span class='b'>{</span> call.args<span class='b'>[</span>i<span class='b'>]</span> = box<span class='b'>(</span>call.args<span class='b'>[</span>i<span class='b'>])</span> <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// if constructor</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isCtor &amp;&amp; !call.isCtorChain<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// ensure we aren't calling constructors on an instance</span>
      <span class='k'>if</span> <span class='b'>(</span>call.target != <span class='k'>null</span> &amp;&amp; call.target.id !== ExprId.staticTarget &amp;&amp; !call.target.synthetic<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot call constructor '$name' on instance"</span>, call.loc<span class='b'>)</span>

      <span class='y'>// ensure we aren't calling a constructor on an abstract class</span>
      <span class='k'>if</span> <span class='b'>(</span>m.parent.isAbstract<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Calling constructor on abstract class"</span>, call.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// ensure we aren't calling static methods on an instance</span>
    <span class='k'>if</span> <span class='b'>(</span>m.isStatic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>call.target != <span class='k'>null</span> &amp;&amp; call.target.id !== ExprId.staticTarget<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot call static method '$name' on instance"</span>, call.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// ensure we can't calling an instance method statically</span>
    <span class='k'>if</span> <span class='b'>(</span>!m.isStatic &amp;&amp; !m.isCtor<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>call.target == <span class='k'>null</span> || call.target.id === ExprId.staticTarget<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot call instance method '$name' in static context"</span>, call.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if using super</span>
    <span class='k'>if</span> <span class='b'>(</span>call.target != <span class='k'>null</span> &amp;&amp; call.target.id === ExprId.superExpr<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// check that super is concrete</span>
      <span class='k'>if</span> <span class='b'>(</span>m.isAbstract<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot use super to call abstract method '$m.qname'"</span>, call.target.loc<span class='b'>)</span>

      <span class='y'>// check that calling super with exact param match otherwise stack overflow</span>
      <span class='k'>if</span> <span class='b'>(</span>call.args.size != m.params.size &amp;&amp; m.name == curMethod.name &amp;&amp; !m.isCtor<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Must call super method '$m.qname' with exactly $m.params.size arguments"</span>, call.target.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// don't allow safe calls on non-nullable type</span>
    <span class='k'>if</span> <span class='b'>(</span>call.isSafe &amp;&amp; call.target != <span class='k'>null</span> &amp;&amp; !call.target.ctype.isNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use null-safe call on non-nullable type '$call.target.ctype'"</span>, call.target.loc<span class='b'>)</span>

    <span class='y'>// if calling a method on a value-type, ensure target is</span>
    <span class='y'>// coerced to non-null; we don't do this for comparisons</span>
    <span class='y'>// and safe calls since they are handled specially</span>
    <span class='k'>if</span> <span class='b'>(</span>call.target != <span class='k'>null</span> &amp;&amp; !call.isCompare &amp;&amp; !call.isSafe &amp;&amp; !call.method.isStatic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>call.target.ctype.isVal || call.method.parent.isVal<span class='b'>)</span>
        call.target = coerce<span class='b'>(</span>call.target, call.method.parent<span class='b'>)</span> |-&gt;| <span class='b'>{}</span>
    <span class='b'>}</span>

    <span class='y'>// ensure call operator target() not used on non-function types</span>
    <span class='k'>if</span> <span class='b'>(</span>call.isCallOp &amp;&amp; !call.target.ctype.isFunc<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use () call operator on non-func type '$call.target.ctype'"</span>, call.target.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkField'>checkField</span><span class='b'>(</span>FieldExpr f<span class='b'>)</span>
  <span class='b'>{</span>
    field := f.field

    <span class='y'>// check protection scope</span>
    checkSlotProtection<span class='b'>(</span>field, f.loc<span class='b'>)</span>

    <span class='y'>// if a FFI, then verify we aren't using unsupported types</span>
    <span class='k'>if</span> <span class='b'>(</span>!field.fieldType.isSupported<span class='b'>)</span>
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Field '$field.name' has unsupported type '$field.fieldType'"</span>, f.loc<span class='b'>)</span>
      <span class='k'>return</span>
    <span class='b'>}</span>

    <span class='y'>// ensure we aren't calling static methods on an instance</span>
    <span class='k'>if</span> <span class='b'>(</span>field.isStatic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>f.target != <span class='k'>null</span> &amp;&amp; f.target.id !== ExprId.staticTarget<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot access static field '$f.name' on instance"</span>, f.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if instance field</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>f.target == <span class='k'>null</span> || f.target.id === ExprId.staticTarget<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot access instance field '$f.name' in static context"</span>, f.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if using super check that concrete</span>
    <span class='k'>if</span> <span class='b'>(</span>f.target != <span class='k'>null</span> &amp;&amp; f.target.id === ExprId.superExpr<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>field.isAbstract<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot use super to access abstract field '$field.qname'"</span>, f.target.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// don't allow safe access on non-nullable type</span>
    <span class='k'>if</span> <span class='b'>(</span>f.isSafe &amp;&amp; f.target != <span class='k'>null</span> &amp;&amp; !f.target.ctype.isNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use null-safe access on non-nullable type '$f.target.ctype'"</span>, f.target.loc<span class='b'>)</span>

    <span class='y'>// if using the field's accessor method</span>
    <span class='k'>if</span> <span class='b'>(</span>f.useAccessor<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// check if we can optimize out the accessor (required for constants)</span>
      f.useAccessor = useFieldAccessor<span class='b'>(</span>field<span class='b'>)</span>

      <span class='y'>// check that we aren't using an field accessor inside of itself</span>
      <span class='k'>if</span> <span class='b'>(</span>curMethod != <span class='k'>null</span> &amp;&amp; <span class='b'>(</span>field.getter === curMethod || field.setter === curMethod<span class='b'>)</span> &amp;&amp;
          <span class='b'>(</span>f.target == <span class='k'>null</span> || f.target.id == ExprId.thisExpr<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Cannot use field accessor inside accessor itself - use '&amp;' operator"</span>, f.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// if accessing storage directly</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='y'>// check that the current class gets access to direct</span>
      <span class='y'>// field storage (only defining class gets it); allow closures</span>
      <span class='y'>// same scope priviledges as enclosing class</span>
      enclosing := curType.isClosure ? curType.closure.enclosingType : curType
      <span class='k'>if</span> <span class='b'>(</span>!field.isConst &amp;&amp; field.parent != curType &amp;&amp; field.parent != enclosing<span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Field storage for '$field.qname' not accessible"</span>, f.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>

      <span class='y'>// sanity check that field has storage</span>
      <span class='k'>if</span> <span class='b'>(</span>!field.isStorage<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>field <span class='k'>is</span> FieldDef &amp;&amp; <span class='b'>((</span>FieldDef<span class='b'>)</span>field<span class='b'>)</span>.concreteBase != <span class='k'>null</span><span class='b'>)</span>
          err<span class='b'>(</span><span class='s'>"Field storage of inherited field '${field-&gt;concreteBase-&gt;qname}' not accessible (might try super)"</span>, f.loc<span class='b'>)</span>
        <span class='k'>else</span>
          err<span class='b'>(</span><span class='s'>"Invalid storage access of field '$field.qname' which doesn't have storage"</span>, f.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>

      <span class='y'>// cannot use storage operator in mixin</span>
      <span class='k'>if</span> <span class='b'>(</span>enclosing.isMixin &amp;&amp; !curMethod.isSynthetic<span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Field storage not accessible in mixin '$field.qname'"</span>, f.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Bool <span id='useFieldAccessor'>useFieldAccessor</span><span class='b'>(</span>CField f<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if const field then use field directly</span>
    <span class='k'>if</span> <span class='b'>(</span>f.isConst || f.getter == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// always use accessor if field is imported from another</span>
    <span class='y'>// pod (in which case it isn't a def in my compilation unit)</span>
    def := f <span class='k'>as</span> FieldDef
    <span class='k'>if</span> <span class='b'>(</span>def == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// if virtual/override/native then always use accessor</span>
    <span class='k'>if</span> <span class='b'>(</span>def.isVirtual || def.isOverride || f.isNative<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// if the field has synthetic getter and setter, then</span>
    <span class='y'>// we can safely optimize internal field accessors to</span>
    <span class='y'>// use field directly</span>
    <span class='k'>if</span> <span class='b'>(</span>!def.hasGet &amp;&amp; !def.hasSet<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// use accessor since there is a custom getter or setter</span>
    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkThis'>checkThis</span><span class='b'>(</span>ThisExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>inStatic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot access 'this' in static context"</span>, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkSuper'>checkSuper</span><span class='b'>(</span>SuperExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>inStatic<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot access 'super' in static context"</span>, expr.loc<span class='b'>)</span>

    <span class='k'>if</span> <span class='b'>(</span>curType.isMixin<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>expr.explicitType == <span class='k'>null</span><span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Must use named 'super' inside mixin"</span>, expr.loc<span class='b'>)</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>!expr.explicitType.isMixin<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Cannot use 'Obj.super' inside mixin (yeah I know - take it up with Sun)"</span>, expr.loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='k'>if</span> <span class='b'>(</span>expr.explicitType != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!curType.fits<span class='b'>(</span>expr.explicitType<span class='b'>))</span>
        err<span class='b'>(</span><span class='s'>"Named super '$expr.explicitType' not a super class of '$curType.name'"</span>, expr.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTypeCheck'>checkTypeCheck</span><span class='b'>(</span>TypeCheckExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// don't bother checking a synthetic coercion that the</span>
    <span class='y'>// compiler generated itself (which is most coercions)</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.synthetic<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// verify types are convertible</span>
    check := expr.check
    target := expr.target.ctype
    <span class='k'>if</span> <span class='b'>(</span>!check.fits<span class='b'>(</span>target<span class='b'>)</span> &amp;&amp; !target.fits<span class='b'>(</span>check<span class='b'>)</span> &amp;&amp; !check.isMixin &amp;&amp; !target.isMixin<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Inconvertible types '$target' and '$check'"</span>, expr.loc<span class='b'>)</span>

    <span class='y'>// don't allow is, as, isnot (everything but coerce) to be</span>
    <span class='y'>// used with value type expressions</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.id != ExprId.coerce<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>target.isVal<span class='b'>)</span>
      <span class='b'>{</span>
        err<span class='b'>(</span><span class='s'>"Cannot use '$expr.opStr' operator on value type '$target'"</span>, expr.loc<span class='b'>)</span>
        <span class='k'>return</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// don't allow as with nullable</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.id === ExprId.asExpr &amp;&amp; check.isNullable<span class='b'>)</span>
      err<span class='b'>(</span><span class='s'>"Cannot use 'as' operator with nullable type '$check'"</span>, expr.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTernary'>checkTernary</span><span class='b'>(</span>TernaryExpr expr<span class='b'>)</span>
  <span class='b'>{</span>
    expr.condition = coerce<span class='b'>(</span>expr.condition, ns.boolType<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Ternary condition must be Bool, not '$expr.condition.ctype'"</span>, expr.condition.loc<span class='b'>)</span>
    <span class='b'>}</span>
    expr.trueExpr = coerce<span class='b'>(</span>expr.trueExpr, expr.ctype<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Ternary true expr '$expr.trueExpr.toTypeStr' cannot be coerced to $expr.ctype"</span>, expr.trueExpr.loc<span class='b'>)</span>
    <span class='b'>}</span>
    expr.falseExpr = coerce<span class='b'>(</span>expr.falseExpr, expr.ctype<span class='b'>)</span> |-&gt;|
    <span class='b'>{</span>
      err<span class='b'>(</span><span class='s'>"Ternary false expr '$expr.falseExpr.toTypeStr' cannot be coerced to $expr.ctype"</span>, expr.falseExpr.loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Check Args</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='checkArgs'>checkArgs</span><span class='b'>(</span>CallExpr call<span class='b'>)</span>
  <span class='b'>{</span>
    method := call.method
    base := call.target == <span class='k'>null</span> ? method.parent : call.target.ctype
    name := call.name
    args := call.args
    newArgs := args.dup
    isErr := <span class='k'>false</span>
    params := method.params
    genericParams := method.isParameterized ? method.generic.params : <span class='k'>null</span>

    <span class='y'>// if we are calling call(A, B...) on a FuncType, then</span>
    <span class='y'>// use the first class Func signature rather than the</span>
    <span class='y'>// version of call which got picked because we might have</span>
    <span class='y'>// picked the wrong call version</span>
    sig := method.parent <span class='k'>as</span> FuncType
    <span class='k'>if</span> <span class='b'>(</span>sig != <span class='k'>null</span> &amp;&amp; name == <span class='s'>"call"</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>sig.params.size != args.size<span class='b'>)</span>
      <span class='b'>{</span>
        isErr = <span class='k'>true</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        sig.params.each |CType p, Int i|
        <span class='b'>{</span>
          <span class='y'>// check each argument and ensure boxed</span>
          newArgs<span class='b'>[</span>i<span class='b'>]</span> = coerceBoxed<span class='b'>(</span>args<span class='b'>[</span>i<span class='b'>]</span>, p<span class='b'>)</span> |-&gt;| <span class='b'>{</span> isErr = <span class='k'>true</span> <span class='b'>}</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// if more args than params, always an err</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>params.size &lt; args.size<span class='b'>)</span>
    <span class='b'>{</span>
      isErr = <span class='k'>true</span>
    <span class='b'>}</span>

    <span class='y'>// check each arg against each parameter</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      params.each |CParam p, Int i|
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>i &gt;= args.size<span class='b'>)</span>
        <span class='b'>{</span>
          <span class='y'>// param has a default value, then that is ok</span>
          <span class='k'>if</span> <span class='b'>(</span>!p.hasDefault<span class='b'>)</span> isErr = <span class='k'>true</span>
        <span class='b'>}</span>
        <span class='k'>else</span>
        <span class='b'>{</span>
          <span class='y'>// ensure arg fits parameter type (or auto-cast)</span>
          pt := p.paramType.parameterizeThis<span class='b'>(</span>base<span class='b'>)</span>
          newArgs<span class='b'>[</span>i<span class='b'>]</span> = coerce<span class='b'>(</span>args<span class='b'>[</span>i<span class='b'>]</span>, pt<span class='b'>)</span> |-&gt;|
          <span class='b'>{</span>
            isErr = name != <span class='s'>"compare"</span> <span class='y'>// TODO let anything slide for Obj.compare</span>
          <span class='b'>}</span>

          <span class='y'>// if this a parameterized generic, then we need to box</span>
          <span class='y'>// even if the expected type is a value-type (since the</span>
          <span class='y'>// actual implementation methods are all Obj based)</span>
          <span class='k'>if</span> <span class='b'>(</span>!isErr &amp;&amp; genericParams != <span class='k'>null</span> &amp;&amp; genericParams<span class='b'>[</span>i<span class='b'>]</span>.paramType.isGenericParameter<span class='b'>)</span>
            newArgs<span class='b'>[</span>i<span class='b'>]</span> = box<span class='b'>(</span>newArgs<span class='b'>[</span>i<span class='b'>])</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='k'>if</span> <span class='b'>(</span>!isErr<span class='b'>)</span>
    <span class='b'>{</span>
      call.args = newArgs
      <span class='k'>return</span>
    <span class='b'>}</span>

    msg := <span class='s'>"Invalid args "</span>
    <span class='k'>if</span> <span class='b'>(</span>sig != <span class='k'>null</span><span class='b'>)</span>
      msg += <span class='s'>"|"</span> + sig.params.join<span class='b'>(</span><span class='s'>", "</span><span class='b'>)</span> + <span class='s'>"|"</span>
    <span class='k'>else</span>
      msg += <span class='s'>"$name("</span> + params.join<span class='b'>(</span><span class='s'>", "</span>, |p| <span class='b'>{</span> paramTypeStr<span class='b'>(</span>base, p<span class='b'>)</span> <span class='b'>})</span> + <span class='s'>")"</span>
    msg += <span class='s'>", not ("</span> + args.join<span class='b'>(</span><span class='s'>", "</span>, |Expr e-&gt;Str| <span class='b'>{</span> <span class='k'>return</span> <span class='s'>"$e.toTypeStr"</span> <span class='b'>})</span> + <span class='s'>")"</span>
    err<span class='b'>(</span>msg, call.loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>internal</span> <span class='k'>static</span> Str <span id='paramTypeStr'>paramTypeStr</span><span class='b'>(</span>CType base, CParam param<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> param.paramType.parameterizeThis<span class='b'>(</span>base<span class='b'>)</span>.inferredAs.signature
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Type</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='checkValidType'>checkValidType</span><span class='b'>(</span>Loc loc, CType t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>!t.isValid<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid type '$t'"</span>, loc<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Flag Utils</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Void <span id='checkProtectionFlags'>checkProtectionFlags</span><span class='b'>(</span>Int flags, Loc loc<span class='b'>)</span>
  <span class='b'>{</span>
    isPublic    := flags.and<span class='b'>(</span>FConst.Public<span class='b'>)</span>    != 0
    isProtected := flags.and<span class='b'>(</span>FConst.Protected<span class='b'>)</span> != 0
    isPrivate   := flags.and<span class='b'>(</span>FConst.Private<span class='b'>)</span>   != 0
    isInternal  := flags.and<span class='b'>(</span>FConst.Internal<span class='b'>)</span>  != 0
    isVirtual   := flags.and<span class='b'>(</span>FConst.Virtual<span class='b'>)</span>   != 0
    isOverride  := flags.and<span class='b'>(</span>FConst.Override<span class='b'>)</span>  != 0

    <span class='k'>if</span> <span class='b'>(</span>isPublic<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isProtected<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'public' and 'protected' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>isPrivate<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Invalid combination of 'public' and 'private' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>isInternal<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Invalid combination of 'public' and 'internal' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>isProtected<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isPrivate<span class='b'>)</span>   err<span class='b'>(</span><span class='s'>"Invalid combination of 'protected' and 'private' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>isInternal<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Invalid combination of 'protected' and 'internal' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>isPrivate<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isInternal<span class='b'>)</span>  err<span class='b'>(</span><span class='s'>"Invalid combination of 'private' and 'internal' modifiers"</span>, loc<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>isVirtual &amp;&amp; !isOverride<span class='b'>)</span> err<span class='b'>(</span><span class='s'>"Invalid combination of 'private' and 'virtual' modifiers"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkTypeProtection'>checkTypeProtection</span><span class='b'>(</span>CType t, Loc loc<span class='b'>)</span>
  <span class='b'>{</span>
    t = t.toNonNullable

    <span class='k'>if</span> <span class='b'>(</span>t <span class='k'>is</span> GenericType<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>t <span class='k'>is</span> ListType<span class='b'>)</span>
      <span class='b'>{</span>
        x := <span class='b'>(</span>ListType<span class='b'>)</span>t
        checkTypeProtection<span class='b'>(</span>x.v, loc<span class='b'>)</span>
      <span class='b'>}</span>
      <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>t <span class='k'>is</span> MapType<span class='b'>)</span>
      <span class='b'>{</span>
        x := <span class='b'>(</span>MapType<span class='b'>)</span>t
        checkTypeProtection<span class='b'>(</span>x.k, loc<span class='b'>)</span>
        checkTypeProtection<span class='b'>(</span>x.v, loc<span class='b'>)</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        x := <span class='b'>(</span>FuncType<span class='b'>)</span>t
        checkTypeProtection<span class='b'>(</span>x.ret, loc<span class='b'>)</span>
        x.params.each |CType p| <span class='b'>{</span> checkTypeProtection<span class='b'>(</span>p, loc<span class='b'>)</span> <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>t.isInternal &amp;&amp; t.pod != curType.pod<span class='b'>)</span>
        err<span class='b'>(</span><span class='s'>"Internal type '$t' not accessible"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    checkDeprecated<span class='b'>(</span>t, loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Void <span id='checkSlotProtection'>checkSlotProtection</span><span class='b'>(</span>CSlot slot, Loc loc, Bool setter := <span class='k'>false</span><span class='b'>)</span>
  <span class='b'>{</span>
    errMsg := slotProtectionErr<span class='b'>(</span>slot, setter<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>errMsg != <span class='k'>null</span><span class='b'>)</span> err<span class='b'>(</span>errMsg, loc<span class='b'>)</span>

    checkDeprecated<span class='b'>(</span>slot, loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Str? <span id='slotProtectionErr'>slotProtectionErr</span><span class='b'>(</span>CSlot slot, Bool setter := <span class='k'>false</span><span class='b'>)</span>
  <span class='b'>{</span>
    msg := setter ? <span class='s'>"setter of field"</span> : <span class='b'>(</span>slot <span class='k'>is</span> CMethod ? <span class='s'>"method"</span> : <span class='s'>"field"</span><span class='b'>)</span>

    <span class='y'>// short circuit if method on myself</span>
    <span class='k'>if</span> <span class='b'>(</span>curType == slot.parent<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>null</span>

    <span class='y'>// allow closures same scope priviledges as enclosing class</span>
    myType := curType
    <span class='k'>if</span> <span class='b'>(</span>myType != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>myType.isClosure<span class='b'>)</span> myType = curType.closure.enclosingType
    <span class='b'>}</span>

    <span class='y'>// consider the slot internal if its parent is internal</span>
    isInternal := slot.isInternal || <span class='b'>(</span>slot.parent.isInternal &amp;&amp; !slot.parent.isParameterized<span class='b'>)</span>

    <span class='k'>if</span> <span class='b'>(</span>slot.isPrivate &amp;&amp; myType != slot.parent<span class='b'>)</span>
      <span class='k'>return</span> <span class='s'>"Private $msg '$slot.qname' not accessible"</span>

    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>slot.isProtected &amp;&amp; !myType.fits<span class='b'>(</span>slot.parent<span class='b'>))</span>
      <span class='k'>return</span> <span class='s'>"Protected $msg '$slot.qname' not accessible"</span>

    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>isInternal &amp;&amp; myType.pod != slot.parent.pod<span class='b'>)</span>
      <span class='k'>return</span> <span class='s'>"Internal $msg '$slot.qname' not accessible"</span>

    <span class='k'>else</span>
      <span class='k'>return</span> <span class='k'>null</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Utils</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Check for the deprecated facet where target is CType or CSlot</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='checkDeprecated'>checkDeprecated</span><span class='b'>(</span>Obj target, Loc loc<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// don't check inside of synthetic getter/setter</span>
    <span class='k'>if</span> <span class='b'>(</span>curMethod != <span class='k'>null</span> &amp;&amp; curMethod.isSynthetic<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// check both slot and its parent type</span>
    slot := target <span class='k'>as</span> CSlot
    CFacet? f := <span class='k'>null</span>
    <span class='k'>if</span> <span class='b'>(</span>slot != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      f = slot.facet<span class='b'>(</span><span class='s'>"sys::Deprecated"</span><span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>f == <span class='k'>null</span><span class='b'>)</span> target = slot.parent
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>f == <span class='k'>null</span><span class='b'>)</span> f = <span class='b'>((</span>CType<span class='b'>)</span>target<span class='b'>)</span>.facet<span class='b'>(</span><span class='s'>"sys::Deprecated"</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>f == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// we got a deprecration warning - log it</span>
    kind := target <span class='k'>is</span> CType ? <span class='s'>"type"</span> : <span class='s'>"slot"</span>
    qname := <span class='b'>(</span>Str<span class='b'>)</span>target-&gt;qname
    msg := f.get<span class='b'>(</span><span class='s'>"msg"</span><span class='b'>)</span> <span class='k'>as</span> Str ?: <span class='s'>""</span>
    <span class='k'>if</span> <span class='b'>(</span>!msg.isEmpty<span class='b'>)</span>
      warn<span class='b'>(</span><span class='s'>"Deprecated $kind '$qname' - $msg"</span>, loc<span class='b'>)</span>
    <span class='k'>else</span>
      warn<span class='b'>(</span><span class='s'>"Deprecated $kind '$qname'"</span>, loc<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Ensure the specified expression is boxed to an object reference.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='box'>box</span><span class='b'>(</span>Expr expr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.ctype.isVal<span class='b'>)</span>
      <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>expr, ns.objType.toNullable<span class='b'>)</span>
    <span class='k'>else</span>
      <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Run the standard coerce method and ensure the result is boxed.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Expr <span id='coerceBoxed'>coerceBoxed</span><span class='b'>(</span>Expr expr, CType expected, |-&gt;| onErr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> box<span class='b'>(</span>coerce<span class='b'>(</span>expr, expected, onErr<span class='b'>))</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Coerce the target expression to the specified type.  If</span>
  <span class='z'>** the expression is not type compatible run the onErr function.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Expr <span id='coerce'>coerce</span><span class='b'>(</span>Expr expr, CType expected, |-&gt;| onErr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// route to bridge for FFI coercion if either side if foreign</span>
    <span class='k'>if</span> <span class='b'>(</span>expected.isForeign<span class='b'>)</span> <span class='k'>return</span> expected.bridge.coerce<span class='b'>(</span>expr, expected, onErr<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.ctype.isForeign<span class='b'>)</span> <span class='k'>return</span> expr.ctype.bridge.coerce<span class='b'>(</span>expr, expected, onErr<span class='b'>)</span>

    <span class='y'>// normal Fantom coercion behavior</span>
    <span class='k'>return</span> doCoerce<span class='b'>(</span>expr, expected, onErr<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Coerce the target expression to the specified type.  If</span>
  <span class='z'>** the expression is not type compatible run the onErr function.</span>
  <span class='z'>** Default Fantom behavior.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Expr <span id='doCoerce'>doCoerce</span><span class='b'>(</span>Expr expr, CType expected, |-&gt;| onErr<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// sanity check that expression has been typed</span>
    CType actual := expr.ctype
    <span class='k'>if</span> <span class='b'>((</span>Obj?<span class='b'>)</span>actual == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> NullErr<span class='b'>(</span><span class='s'>"null ctype: ${expr}"</span><span class='b'>)</span>

    <span class='y'>// if the same type this is easy</span>
    <span class='k'>if</span> <span class='b'>(</span>actual == expected<span class='b'>)</span> <span class='k'>return</span> expr

    <span class='y'>// if actual type is nothing, then its of no matter</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.isNothing<span class='b'>)</span> <span class='k'>return</span> expr

    <span class='y'>// we can never use a void expression</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.isVoid || expected.isVoid<span class='b'>)</span>
    <span class='b'>{</span>
      onErr<span class='b'>()</span>
      <span class='k'>return</span> expr
    <span class='b'>}</span>

    <span class='y'>// if expr is always nullable (null literal, safe invoke, as),</span>
    <span class='y'>// then verify expected type is nullable</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.isAlwaysNullable<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>!expected.isNullable<span class='b'>)</span> <span class='b'>{</span> onErr<span class='b'>()</span>; <span class='k'>return</span> expr <span class='b'>}</span>

      <span class='y'>// null literals don't need cast to nullable types,</span>
      <span class='y'>// otherwise // fall-thru to apply coercion</span>
      <span class='k'>if</span> <span class='b'>(</span>expr.id === ExprId.nullLiteral<span class='b'>)</span> <span class='k'>return</span> expr
    <span class='b'>}</span>

    <span class='y'>// if the expression fits to type, that is ok</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.fits<span class='b'>(</span>expected<span class='b'>))</span>
    <span class='b'>{</span>
      <span class='y'>// if we have any nullable/value difference we need a coercion</span>
      <span class='k'>if</span> <span class='b'>(</span>needCoerce<span class='b'>(</span>actual, expected<span class='b'>))</span>
        <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>expr, expected<span class='b'>)</span>
      <span class='k'>else</span>
        <span class='k'>return</span> expr
    <span class='b'>}</span>

    <span class='y'>// if we can auto-cast to make the expr fit then do it - we</span>
    <span class='y'>// have to treat function auto-casting a little specially here</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.isFunc &amp;&amp; expected.isFunc<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isFuncAutoCoerce<span class='b'>(</span>actual, expected<span class='b'>))</span>
        <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>expr, expected<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>expected.fits<span class='b'>(</span>actual<span class='b'>))</span>
        <span class='k'>return</span> TypeCheckExpr.coerce<span class='b'>(</span>expr, expected<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='y'>// we have an error condition</span>
    onErr<span class='b'>()</span>
    <span class='k'>return</span> expr
  <span class='b'>}</span>

  <span class='k'>static</span> Bool <span id='isFuncAutoCoerce'>isFuncAutoCoerce</span><span class='b'>(</span>CType actualType, CType expectedType<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check if both are function types</span>
    <span class='k'>if</span> <span class='b'>(</span>!actualType.isFunc || !expectedType.isFunc<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    actual   := actualType.toNonNullable <span class='k'>as</span> FuncType
    expected := expectedType.toNonNullable <span class='k'>as</span> FuncType

    <span class='y'>// auto-cast to or from unparameterized 'sys::Func'</span>
    <span class='k'>if</span> <span class='b'>(</span>actual == <span class='k'>null</span> || expected == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// if actual function requires more parameters than</span>
    <span class='y'>// we are expecting, then this cannot be a match</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.arity &gt; expected.arity<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// check return type</span>
    <span class='k'>if</span> <span class='b'>(</span>!isFuncAutoCoerceMatch<span class='b'>(</span>actual.ret, expected.ret<span class='b'>))</span>
      <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// check that each parameter is auto-castable</span>
    <span class='k'>return</span> actual.params.all |CType actualParam, Int i-&gt;Bool|
    <span class='b'>{</span>
      expectedParam := expected.params<span class='b'>[</span>i<span class='b'>]</span>
      <span class='k'>return</span> isFuncAutoCoerceMatch<span class='b'>(</span>actualParam, expectedParam<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>static</span> Bool <span id='isFuncAutoCoerceMatch'>isFuncAutoCoerceMatch</span><span class='b'>(</span>CType actual, CType expected<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>actual.fits<span class='b'>(</span>expected<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>
    <span class='k'>if</span> <span class='b'>(</span>expected.fits<span class='b'>(</span>actual<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>
    <span class='k'>if</span> <span class='b'>(</span>isFuncAutoCoerce<span class='b'>(</span>actual, expected<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>
    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='k'>static</span> Bool <span id='needCoerce'>needCoerce</span><span class='b'>(</span>CType from, CType to<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if either side is a value type and we got past</span>
    <span class='y'>// the equals check then we definitely need a coercion</span>
    <span class='k'>if</span> <span class='b'>(</span>from.isVal || to.isVal<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// if going from Obj? -&gt; Obj we need a nullable coercion</span>
    <span class='k'>if</span> <span class='b'>(</span>!to.isNullable<span class='b'>)</span> <span class='k'>return</span> from.isNullable

    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='k'>private</span> Int <span id='protectedRegionDepth'>protectedRegionDepth</span> := 0  <span class='y'>// try statement depth</span>
  <span class='k'>private</span> Int <span id='finallyDepth'>finallyDepth</span> := 0          <span class='y'>// finally block depth</span>
  <span class='k'>private</span> Bool <span id='isSys'>isSys</span>
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='CheckErrors.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li class='hidden' style='display: block;'><a href='#box'>box</a></li>
  <li class='hidden' style='display: block;'><a href='#checkAbstractSlots'>checkAbstractSlots</a></li>
  <li class='hidden' style='display: block;'><a href='#checkArgs'>checkArgs</a></li>
  <li class='hidden' style='display: block;'><a href='#checkAssign'>checkAssign</a></li>
  <li class='hidden' style='display: block;'><a href='#checkAssignField'>checkAssignField</a></li>
  <li class='hidden' style='display: block;'><a href='#checkBase'>checkBase</a></li>
  <li class='hidden' style='display: block;'><a href='#checkBool'>checkBool</a></li>
  <li class='hidden' style='display: block;'><a href='#checkBools'>checkBools</a></li>
  <li class='hidden' style='display: block;'><a href='#checkBreak'>checkBreak</a></li>
  <li class='hidden' style='display: block;'><a href='#checkCall'>checkCall</a></li>
  <li class='hidden' style='display: block;'><a href='#checkCompare'>checkCompare</a></li>
  <li class='hidden' style='display: block;'><a href='#checkCompareNull'>checkCompareNull</a></li>
  <li class='hidden' style='display: block;'><a href='#checkConstType'>checkConstType</a></li>
  <li class='hidden' style='display: block;'><a href='#checkConstruction'>checkConstruction</a></li>
  <li class='hidden' style='display: block;'><a href='#checkContinue'>checkContinue</a></li>
  <li class='hidden' style='display: block;'><a href='#checkCtor'>checkCtor</a></li>
  <li class='hidden' style='display: block;'><a href='#checkDefiniteAssign'>checkDefiniteAssign</a></li>
  <li class='hidden' style='display: block;'><a href='#checkDeprecated'>checkDeprecated</a></li>
  <li class='hidden' style='display: block;'><a href='#checkElvis'>checkElvis</a></li>
  <li class='hidden' style='display: block;'><a href='#checkExprStmt'>checkExprStmt</a></li>
  <li style='display: block;'><a href='#checkFacet'>checkFacet</a></li>
  <li style='display: block;'><a href='#checkFacets'>checkFacets</a></li>
  <li class='hidden' style='display: block;'><a href='#checkField'>checkField</a></li>
  <li class='hidden' style='display: block;'><a href='#checkFieldFlags'>checkFieldFlags</a></li>
  <li class='hidden' style='display: block;'><a href='#checkFor'>checkFor</a></li>
  <li class='hidden' style='display: block;'><a href='#checkIf'>checkIf</a></li>
  <li class='hidden' style='display: block;'><a href='#checkListLiteral'>checkListLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#checkLocalDef'>checkLocalDef</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMapLiteral'>checkMapLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMethodFlags'>checkMethodFlags</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMethodReturn'>checkMethodReturn</a></li>
  <li class='hidden' style='display: block;'><a href='#checkMixin'>checkMixin</a></li>
  <li class='hidden' style='display: block;'><a href='#checkNoNullSafes'>checkNoNullSafes</a></li>
  <li class='hidden' style='display: block;'><a href='#checkOperatorMethod'>checkOperatorMethod</a></li>
  <li class='hidden' style='display: block;'><a href='#checkParam'>checkParam</a></li>
  <li class='hidden' style='display: block;'><a href='#checkParams'>checkParams</a></li>
  <li style='display: block;'><a href='#checkPodDef'>checkPodDef</a></li>
  <li class='hidden' style='display: block;'><a href='#checkProtectionFlags'>checkProtectionFlags</a></li>
  <li class='hidden' style='display: block;'><a href='#checkRangeLiteral'>checkRangeLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#checkResConflicts'>checkResConflicts</a></li>
  <li class='hidden' style='display: block;'><a href='#checkReturn'>checkReturn</a></li>
  <li class='hidden' style='display: block;'><a href='#checkSame'>checkSame</a></li>
  <li class='hidden' style='display: block;'><a href='#checkShortcut'>checkShortcut</a></li>
  <li class='hidden' style='display: block;'><a href='#checkSlotLiteral'>checkSlotLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#checkSlotProtection'>checkSlotProtection</a></li>
  <li class='hidden' style='display: block;'><a href='#checkSuper'>checkSuper</a></li>
  <li class='hidden' style='display: block;'><a href='#checkSwitch'>checkSwitch</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTernary'>checkTernary</a></li>
  <li class='hidden' style='display: block;'><a href='#checkThis'>checkThis</a></li>
  <li class='hidden' style='display: block;'><a href='#checkThrow'>checkThrow</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTry'>checkTry</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTypeCheck'>checkTypeCheck</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTypeFlags'>checkTypeFlags</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTypeLiteral'>checkTypeLiteral</a></li>
  <li class='hidden' style='display: block;'><a href='#checkTypeProtection'>checkTypeProtection</a></li>
  <li class='hidden' style='display: block;'><a href='#checkValidType'>checkValidType</a></li>
  <li class='hidden' style='display: block;'><a href='#checkWhile'>checkWhile</a></li>
  <li style='display: block;'><a href='#coerce'>coerce</a></li>
  <li class='hidden' style='display: block;'><a href='#coerceBoxed'>coerceBoxed</a></li>
  <li style='display: block;'><a href='#doCoerce'>doCoerce</a></li>
  <li style='display: block;'><a href='#enterFinally'>enterFinally</a></li>
  <li style='display: block;'><a href='#enterStmt'>enterStmt</a></li>
  <li style='display: block;'><a href='#exitFinally'>exitFinally</a></li>
  <li style='display: block;'><a href='#exitStmt'>exitStmt</a></li>
  <li class='hidden' style='display: block;'><a href='#finallyDepth'>finallyDepth</a></li>
  <li class='hidden' style='display: block;'><a href='#implicitToImmutable'>implicitToImmutable</a></li>
  <li style='display: block;'><a href='#isFuncAutoCoerce'>isFuncAutoCoerce</a></li>
  <li style='display: block;'><a href='#isFuncAutoCoerceMatch'>isFuncAutoCoerceMatch</a></li>
  <li style='display: block;'><a href='#isRestrictedName'>isRestrictedName</a></li>
  <li class='hidden' style='display: block;'><a href='#isSys'>isSys</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#needCoerce'>needCoerce</a></li>
  <li class='hidden' style='display: block;'><a href='#paramTypeStr'>paramTypeStr</a></li>
  <li class='hidden' style='display: block;'><a href='#protectedRegionDepth'>protectedRegionDepth</a></li>
  <li style='display: block;'><a href='#run'>run</a></li>
  <li class='hidden' style='display: block;'><a href='#slotProtectionErr'>slotProtectionErr</a></li>
  <li class='hidden' style='display: block;'><a href='#useFieldAccessor'>useFieldAccessor</a></li>
  <li style='display: block;'><a href='#visitExpr'>visitExpr</a></li>
  <li style='display: block;'><a href='#visitFieldDef'>visitFieldDef</a></li>
  <li style='display: block;'><a href='#visitMethodDef'>visitMethodDef</a></li>
  <li style='display: block;'><a href='#visitStmt'>visitStmt</a></li>
  <li style='display: block;'><a href='#visitTypeDef'>visitTypeDef</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

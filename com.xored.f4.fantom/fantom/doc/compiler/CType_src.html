<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::CType</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='CType.html'>CType</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>mixin</h2>
<h1>compiler::CType</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  compiler::CType</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   4 Jun 06  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** CType is a "compiler type" which is class used for representing</span>
<span class='z'>** the Fantom type system in the compiler.  CTypes map to types within</span>
<span class='z'>** the compilation units themsevles as TypeDef and TypeRef or to</span>
<span class='z'>** precompiled types in imported pods via ReflectType or FType.</span>
<span class='z'>**</span>
<span class='k'>mixin</span> CType
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Naming</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Associated namespace for this type representation</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CNamespace <span id='ns'>ns</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Parent pod which defines this type.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CPod <span id='pod'>pod</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Simple name of the type such as "Str".</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Str <span id='name'>name</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Qualified name such as "sys:Str".</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Str <span id='qname'>qname</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** This is the full signature of the type.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Str <span id='signature'>signature</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return signature</span>
  <span class='z'>**</span>
  <span class='k'>override</span> <span class='k'>final</span> Str <span id='toStr'>toStr</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> signature <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a TypeRef, return what it references</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CType <span id='deref'>deref</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>this</span> <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Nullable</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Is this is a value type (Bool, Int, or Float and their nullables)</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='isVal'>isVal</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Static utility for value type</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Bool <span id='isValType'>isValType</span><span class='b'>(</span>Str qname<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>switch</span> <span class='b'>(</span>qname<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>case</span> <span class='s'>"sys::Bool"</span>:
      <span class='k'>case</span> <span class='s'>"sys::Int"</span>:
      <span class='k'>case</span> <span class='s'>"sys::Float"</span>:
        <span class='k'>return</span> <span class='k'>true</span>
      <span class='k'>default</span>:
        <span class='k'>return</span> <span class='k'>false</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Nullable</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Is this is a nullable type (marked with trailing ?)</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='isNullable'>isNullable</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get this type as a nullable type (marked with trailing ?)</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CType <span id='toNullable'>toNullable</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get this type as a non-nullable (if nullable)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CType <span id='toNonNullable'>toNonNullable</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>this</span> <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// FFI</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If this a foreign function interface type.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool <span id='isForeign'>isForeign</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>false</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this TypeDef extends from a FFI class or implements any</span>
  <span class='z'>** FFI mixins, then return the FFI type otherwise return null.</span>
  <span class='z'>**</span>
  CType? <span id='foreignInheritance'>foreignInheritance</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>base == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    <span class='k'>if</span> <span class='b'>(</span>base.isForeign<span class='b'>)</span> <span class='k'>return</span> base
    m := mixins.find |CType t-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> t.isForeign <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>m != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> m
    <span class='k'>return</span> base.foreignInheritance
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a foreign function return the bridge.</span>
  <span class='z'>**</span>
  CBridge? <span id='bridge'>bridge</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> pod.bridge <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this type is being used for type inference then get the</span>
  <span class='z'>** type as it should be inferred.  Typically we just return this.</span>
  <span class='z'>** However some FFI types such as '[java]::int' are never used</span>
  <span class='z'>** on the stack directly and are inferred to be 'sys::Int'.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CType <span id='inferredAs'>inferredAs</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>this</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if type is supported by the Fantom type system.  For example</span>
  <span class='z'>** the Java FFI will correctly model a Java multi-dimensional array</span>
  <span class='z'>** during compilation, however there is no Fantom representation.  We</span>
  <span class='z'>** check for supported types during CheckErrors when accessing</span>
  <span class='z'>** fields and methods.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool <span id='isSupported'>isSupported</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='k'>true</span> <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Generics</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** A generic type means that one or more of my slots contain signatures</span>
  <span class='z'>** using a generic parameter (such as V or K).  Fantom supports three built-in</span>
  <span class='z'>** generic types: List, Map, and Func.  A generic instance (such as Str[])</span>
  <span class='z'>** is NOT a generic type (all of its generic parameters have been filled in).</span>
  <span class='z'>** User defined generic types are not supported in Fan.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='isGeneric'>isGeneric</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** A parameterized type is a type which has parameterized a generic type</span>
  <span class='z'>** and replaced all the generic parameter types with generic argument</span>
  <span class='z'>** types.  The type Str[] is a parameterized type of the generic type</span>
  <span class='z'>** List (V is replaced with Str).  A parameterized type always has a</span>
  <span class='z'>** signature which is different from the qname.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='isParameterized'>isParameterized</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this type is a generic parameter (such as V or K) in a</span>
  <span class='z'>** generic type (List, Map, or Method).  Generic parameters serve</span>
  <span class='z'>** as place holders for the parameterization of the generic type.</span>
  <span class='z'>** Fantom has a predefined set of generic parameters which are always</span>
  <span class='z'>** defined in the sys pod with a one character name.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='isGenericParameter'>isGenericParameter</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Create a parameterized List of this type.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CType <span id='toListOf'>toListOf</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** If this type is a generic parameter (V, L, etc), then return</span>
  <span class='z'>** the actual type for the native implementation.  For example V</span>
  <span class='z'>** is Obj, and L is List.  This is the type we actually use when</span>
  <span class='z'>** constructing a signature for the invoke opcode.</span>
  <span class='z'>**</span>
  CType <span id='raw'>raw</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// if not generic parameter, always use this type</span>
    <span class='k'>if</span> <span class='b'>(</span>!isGenericParameter<span class='b'>)</span> <span class='k'>return</span> <span class='k'>this</span>

    <span class='y'>// it's possible that this type is a generic unparameterized</span>
    <span class='y'>// instance of Method (such as List.each), in which case</span>
    <span class='y'>// we should use this type itself</span>
    <span class='k'>if</span> <span class='b'>(</span>name.size != 1<span class='b'>)</span> <span class='k'>return</span> <span class='k'>this</span>

    <span class='k'>switch</span> <span class='b'>(</span>name<span class='b'>[</span>0<span class='b'>])</span>
    <span class='b'>{</span>
      <span class='k'>case</span> <span class='s'>'L'</span>: <span class='k'>return</span> ns.listType
      <span class='k'>case</span> <span class='s'>'M'</span>: <span class='k'>return</span> ns.mapType
      <span class='k'>default</span>:  <span class='k'>return</span> ns.objType
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a parameterized type which uses 'This',</span>
  <span class='z'>** then replace 'This' with the specified type.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CType <span id='parameterizeThis'>parameterizeThis</span><span class='b'>(</span>CType thisType<span class='b'>)</span> <span class='b'>{</span> <span class='k'>this</span> <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Inheritance</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** The direct super class of this type (null for Obj).</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CType? <span id='base'>base</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the mixins directly implemented by this type.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CType<span class='b'>[]</span> <span id='mixins'>mixins</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Hash on signature.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Int <span id='hash'>hash</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> signature.hash
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Equality based on signature.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Bool <span id='equals'>equals</span><span class='b'>(</span>Obj? t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> === t<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>
    that := t <span class='k'>as</span> CType
    <span class='k'>if</span> <span class='b'>(</span>that == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>
    <span class='k'>return</span> signature == that.signature
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Does this type implement the specified type.  If true, then</span>
  <span class='z'>** this type is assignable to the specified type (although the</span>
  <span class='z'>** converse is not necessarily true).  All types (including</span>
  <span class='z'>** mixin types) fit sys::Obj.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool <span id='fits'>fits</span><span class='b'>(</span>CType t<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// don't take nullable in consideration</span>
    t = t.toNonNullable

    <span class='y'>// everything fits Obj</span>
    <span class='k'>if</span> <span class='b'>(</span>t.isObj<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// short circuit if myself</span>
    <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span> == t<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// recurse extends</span>
    <span class='k'>if</span> <span class='b'>(</span>base != <span class='k'>null</span> &amp;&amp; base.fits<span class='b'>(</span>t<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// recuse mixins</span>
    <span class='k'>for</span> <span class='b'>(</span>i:=0; i&lt;mixins.size; ++i<span class='b'>)</span>
      <span class='k'>if</span> <span class='b'>(</span>mixins<span class='b'>[</span>i<span class='b'>]</span>.fits<span class='b'>(</span>t<span class='b'>))</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// let anything fit unparameterized generic parameters like</span>
    <span class='y'>// V, K (in case we are using List, Map, or Method directly)</span>
    <span class='k'>if</span> <span class='b'>(</span>t.name.size == 1 &amp;&amp; t.pod.name == <span class='s'>"sys"</span><span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// no fit</span>
    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this type fits any of the types in the specified list.</span>
  <span class='z'>**</span>
  Bool <span id='fitsAny'>fitsAny</span><span class='b'>(</span>CType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>return</span> types.any |CType t-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> <span class='k'>this</span>.fits<span class='b'>(</span>t<span class='b'>)</span> <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Given a list of types, compute the most specific type which they</span>
  <span class='z'>** all share, or at worst return sys::Obj.  This method does not take</span>
  <span class='z'>** into account mixins, only extends class inheritance.</span>
  <span class='z'>**</span>
  <span class='k'>public</span> <span class='k'>static</span> CType <span id='common'>common</span><span class='b'>(</span>CNamespace ns, CType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// special handling for nothing</span>
    <span class='k'>if</span> <span class='b'>(</span>types.size == 2<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>types<span class='b'>[</span>0<span class='b'>]</span>.isNothing<span class='b'>)</span> <span class='k'>return</span> types<span class='b'>[</span>1<span class='b'>]</span>
      <span class='k'>if</span> <span class='b'>(</span>types<span class='b'>[</span>1<span class='b'>]</span>.isNothing<span class='b'>)</span> <span class='k'>return</span> types<span class='b'>[</span>0<span class='b'>]</span>
    <span class='b'>}</span>

    <span class='y'>// special handling for zero or one types</span>
    <span class='k'>if</span> <span class='b'>(</span>types.size == 0<span class='b'>)</span> <span class='k'>return</span> ns.objType.toNullable
    <span class='k'>if</span> <span class='b'>(</span>types.size == 1<span class='b'>)</span> <span class='k'>return</span> types.first

    <span class='y'>// first-pass iteration is used to:</span>
    <span class='y'>//   - check if any one of the types is nullable</span>
    <span class='y'>//   - check if any of the types is a parameterized generic</span>
    <span class='y'>//   - normalize our types to non-nullable</span>
    mixins := <span class='k'>false</span>
    nullable := <span class='k'>false</span>
    parameterized := <span class='k'>false</span>
    types = types.dup
    types.each |t, i|
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>t.isParameterized<span class='b'>)</span> parameterized = <span class='k'>true</span>
      <span class='k'>if</span> <span class='b'>(</span>t.isNullable<span class='b'>)</span> nullable = <span class='k'>true</span>
      <span class='k'>if</span> <span class='b'>(</span>t.isMixin<span class='b'>)</span> mixins = <span class='k'>true</span>
      types<span class='b'>[</span>i<span class='b'>]</span> = t.toNonNullable
    <span class='b'>}</span>

    <span class='y'>// if any one of the items is parameterized then we handle it</span>
    <span class='y'>// specially, otherwise we find the most common class</span>
    CType? best
    <span class='k'>if</span> <span class='b'>(</span>parameterized<span class='b'>)</span>
      best = commonParameterized<span class='b'>(</span>ns, types<span class='b'>)</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>mixins<span class='b'>)</span>
      best = commonMixin<span class='b'>(</span>ns, types<span class='b'>)</span>
    <span class='k'>else</span>
      best = commonClass<span class='b'>(</span>ns, types<span class='b'>)</span>

    <span class='y'>// if any one of the items was nullable, then whole result is nullable</span>
    <span class='k'>return</span> nullable ? best.toNullable : best
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> CType <span id='commonClass'>commonClass</span><span class='b'>(</span>CNamespace ns, CType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    best := types<span class='b'>[</span>0<span class='b'>]</span>
    <span class='k'>for</span> <span class='b'>(</span>Int i:=1; i&lt;types.size; ++i<span class='b'>)</span>
    <span class='b'>{</span>
      t := types<span class='b'>[</span>i<span class='b'>]</span>
      <span class='k'>while</span> <span class='b'>(</span>!t.fits<span class='b'>(</span>best<span class='b'>))</span>
      <span class='b'>{</span>
        bestBase := best.base
        <span class='k'>if</span> <span class='b'>(</span>bestBase == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> ns.objType
        best = bestBase
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>return</span> best
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> CType <span id='commonMixin'>commonMixin</span><span class='b'>(</span>CNamespace ns, CType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// mixins must all be same type or else we fallback to Obj</span>
    first := types<span class='b'>[</span>0<span class='b'>]</span>
    allSame := types.all |t| <span class='b'>{</span> t == first <span class='b'>}</span>
    <span class='k'>return</span> allSame ? first : ns.objType
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> CType <span id='commonParameterized'>commonParameterized</span><span class='b'>(</span>CNamespace ns, CType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// we only support common inference on parameterized lists</span>
    <span class='y'>// since they are one dimensional in their parameterization,</span>
    <span class='y'>// all other inference is based strictly on exact type</span>
    allList := <span class='k'>true</span>
    allMap  := <span class='k'>true</span>
    allFunc := <span class='k'>true</span>
    types.each |t|
    <span class='b'>{</span>
      allList = allList &amp;&amp; t <span class='k'>is</span> ListType
      allMap  = allMap  &amp;&amp; t <span class='k'>is</span> MapType
      allFunc = allFunc &amp;&amp; t <span class='k'>is</span> FuncType
    <span class='b'>}</span>
    <span class='k'>if</span> <span class='b'>(</span>allList<span class='b'>)</span> <span class='k'>return</span> commonList<span class='b'>(</span>ns, types<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>allMap<span class='b'>)</span>  <span class='k'>return</span> commonExact<span class='b'>(</span>ns, types, ns.mapType<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>allFunc<span class='b'>)</span> <span class='k'>return</span> commonExact<span class='b'>(</span>ns, types, ns.funcType<span class='b'>)</span>
    <span class='k'>return</span> ns.objType
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> CType <span id='commonList'>commonList</span><span class='b'>(</span>CNamespace ns, ListType<span class='b'>[]</span> types<span class='b'>)</span>
  <span class='b'>{</span>
    vTypes := types.map |t-&gt;CType| <span class='b'>{</span> t.v <span class='b'>}</span>
    <span class='k'>return</span> common<span class='b'>(</span>ns, vTypes<span class='b'>)</span>.toListOf
  <span class='b'>}</span>

  <span class='k'>private</span> <span class='k'>static</span> CType <span id='commonExact'>commonExact</span><span class='b'>(</span>CNamespace ns, CType<span class='b'>[]</span> types, CType fallback<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// we only infer func types based strictly on exact type</span>
    first := types<span class='b'>[</span>0<span class='b'>]</span>
    exact := types.all |t| <span class='b'>{</span> first == t <span class='b'>}</span>
    <span class='k'>return</span> exact ? first : fallback
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Flags</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the flags bitmask.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Int <span id='flags'>flags</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is a class (as opposed to enum or mixin)</span>
  <span class='z'>**</span>
  Bool <span id='isClass'>isClass</span><span class='b'>()</span> <span class='b'>{</span> !isMixin &amp;&amp; !isEnum <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is a mixin type and cannot be instantiated.</span>
  <span class='z'>**</span>
  Bool <span id='isMixin'>isMixin</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Mixin<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is an sys::Enum</span>
  <span class='z'>**</span>
  Bool <span id='isEnum'>isEnum</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Enum<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is an sys::Facet</span>
  <span class='z'>**</span>
  Bool <span id='isFacet'>isFacet</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Facet<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is abstract and cannot be instantiated.  This</span>
  <span class='z'>** method will always return true if the type is a mixin.</span>
  <span class='z'>**</span>
  Bool <span id='isAbstract'>isAbstract</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Abstract<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is const and immutable.</span>
  <span class='z'>**</span>
  Bool <span id='isConst'>isConst</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Const<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is final and cannot be subclassed.</span>
  <span class='z'>**</span>
  Bool <span id='isFinal'>isFinal</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Final<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is this a public scoped class</span>
  <span class='z'>**</span>
  Bool <span id='isPublic'>isPublic</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Public<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is this an internally scoped class</span>
  <span class='z'>**</span>
  Bool <span id='isInternal'>isInternal</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Internal<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is this a compiler generated synthetic class</span>
  <span class='z'>**</span>
  Bool <span id='isSynthetic'>isSynthetic</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Synthetic<span class='b'>)</span> != 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is the entire class implemented in native code?</span>
  <span class='z'>**</span>
  Bool <span id='isNative'>isNative</span><span class='b'>()</span> <span class='b'>{</span> flags.and<span class='b'>(</span>FConst.Native<span class='b'>)</span> != 0 <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Conveniences</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  Bool <span id='isObj'>isObj</span><span class='b'>()</span>     <span class='b'>{</span> qname == <span class='s'>"sys::Obj"</span> <span class='b'>}</span>
  Bool <span id='isBool'>isBool</span><span class='b'>()</span>    <span class='b'>{</span> qname == <span class='s'>"sys::Bool"</span> <span class='b'>}</span>
  Bool <span id='isInt'>isInt</span><span class='b'>()</span>     <span class='b'>{</span> qname == <span class='s'>"sys::Int"</span> <span class='b'>}</span>
  Bool <span id='isFloat'>isFloat</span><span class='b'>()</span>   <span class='b'>{</span> qname == <span class='s'>"sys::Float"</span> <span class='b'>}</span>
  Bool <span id='isDecimal'>isDecimal</span><span class='b'>()</span> <span class='b'>{</span> qname == <span class='s'>"sys::Decimal"</span> <span class='b'>}</span>
  Bool <span id='isRange'>isRange</span><span class='b'>()</span>   <span class='b'>{</span> qname == <span class='s'>"sys::Range"</span> <span class='b'>}</span>
  Bool <span id='isStr'>isStr</span><span class='b'>()</span>     <span class='b'>{</span> qname == <span class='s'>"sys::Str"</span> <span class='b'>}</span>
  Bool <span id='isThis'>isThis</span><span class='b'>()</span>    <span class='b'>{</span> qname == <span class='s'>"sys::This"</span> <span class='b'>}</span>
  Bool <span id='isType'>isType</span><span class='b'>()</span>    <span class='b'>{</span> qname == <span class='s'>"sys::Type"</span> <span class='b'>}</span>
  Bool <span id='isVoid'>isVoid</span><span class='b'>()</span>    <span class='b'>{</span> qname == <span class='s'>"sys::Void"</span> <span class='b'>}</span>
  Bool <span id='isList'>isList</span><span class='b'>()</span>    <span class='b'>{</span> fits<span class='b'>(</span>ns.listType<span class='b'>)</span> <span class='b'>}</span>
  Bool <span id='isMap'>isMap</span><span class='b'>()</span>     <span class='b'>{</span> fits<span class='b'>(</span>ns.mapType<span class='b'>)</span> <span class='b'>}</span>
  Bool <span id='isFunc'>isFunc</span><span class='b'>()</span>    <span class='b'>{</span> fits<span class='b'>(</span>ns.funcType<span class='b'>)</span> <span class='b'>}</span>
  Bool <span id='isNothing'>isNothing</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>this</span> === ns.nothingType <span class='b'>}</span>

  <span class='z'>** Is this a valid type usable anywhere (such as local var)</span>
  <span class='k'>virtual</span> Bool <span id='isValid'>isValid</span><span class='b'>()</span> <span class='b'>{</span> !isVoid &amp;&amp; !isThis <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Is this type ok to use as a const field?  Any const</span>
  <span class='z'>** type fine, plus we allow Obj, List, Map, and Func since</span>
  <span class='z'>** they will implicitly have toImmutable called on them.</span>
  <span class='z'>**</span>
  Bool <span id='isConstFieldType'>isConstFieldType</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>isConst<span class='b'>)</span> <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// these are checked at runtime</span>
    t := deref.toNonNullable
    <span class='k'>if</span> <span class='b'>(</span>t.isObj || t.isList || t.isMap|| t.isFunc<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>true</span>

    <span class='y'>// definitely no way it can be immutable</span>
    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Slots</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Map of the all defined slots, both fields and</span>
  <span class='z'>** methods (including inherited slots).</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Str:CSlot <span id='slots'>slots</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this type contains a slot by the specified name.</span>
  <span class='z'>**</span>
  Bool <span id='hasSlot'>hasSlot</span><span class='b'>(</span>Str name<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> slots.containsKey<span class='b'>(</span>name<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Lookup a slot by name.  If the slot doesn't exist then return null.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CSlot? <span id='slot'>slot</span><span class='b'>(</span>Str name<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> slots<span class='b'>[</span>name<span class='b'>]</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Lookup a field by name (null if method).</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CField? <span id='field'>field</span><span class='b'>(</span>Str name<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> slot<span class='b'>(</span>name<span class='b'>)</span> <span class='k'>as</span> CField <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Lookup a method by name (null if field).</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> CMethod? <span id='method'>method</span><span class='b'>(</span>Str name<span class='b'>)</span> <span class='b'>{</span> <span class='k'>return</span> slot<span class='b'>(</span>name<span class='b'>)</span> <span class='k'>as</span> CMethod <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all defined fields (including inherited fields).</span>
  <span class='z'>**</span>
  CField<span class='b'>[]</span> <span id='fields'>fields</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='b'>(</span>CField<span class='b'>[])</span>slots.vals.findType<span class='b'>(</span>CField#<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all defined methods (including inherited methods).</span>
  <span class='z'>**</span>
  CMethod<span class='b'>[]</span> <span id='methods'>methods</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='b'>(</span>CMethod<span class='b'>[])</span>slots.vals.findType<span class='b'>(</span>CMethod#<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all constructors.</span>
  <span class='z'>**</span>
  CMethod<span class='b'>[]</span> <span id='ctors'>ctors</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> methods.findAll |CMethod m-&gt;Bool| <span class='b'>{</span> <span class='k'>return</span> m.isCtor <span class='b'>}</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get operators lookup structure</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> COperators <span id='operators'>operators</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Facets</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the facet keyed by given type, or null if not defined.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> CFacet? <span id='facet'>facet</span><span class='b'>(</span>Str qname<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return if the given facet is defined.</span>
  <span class='z'>**</span>
  Bool <span id='hasFacet'>hasFacet</span><span class='b'>(</span>Str qname<span class='b'>)</span> <span class='b'>{</span> facet<span class='b'>(</span>qname<span class='b'>)</span> != <span class='k'>null</span> <span class='b'>}</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='CType.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#base'>base</a></li>
  <li style='display: block;'><a href='#bridge'>bridge</a></li>
  <li style='display: block;'><a href='#common'>common</a></li>
  <li class='hidden' style='display: block;'><a href='#commonClass'>commonClass</a></li>
  <li class='hidden' style='display: block;'><a href='#commonExact'>commonExact</a></li>
  <li class='hidden' style='display: block;'><a href='#commonList'>commonList</a></li>
  <li class='hidden' style='display: block;'><a href='#commonMixin'>commonMixin</a></li>
  <li class='hidden' style='display: block;'><a href='#commonParameterized'>commonParameterized</a></li>
  <li style='display: block;'><a href='#ctors'>ctors</a></li>
  <li style='display: block;'><a href='#deref'>deref</a></li>
  <li style='display: block;'><a href='#equals'>equals</a></li>
  <li style='display: block;'><a href='#facet'>facet</a></li>
  <li style='display: block;'><a href='#field'>field</a></li>
  <li style='display: block;'><a href='#fields'>fields</a></li>
  <li style='display: block;'><a href='#fits'>fits</a></li>
  <li style='display: block;'><a href='#fitsAny'>fitsAny</a></li>
  <li style='display: block;'><a href='#flags'>flags</a></li>
  <li style='display: block;'><a href='#foreignInheritance'>foreignInheritance</a></li>
  <li style='display: block;'><a href='#hasFacet'>hasFacet</a></li>
  <li style='display: block;'><a href='#hasSlot'>hasSlot</a></li>
  <li style='display: block;'><a href='#hash'>hash</a></li>
  <li style='display: block;'><a href='#inferredAs'>inferredAs</a></li>
  <li style='display: block;'><a href='#isAbstract'>isAbstract</a></li>
  <li style='display: block;'><a href='#isBool'>isBool</a></li>
  <li style='display: block;'><a href='#isClass'>isClass</a></li>
  <li style='display: block;'><a href='#isConst'>isConst</a></li>
  <li style='display: block;'><a href='#isConstFieldType'>isConstFieldType</a></li>
  <li style='display: block;'><a href='#isDecimal'>isDecimal</a></li>
  <li style='display: block;'><a href='#isEnum'>isEnum</a></li>
  <li style='display: block;'><a href='#isFacet'>isFacet</a></li>
  <li style='display: block;'><a href='#isFinal'>isFinal</a></li>
  <li style='display: block;'><a href='#isFloat'>isFloat</a></li>
  <li style='display: block;'><a href='#isForeign'>isForeign</a></li>
  <li style='display: block;'><a href='#isFunc'>isFunc</a></li>
  <li style='display: block;'><a href='#isGeneric'>isGeneric</a></li>
  <li style='display: block;'><a href='#isGenericParameter'>isGenericParameter</a></li>
  <li style='display: block;'><a href='#isInt'>isInt</a></li>
  <li style='display: block;'><a href='#isInternal'>isInternal</a></li>
  <li style='display: block;'><a href='#isList'>isList</a></li>
  <li style='display: block;'><a href='#isMap'>isMap</a></li>
  <li style='display: block;'><a href='#isMixin'>isMixin</a></li>
  <li style='display: block;'><a href='#isNative'>isNative</a></li>
  <li style='display: block;'><a href='#isNothing'>isNothing</a></li>
  <li style='display: block;'><a href='#isNullable'>isNullable</a></li>
  <li style='display: block;'><a href='#isObj'>isObj</a></li>
  <li style='display: block;'><a href='#isParameterized'>isParameterized</a></li>
  <li style='display: block;'><a href='#isPublic'>isPublic</a></li>
  <li style='display: block;'><a href='#isRange'>isRange</a></li>
  <li style='display: block;'><a href='#isStr'>isStr</a></li>
  <li style='display: block;'><a href='#isSupported'>isSupported</a></li>
  <li style='display: block;'><a href='#isSynthetic'>isSynthetic</a></li>
  <li style='display: block;'><a href='#isThis'>isThis</a></li>
  <li style='display: block;'><a href='#isType'>isType</a></li>
  <li style='display: block;'><a href='#isVal'>isVal</a></li>
  <li style='display: block;'><a href='#isValType'>isValType</a></li>
  <li style='display: block;'><a href='#isValid'>isValid</a></li>
  <li style='display: block;'><a href='#isVoid'>isVoid</a></li>
  <li style='display: block;'><a href='#method'>method</a></li>
  <li style='display: block;'><a href='#methods'>methods</a></li>
  <li style='display: block;'><a href='#mixins'>mixins</a></li>
  <li style='display: block;'><a href='#name'>name</a></li>
  <li style='display: block;'><a href='#ns'>ns</a></li>
  <li style='display: block;'><a href='#operators'>operators</a></li>
  <li style='display: block;'><a href='#parameterizeThis'>parameterizeThis</a></li>
  <li style='display: block;'><a href='#pod'>pod</a></li>
  <li style='display: block;'><a href='#qname'>qname</a></li>
  <li style='display: block;'><a href='#raw'>raw</a></li>
  <li style='display: block;'><a href='#signature'>signature</a></li>
  <li style='display: block;'><a href='#slot'>slot</a></li>
  <li style='display: block;'><a href='#slots'>slots</a></li>
  <li style='display: block;'><a href='#toListOf'>toListOf</a></li>
  <li style='display: block;'><a href='#toNonNullable'>toNonNullable</a></li>
  <li style='display: block;'><a href='#toNullable'>toNullable</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

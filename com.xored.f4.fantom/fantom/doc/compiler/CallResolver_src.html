<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>compiler::CallResolver</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>compiler</a></li>
  <li>&gt;</li>
  <li><a href='CallResolver.html'>CallResolver</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>compiler::CallResolver</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  <a href='CompilerSupport.html'>compiler::CompilerSupport</a>
    compiler::CallResolver</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   15 Sep 05  Brian Frank  Creation</span>
<span class='y'>//    5 Sep 06  Brian Frank  Ported from Java to Fan</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** CallResolver handles the process of resolving a CallExpr or</span>
<span class='z'>** UnknownVarExpr to a method call or a field access.</span>
<span class='z'>**</span>
<span class='k'>class</span> CallResolver : CompilerSupport
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Construction</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Construct with NameExpr (base class of CallExpr and UnknownVarExpr)</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Compiler compiler, TypeDef? curType, MethodDef? curMethod, NameExpr expr<span class='b'>)</span>
    : <span class='k'>super</span><span class='b'>(</span>compiler<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.curType   = curType
    <span class='k'>this</span>.curMethod = curMethod
    <span class='k'>this</span>.expr      = expr
    <span class='k'>this</span>.loc       = expr.loc
    <span class='k'>this</span>.target    = expr.target
    <span class='k'>this</span>.name      = expr.name

    call := expr <span class='k'>as</span> CallExpr
    <span class='k'>if</span> <span class='b'>(</span>call != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.isVar = <span class='k'>false</span>
      <span class='k'>this</span>.args  = call.args
      <span class='k'>this</span>.found = call.method
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      <span class='k'>this</span>.isVar = <span class='k'>true</span>
      <span class='k'>this</span>.args  = Expr<span class='b'>[</span>,<span class='b'>]</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Resolve</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve into a method call or field access</span>
  <span class='z'>**</span>
  Expr <span id='resolve'>resolve</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isStaticLiteral<span class='b'>)</span> <span class='k'>return</span> result
      resolveBase
      find
      <span class='k'>if</span> <span class='b'>(</span>result != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> result
      insertImplicitThisOrIt
      resolveToExpr
      inferClosureType
      resolveForeign
      constantFolding
      castForThisType
      safeToNullable
      ffiCoercion
      <span class='k'>return</span> result
    <span class='b'>}</span>
    <span class='k'>catch</span> <span class='b'>(</span>CompilerErr err<span class='b'>)</span>
    <span class='b'>{</span>
      expr.ctype = ns.error
      <span class='k'>return</span> expr
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Static Literal</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a standalone name without a base target</span>
  <span class='z'>** such as "Foo" and the name maps to a type name, then</span>
  <span class='z'>** this is a type literal.</span>
  <span class='z'>**</span>
  Bool <span id='isStaticLiteral'>isStaticLiteral</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>target == <span class='k'>null</span> &amp;&amp; isVar<span class='b'>)</span>
    <span class='b'>{</span>
      stypes := curType.unit.importedTypes<span class='b'>[</span>name<span class='b'>]</span>

      <span class='y'>// if more then, one first try to exclude those internal to other pods</span>
      <span class='k'>if</span> <span class='b'>(</span>stypes != <span class='k'>null</span> &amp;&amp; stypes.size &gt; 1<span class='b'>)</span>
        stypes.exclude |t| <span class='b'>{</span> t.isInternal &amp;&amp; t.pod.name != compiler.pod.name <span class='b'>}</span>

      <span class='k'>if</span> <span class='b'>(</span>stypes != <span class='k'>null</span> &amp;&amp; !stypes.isEmpty<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>stypes.size &gt; 1<span class='b'>)</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Ambiguous type: "</span> + stypes.join<span class='b'>(</span><span class='s'>", "</span><span class='b'>)</span>, loc<span class='b'>)</span>
        <span class='k'>else</span>
          result = StaticTargetExpr<span class='b'>(</span>loc, stypes.first<span class='b'>)</span>
        <span class='k'>return</span> <span class='k'>true</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>return</span> <span class='k'>false</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Resolve Base</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Resolve the base type which defines the slot we are calling.</span>
  <span class='z'>**</span>
  Void <span id='resolveBase'>resolveBase</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// if target unspecified, then assume a slot on the current</span>
    <span class='y'>// class otherwise the slot must be on the target type</span>
    <span class='k'>if</span> <span class='b'>(</span>target == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// if we are in a closure - then base is the enclosing class;</span>
      <span class='y'>// if closure is it-block when we need to keep track of it too</span>
      <span class='k'>if</span> <span class='b'>(</span>curType.isClosure<span class='b'>)</span>
      <span class='b'>{</span>
        base = curType.closure.enclosingType
        <span class='k'>if</span> <span class='b'>(</span>curType.closure.isItBlock<span class='b'>)</span> baseIt = curType.closure.itType
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        base = curType
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      base = target.ctype
    <span class='b'>}</span>

    <span class='y'>// if base is the error type, then we already logged an error</span>
    <span class='y'>// trying to resolve the target and it's pointless to continue</span>
    <span class='k'>if</span> <span class='b'>(</span>base === ns.error<span class='b'>)</span> <span class='k'>throw</span> CompilerErr<span class='b'>(</span><span class='s'>"ignore"</span>, loc, <span class='k'>null</span><span class='b'>)</span>

    <span class='y'>// sanity check</span>
    <span class='k'>if</span> <span class='b'>(</span>base == <span class='k'>null</span><span class='b'>)</span> <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Internal error"</span>, loc<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Find</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Find the method or field with the specified name.</span>
  <span class='z'>**</span>
  Void <span id='find'>find</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// if already "found", then skip this step</span>
    <span class='k'>if</span> <span class='b'>(</span>found != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// look it up in base type</span>
    found = findOn<span class='b'>(</span>base<span class='b'>)</span>

    <span class='y'>// if we have an it in scope, then also attempt to resolve against it</span>
    <span class='k'>if</span> <span class='b'>(</span>baseIt != <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      foundIt := findOn<span class='b'>(</span>baseIt<span class='b'>)</span>

      <span class='y'>// if we found a match on both base and it, that is an error</span>
      <span class='k'>if</span> <span class='b'>(</span>isAmbiguous<span class='b'>(</span>found, foundIt<span class='b'>))</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Ambiguous slot '$name' on both 'this' ($base) and 'it' ($baseIt)"</span>, loc<span class='b'>)</span>

      <span class='y'>// resolved against implicit it</span>
      <span class='k'>if</span> <span class='b'>(</span>foundIt != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        found = foundIt
        foundOnIt = <span class='k'>true</span>
      <span class='b'>}</span>
    <span class='b'>}</span>

    <span class='y'>// if still not found, then error</span>
    <span class='k'>if</span> <span class='b'>(</span>found == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>isVar<span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>if</span> <span class='b'>(</span>target == <span class='k'>null</span><span class='b'>)</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Unknown variable '$name'"</span>, loc<span class='b'>)</span>
        <span class='k'>else</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Unknown slot '$errSig'"</span>, loc<span class='b'>)</span>
      <span class='b'>}</span>
      <span class='k'>else</span>
      <span class='b'>{</span>
        ct := target <span class='k'>as</span> CallExpr
        <span class='k'>if</span> <span class='b'>(</span>name == <span class='s'>"add"</span> &amp;&amp; ct != <span class='k'>null</span> &amp;&amp; ct.target?.id === ExprId.itExpr &amp;&amp; ct.method != <span class='k'>null</span><span class='b'>)</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"'$ct.method.qname' must return This"</span>, loc<span class='b'>)</span>
        <span class='k'>else</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Unknown method '$errSig'"</span>, loc<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> CSlot? <span id='findOn'>findOn</span><span class='b'>(</span>CType base<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// if base is the error type, short circuit</span>
    <span class='k'>if</span> <span class='b'>(</span>base === ns.error<span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>

    <span class='y'>// attempt to resolve the slot by name</span>
    found := base.slot<span class='b'>(</span>name<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>found == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>

    <span class='y'>// if the resolved slot is on a FFI type then we have to</span>
    <span class='y'>// delegate back to bridge because we might support both methods</span>
    <span class='y'>// and fields overloaded by the same name</span>
    <span class='k'>if</span> <span class='b'>(</span>found.isForeign<span class='b'>)</span>
      found = found.parent.bridge.resolveSlotAccess<span class='b'>(</span>base, name, isVar<span class='b'>)</span>

    <span class='y'>// if we resolve a method call against a field that is an error,</span>
    <span class='y'>// unless the field is a function in which case this is sugar</span>
    <span class='y'>// for field.call(...)</span>
    <span class='k'>if</span> <span class='b'>(</span>found <span class='k'>is</span> CField &amp;&amp; !isVar<span class='b'>)</span>
    <span class='b'>{</span>
      field := <span class='b'>(</span>CField<span class='b'>)</span>found
      <span class='k'>if</span> <span class='b'>(</span>field.fieldType.isFunc<span class='b'>)</span>
        isFuncFieldCall = <span class='k'>true</span>
      <span class='k'>else</span>
        <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Expected method, not field '$errSig'"</span>, loc<span class='b'>)</span>
    <span class='b'>}</span>

    <span class='k'>return</span> found
  <span class='b'>}</span>

  <span class='k'>private</span> Bool <span id='isAmbiguous'>isAmbiguous</span><span class='b'>(</span>CSlot? onBase, CSlot? onIt<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// unless we found on both base and baseIt, it is not ambiguous</span>
    <span class='k'>if</span> <span class='b'>(</span>onBase == <span class='k'>null</span> || onIt == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// if they are both the same static method, it doesn't matter</span>
    <span class='k'>if</span> <span class='b'>(</span>onBase.qname == onIt.qname &amp;&amp; onBase.isStatic<span class='b'>)</span> <span class='k'>return</span> <span class='k'>false</span>

    <span class='y'>// if we are calling an instance slot in a static context,</span>
    <span class='y'>// then we can assume that we are binding to it</span>
    <span class='k'>if</span> <span class='b'>(</span>!onBase.isStatic &amp;&amp; !onIt.isStatic &amp;&amp; curType.closure.enclosingSlot.isStatic<span class='b'>)</span>
      <span class='k'>return</span> <span class='k'>false</span>

    <span class='k'>return</span> <span class='k'>true</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Str <span id='errSig'>errSig</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> <span class='s'>"${base.qname}.${name}"</span> <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Implicit This</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If the call has no explicit target, and is a instance field</span>
  <span class='z'>** or method, then we need to insert an implicit this or it.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='insertImplicitThisOrIt'>insertImplicitThisOrIt</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>target != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>found.isStatic || found.isCtor<span class='b'>)</span> <span class='k'>return</span>
    <span class='k'>if</span> <span class='b'>(</span>curMethod.isStatic<span class='b'>)</span> <span class='k'>return</span>

    <span class='k'>if</span> <span class='b'>(</span>foundOnIt<span class='b'>)</span>
    <span class='b'>{</span>
      target = ItExpr<span class='b'>(</span>loc, baseIt<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span> <span class='k'>if</span> <span class='b'>(</span>curType.isClosure<span class='b'>)</span>
    <span class='b'>{</span>
      closure := curType.closure
      <span class='k'>if</span> <span class='b'>(</span>!closure.enclosingSlot.isStatic<span class='b'>)</span>
        target = FieldExpr<span class='b'>(</span>loc, ThisExpr<span class='b'>(</span>loc, closure.enclosingType<span class='b'>)</span>, closure.outerThisField<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      target = ThisExpr<span class='b'>(</span>loc, curType<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Resolve Expr Type</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Compute the expression type the call itself (what gets left on the stack).</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='resolveToExpr'>resolveToExpr</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>found <span class='k'>is</span> CField<span class='b'>)</span>
    <span class='b'>{</span>
      result = resolveToFieldExpr
      <span class='k'>if</span> <span class='b'>(</span>isFuncFieldCall<span class='b'>)</span>
      <span class='b'>{</span>
        callMethod := <span class='b'>((</span>CField<span class='b'>)</span>found<span class='b'>)</span>.fieldType.method<span class='b'>(</span><span class='s'>"call"</span><span class='b'>)</span>
        result = CallExpr.makeWithMethod<span class='b'>(</span>loc, result, callMethod, args<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>else</span>
    <span class='b'>{</span>
      result = resolveToCallExpr
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> CallExpr <span id='resolveToCallExpr'>resolveToCallExpr</span><span class='b'>()</span>
  <span class='b'>{</span>
    method := <span class='b'>(</span>CMethod<span class='b'>)</span>found

    call := expr <span class='k'>as</span> CallExpr
    <span class='k'>if</span> <span class='b'>(</span>call == <span class='k'>null</span><span class='b'>)</span>
    <span class='b'>{</span>
      call = CallExpr<span class='b'>(</span>loc<span class='b'>)</span>
      call.name   = name
      call.args   = args
    <span class='b'>}</span>
    call.target   = target
    call.isSafe   = expr.isSafe
    call.noParens = isVar

    call.method = method
    <span class='k'>if</span> <span class='b'>(</span>method.isCtor<span class='b'>)</span>
      call.ctype = method.parent
    <span class='k'>else</span>
      call.ctype = method.returnType

    <span class='k'>return</span> call
  <span class='b'>}</span>

  <span class='k'>private</span> FieldExpr <span id='resolveToFieldExpr'>resolveToFieldExpr</span><span class='b'>()</span>
  <span class='b'>{</span>
    f := <span class='b'>(</span>CField<span class='b'>)</span>found

    field := FieldExpr<span class='b'>(</span>loc<span class='b'>)</span>
    field.target = target
    field.name   = name
    field.field  = f
    field.ctype  = f.fieldType
    field.isSafe = expr.isSafe

    <span class='k'>return</span> field
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Infer Closure Type</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If the last argument to the resolved call is a closure,</span>
  <span class='z'>** then use the method to infer the function type</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='inferClosureType'>inferClosureType</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>result <span class='k'>is</span> CallExpr<span class='b'>)</span>
    <span class='b'>{</span>
      base := foundOnIt ? <span class='k'>this</span>.baseIt : <span class='k'>this</span>.base
      result = inferClosureTypeFromCall<span class='b'>(</span><span class='k'>this</span>, result, base<span class='b'>)</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** If the last argument to the resolved call is a closure,</span>
  <span class='z'>** then use the method to infer the function type.  If the</span>
  <span class='z'>** last arg is a closure, but the call doesn't take a closure,</span>
  <span class='z'>** then translate into an implicit call to Obj.with</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Expr <span id='inferClosureTypeFromCall'>inferClosureTypeFromCall</span><span class='b'>(</span>CompilerSupport support, CallExpr call, CType base<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='y'>// check if last argument is closure</span>
    c := call.args.last <span class='k'>as</span> ClosureExpr
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> call

    <span class='y'>// if the resolved slot is a method where the last param</span>
    <span class='y'>// is expected to be a function type, then use that to</span>
    <span class='y'>// infer the type signature of the closure</span>
    m := call.method
    lastParam := m.params.last?.paramType?.deref?.toNonNullable <span class='k'>as</span> FuncType
    <span class='k'>if</span> <span class='b'>(</span>lastParam != <span class='k'>null</span> &amp;&amp; call.args.size == m.params.size &amp;&amp;
        c.signature.params.size &lt;= lastParam.params.size<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>call.method.name == <span class='s'>"with"</span><span class='b'>)</span>
        lastParam = FuncType.makeItBlock<span class='b'>(</span>base<span class='b'>)</span>
      <span class='k'>else</span>
        lastParam = lastParam.parameterizeThis<span class='b'>(</span>base<span class='b'>)</span>
      c.setInferredSignature<span class='b'>(</span>lastParam<span class='b'>)</span>
      <span class='k'>return</span> call
    <span class='b'>}</span>

    <span class='y'>// otherwise if the closure is an it-block, we infer</span>
    <span class='y'>// its type to be the result of the target expression</span>
    <span class='k'>if</span> <span class='b'>(</span>c.isItBlock<span class='b'>)</span>
    <span class='b'>{</span>
      <span class='y'>// if call is This, switch it to base (passes thru to toWith)</span>
      <span class='k'>if</span> <span class='b'>(</span>call.ctype.isThis<span class='b'>)</span> call.ctype = base

      <span class='y'>// can't chain it-block if call returns Void</span>
      <span class='k'>if</span> <span class='b'>(</span>call.ctype.isVoid<span class='b'>)</span>
      <span class='b'>{</span>
        support.err<span class='b'>(</span><span class='s'>"Cannot apply it-block to Void expr"</span>, call.loc<span class='b'>)</span>
        <span class='k'>return</span> call
      <span class='b'>}</span>

      <span class='y'>// remove the function parameter and turn this into:</span>
      <span class='y'>//  call(args).toWith(c)</span>
      call.args.removeAt<span class='b'>(</span>-1<span class='b'>)</span>
      <span class='k'>return</span> c.toWith<span class='b'>(</span>call<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>return</span> call
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// FFI</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If we have a FFI call, then give the foreign bridge a chance</span>
  <span class='z'>** to resolve the method and deal with method overloading.  Note</span>
  <span class='z'>** at this point we've already resolved the call by name to *some*</span>
  <span class='z'>** method (in the find step).  But this callback gives the bridge</span>
  <span class='z'>** a chance to resolve to the *correct* overloaded method.  We need</span>
  <span class='z'>** to this during ResolveExpr in order to infer local variables</span>
  <span class='z'>** correctly.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='resolveForeign'>resolveForeign</span><span class='b'>()</span>
  <span class='b'>{</span>
    bridge := found.usesBridge
    <span class='k'>if</span> <span class='b'>(</span>bridge != <span class='k'>null</span> &amp;&amp; result <span class='k'>is</span> CallExpr<span class='b'>)</span>
      result = bridge.resolveCall<span class='b'>(</span>result<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constant Folding</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If the epxression is a call, check for constant folding.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='constantFolding'>constantFolding</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// only do const folding on method calls (which inculdes shortcut ops)</span>
    call := result <span class='k'>as</span> CallExpr
    <span class='k'>if</span> <span class='b'>(</span>call == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// skip constant folding for testSys</span>
    <span class='k'>if</span> <span class='b'>(</span>curType != <span class='k'>null</span> &amp;&amp; compiler.pod.name == <span class='s'>"testSys"</span><span class='b'>)</span> <span class='k'>return</span>

    result = ConstantFolder<span class='b'>(</span>compiler<span class='b'>)</span>.fold<span class='b'>(</span>call<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Cast for This Type</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If the epxression is a call which returns sys::This,</span>
  <span class='z'>** then we need to insert an implicit cast.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='castForThisType'>castForThisType</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='y'>// only care about calls that return This</span>
    <span class='k'>if</span> <span class='b'>(</span>!result.ctype.isThis<span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// check that we are calling a method</span>
    method := found <span class='k'>as</span> CMethod
    <span class='k'>if</span> <span class='b'>(</span>method == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span>

    <span class='y'>// the result of a method which returns This</span>
    <span class='y'>// is always the base target type - if we aren't</span>
    <span class='y'>// calling against the original declaring type</span>
    <span class='y'>// then we also need an implicit cast operation</span>
    base := foundOnIt ? <span class='k'>this</span>.baseIt : <span class='k'>this</span>.base
    result.ctype = base
    <span class='k'>if</span> <span class='b'>(</span>method.inheritedReturnType != base<span class='b'>)</span>
      result = TypeCheckExpr.coerce<span class='b'>(</span>result, base<span class='b'>)</span> <span class='b'>{</span> from = method.inheritedReturnType <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Safe to Nullable</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If the epxression is a safe call using "?.", then</span>
  <span class='z'>** the resulting expression type is nullable.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='safeToNullable'>safeToNullable</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>expr.isSafe<span class='b'>)</span>
    <span class='b'>{</span>
      result.ctype = result.ctype.toNullable
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// FFI Coercion</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** If this field access or method call returns a type which</span>
  <span class='z'>** isn't directly represented in the Fantom type system, then</span>
  <span class='z'>** implicitly coerce it</span>
  <span class='z'>**</span>
  <span class='k'>private</span> Void <span id='ffiCoercion'>ffiCoercion</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>result.ctype.isForeign<span class='b'>)</span>
    <span class='b'>{</span>
      foreign := result.ctype
      inferred := foreign.inferredAs
      <span class='k'>if</span> <span class='b'>(</span>foreign !== inferred<span class='b'>)</span>
      <span class='b'>{</span>
        result = foreign.bridge.coerce<span class='b'>(</span>result, inferred<span class='b'>)</span> |-&gt;|
        <span class='b'>{</span>
          <span class='k'>throw</span> err<span class='b'>(</span><span class='s'>"Cannot coerce call return to Fantom type"</span>, loc<span class='b'>)</span>
        <span class='b'>}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  TypeDef? <span id='curType'>curType</span>     <span class='y'>// current type of scope</span>
  MethodDef? <span id='curMethod'>curMethod</span> <span class='y'>// current method of scope</span>
  NameExpr <span id='expr'>expr</span>        <span class='y'>// original expression being resolved</span>
  Loc <span id='loc'>loc</span>              <span class='y'>// location of original expression</span>
  Expr? <span id='target'>target</span>         <span class='y'>// target base or null</span>
  Str <span id='name'>name</span>             <span class='y'>// slot name to resolve</span>
  Bool <span id='isVar'>isVar</span>           <span class='y'>// are we resolving simple variable</span>
  Bool <span id='isFuncFieldCall'>isFuncFieldCall</span> <span class='y'>// is this a field.call(...) on func field</span>
  Expr<span class='b'>[]</span> <span id='args'>args</span>          <span class='y'>// arguments or null if simple variable</span>
  CType? <span id='base'>base</span>          <span class='y'>// resolveBase()</span>
  CType? <span id='baseIt'>baseIt</span>        <span class='y'>// resolveBase()</span>
  CSlot? <span id='found'>found</span>         <span class='y'>// find()</span>
  Bool <span id='foundOnIt'>foundOnIt</span>       <span class='y'>// was find() resolved against it</span>
  Expr? <span id='result'>result</span>         <span class='y'>// resolveToExpr()</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='CallResolver.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#args'>args</a></li>
  <li style='display: block;'><a href='#base'>base</a></li>
  <li style='display: block;'><a href='#baseIt'>baseIt</a></li>
  <li class='hidden' style='display: block;'><a href='#castForThisType'>castForThisType</a></li>
  <li class='hidden' style='display: block;'><a href='#constantFolding'>constantFolding</a></li>
  <li style='display: block;'><a href='#curMethod'>curMethod</a></li>
  <li style='display: block;'><a href='#curType'>curType</a></li>
  <li class='hidden' style='display: block;'><a href='#errSig'>errSig</a></li>
  <li style='display: block;'><a href='#expr'>expr</a></li>
  <li class='hidden' style='display: block;'><a href='#ffiCoercion'>ffiCoercion</a></li>
  <li style='display: block;'><a href='#find'>find</a></li>
  <li class='hidden' style='display: block;'><a href='#findOn'>findOn</a></li>
  <li style='display: block;'><a href='#found'>found</a></li>
  <li style='display: block;'><a href='#foundOnIt'>foundOnIt</a></li>
  <li class='hidden' style='display: block;'><a href='#inferClosureType'>inferClosureType</a></li>
  <li style='display: block;'><a href='#inferClosureTypeFromCall'>inferClosureTypeFromCall</a></li>
  <li class='hidden' style='display: block;'><a href='#insertImplicitThisOrIt'>insertImplicitThisOrIt</a></li>
  <li class='hidden' style='display: block;'><a href='#isAmbiguous'>isAmbiguous</a></li>
  <li style='display: block;'><a href='#isFuncFieldCall'>isFuncFieldCall</a></li>
  <li style='display: block;'><a href='#isStaticLiteral'>isStaticLiteral</a></li>
  <li style='display: block;'><a href='#isVar'>isVar</a></li>
  <li style='display: block;'><a href='#loc'>loc</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#name'>name</a></li>
  <li style='display: block;'><a href='#resolve'>resolve</a></li>
  <li style='display: block;'><a href='#resolveBase'>resolveBase</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveForeign'>resolveForeign</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveToCallExpr'>resolveToCallExpr</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveToExpr'>resolveToExpr</a></li>
  <li class='hidden' style='display: block;'><a href='#resolveToFieldExpr'>resolveToFieldExpr</a></li>
  <li style='display: block;'><a href='#result'>result</a></li>
  <li class='hidden' style='display: block;'><a href='#safeToNullable'>safeToNullable</a></li>
  <li style='display: block;'><a href='#target'>target</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
compiler 1.0.56
[11-Nov-2010 Thu 10:08:17AM EST]
</p>
</div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Naming</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Naming.html'>Naming</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Actors.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Actors.html'>Actors</a></div>
<div class='next'><a href='Logging.html'>Logging</a> <a href='Logging.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Naming</h1>

<h1 id='overview'>Overview </h1>

<p>A "name" is a set of conventions and rules for using strings as identifiers. Good names are typically human readable, although that isn't necessarily required.  Fantom provides a unified naming design based on the <code><a href='../sys/Uri.html'>sys::Uri</a></code> class. Uris are a good choice for naming because they provide:</p>

<ul>
<li>Ability to transcribe the name into an ASCII string (with appropriate escaping)</li>

<li>Well defined model for plugging in "protocol" (scheme) handlers</li>

<li>Well defined model for path hierarchies</li>

<li>Well defined model for name/value pairs via queries</li>

<li>Well defined rules for relativization and normalization</li>

<li>Uris map cleanly to web based applications</li>

<li>Uris are widely supported in alternate languages and platforms</li>
</ul>

<h1 id='resolving'>Resolving Uris </h1>

<p>In Fantom anything of interest we might wish to identify with a name is assigned a Uri.  We resolve Uris to <code>sys::Obj</code> instances.  The actual object type is dependent on the Uri.  For example all "file:" Uris will resolve to a <code>sys::File</code>.  Resolving a Uri is done via the <code><a href='../sys/Uri.html#get'>Uri.get</a></code> method:</p>

<pre>File f := `file:/dir/file.txt`.get</pre>

<p>If the file cannot be resolved, then UnresolvedErr is thrown.  You can pass false for the <code>checked</code> parameter to return null if the Uri cannot be resolved.</p>

<p>The default behavior of <code>Uri.get</code> on a relative Uri (null scheme) is to throw UnresolvedErr.  But you can pass in optional base object.  If the Uri is relative, then we attempt to resolve the base object's uri via the dynamic call <code>base->uri</code>.  If the base's uri is absolute, then resolve we <code>base->uri + uri</code>:</p>

<pre>base := `file:/dir/`.get
`file.txt`.get(base)  =>  resolves to `file:/dir/file.txt`</pre>

<h1 id='uriSchemes'>Uri Schemes </h1>

<p>The <code><a href='../sys/UriScheme.html'>sys::UriScheme</a></code> class is used to plug in handling for new Uri schemes.  The standard fan runtime provides support for the following schemes:</p>

<ul>
<li><strong>fan</strong>: resolves to the objects in the Fantom namespace (discussed below)</li>

<li><strong>file</strong>: resolves to <code>File</code> instances on the local file system</li>

<li><strong>http</strong>: not done yet, but coming soon...</li>

<li><strong>flux</strong>: application specific uris for <a href='../docTools/Flux.html'>flux</a> (like "about:" in Firefox)</li>
</ul>

<p>You can plug in your own scheme handling by subclassing <code>UriScheme</code>:</p>

<pre>const class CustomScheme : UriScheme
{
  override Obj? get(Uri uri, Obj? base) { ... }
}</pre>

<p>You override the <code>get</code> method to implement uri to object resolution.  To register your scheme, define an <a href='Env.html#index'>indexed prop</a> formatted as:</p>

<pre>sys.uriScheme.{scheme}={qname}</pre>

<p>Where scheme is the lower case scheme name and qname is the qualified name of your scheme type.  Indexed props are defined your build script, for example:</p>

<pre>index = ["sys.uriScheme.fan": "sys::FanScheme"]</pre>

<h1 id='fanScheme'>Fan Scheme </h1>

<p>The Fantom runtime includes support for the "fan:" scheme which is used to identify objects related to the Fantom namespace:</p>

<pre>fan://pod                =>  sys::Pod
fan://pod/Type           =>  sys::Type
fan://pod/Type#slot      =>  sys::Slot (Field or Method)
fan://pod/dir/file.txt   =>  sys:Pod.file (resource file)</pre>
<div class='prevNext'>
<div class='prev'><a href='Actors.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Actors.html'>Actors</a></div>
<div class='next'><a href='Logging.html'>Logging</a> <a href='Logging.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#resolving'>Resolving Uris </a></li><li><a href='#uriSchemes'>Uri Schemes </a></li><li><a href='#fanScheme'>Fan Scheme </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

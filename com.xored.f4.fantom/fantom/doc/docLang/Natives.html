<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Natives</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Natives.html'>Natives</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='DotnetFFI.html'><img src='../go-previous.png' alt='prev' /></a> <a href='DotnetFFI.html'>Dotnet FFI</a></div>
<div class='next'><a href='JavaScript.html'>JavaScript</a> <a href='JavaScript.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Natives</h1>

<h1>Overview</h1>

<p>Native classes, methods, and fields are used to implement Fantom in the native language of the runtime platform.  For example a native method would be implemented in Java for the JVM, in C# for the CLR, and JavaScript for browsers.  Natives are the glue code for portable libraries such as <code>inet</code> and <code>fwt</code>.</p>

<p>Here is a quick check-list for when and when not to write native code:</p>

<ol style='list-style-type:decimal'>
<li>If possible then the best solution is to write your code in 100% Fantom; then it is portable across any platform</li>

<li>If you don't care about portability, then use a FFI to call out to a native library - see <a href='JavaFFI.html'>JavaFFI</a> and <a href='DotnetFFI.html'>DotnetFFI</a>.</li>

<li>If you need to call out native APIs, but still wish your Fantom pod to be portable across multiple platforms then use natives</li>
</ol>

<p>When writing native code, refer to the FFI documentation for how to map Fantom types to their native platform types.  For example see <a href='JavaFFI.html#summary'>Java FFI</a> to map between Fantom and Java types.</p>

<h1>Native Classes</h1>

<p>A native class is one where the entire implementation is coded up in the native language.  In general the native code must look exactly like what the compiler/runtime would emit.  The <code>sys</code> pod is implemented entirely as native classes which makes it a great place to look for examples in Java, C#, and JavaScript.</p>

<p>A native class is indicated with the <code>native</code> keyword in the class header:</p>

<pre>native class Foo
{
  new make(Str arg) {}
  Int add(Int a, Int b)
  Str? a
  const Str b := "const"
}</pre>

<p>All methods are assumed to be native and must not have a body.  There must be an implementation class for each platform.  Here is what the Java implementation would look like:</p>

<pre>class Foo extends FanObj
{
  // constructor factory called by Foo.make
  public static Foo make(String arg)
  {
    Foo self = new Foo();
    make$(self, arg);
    return self;
  }

  // constructor implementation called by subclasses
  public static void make$(Foo self, Str arg) {}

  // boiler plate for reflection
  public Type typeof()
  {
    if (type == null) type = Type.find("mypod::Foo");
    return type;
  }
  private static Type type;

  // methods
  public long add(long a, long b) { return a + b; }

  // mutable field
  public String a() { return a; }
  public void a(String it) { a = it; }
  private String a;

  // const field
  public String b = "const";
}</pre>

<h1>Native Peers</h1>

<p>The general design for classes with native methods and fields is to create a peer class for each Fantom type.  These peers may be a singleton shared by all Fantom instances or you may use a peer instance per Fantom instance.  Note that peers are not used with native classes.</p>

<p>Any class which defines a native slot must declare a peer class:</p>

<pre>// Fantom code
class Foo
{
  native Int add(Int a, Int b)
}

// Java peer
package fan.mypod;
public class FooPeer
{
  public static FooPeer make(Foo self) { return new FooPeer(); }
  public long add(Foo self, long a, long b) { return a + b; }
}

// C# peer
namespace Fan.Mypod
{
  public class FooPeer
  {
    public static FooPeer make(Foo self) { return new FooPeer(); }
    public long add(Foo self, long a, long b) { return a + b; }
  }
}

// JavaScript peer
fan.mypod.FooPeer = fan.sys.Obj.$extend(fan.sys.Obj);
fan.mypod.FooPeer.prototype.$ctor = function(self) {}
fan.mypod.FooPeer.prototype.add = function(self, a, b) { return a + b; }</pre>

<p>The peer is always accessible from the Fantom instance via a built-in field called <code>peer</code>.  When creating class hieararchies with natives, it is up your peer factory to override the peer fields of super classes:</p>

<pre>public static FooPeer make(Foo t)
{
  FooPeer peer = new FooPeer();
  ((FooBaseClass)t).peer = peer; // override base class's peer field
  return peer;
}</pre>

<h1 id='methods'>Native Methods </h1>

<p>Native methods are always routed to the peer:</p>

<pre>// Fantom
class Foo
{
  native Str a(Bool x)
  static native Void b(Int x)
}

// Java or C#
class FooPeer
{
  public static FooPeer make(Foo self) { return new FooPeer(); }

  // instance methods always take implicit self
  public String a(Foo self, boolean x) { return "a"; }

  // static methods are just normal statics with matching signatures
  public static void b(long x) {}
}

// JavaScript
fan.mypod.FooPeer.prototype.a = function(self, x) { return "a"; }
fan.mypod.FooPeer.b = function(x) {}</pre>

<p>All non-static methods and fields will pass the Fantom instance as an implicit first argument.  This lets you use a singleton peer for all instances.  Typically you will only allocate a peer instance if you wish to manage state on the peer.</p>

<h1 id='fields'>Native Fields </h1>

<p>Native fields are similar to abstract fields in that they generate a getter and setter, but no actual storage.  The emit process will route the Fantom getter/setter to the peer class:</p>

<pre>// Fantom
class Foo
{
  native Str? f
}

// Java
class FooPeer
{
  public static FooPeer make(Foo self) { return new FooPeer(); }
  public String f(Foo t) { return f; }
  public void f(Foo t, String v) { f = v; }
  String f;
}

// C#
class FooPeer
{
  public static FooPeer make(Foo self) { return new FooPeer(); }
  public string f(Foo t) { return m_f; }
  public void f(Foo t, String v) { m_f = v; }
  string m_f;
}

// JavaScript
fan.mypod.FooPeer.prototype.m_f = "";
fan.mypod.FooPeer.prototype.f   = function(t) { return this.m_f; }
fan.mypod.FooPeer.prototype.f$  = function(t, v) { this.m_f = v; }</pre>

<p>Native fields can be virtual or override a superclass, but cannot be const, static, or abstract.</p>
<div class='prevNext'>
<div class='prev'><a href='DotnetFFI.html'><img src='../go-previous.png' alt='prev' /></a> <a href='DotnetFFI.html'>Dotnet FFI</a></div>
<div class='next'><a href='JavaScript.html'>JavaScript</a> <a href='JavaScript.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li>Overview</li><li>Native Classes</li><li>Native Peers</li><li><a href='#methods'>Native Methods </a></li><li><a href='#fields'>Native Fields </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

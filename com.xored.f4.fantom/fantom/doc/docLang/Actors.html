<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Actors</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Actors.html'>Actors</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Concurrency.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Concurrency.html'>Concurrency</a></div>
<div class='next'><a href='Naming.html'>Naming</a> <a href='Naming.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Actors</h1>

<h1 id='overview'>Overview </h1>

<p>Fantom includes an <a href='http://en.wikipedia.org/wiki/Actor_model'>actor framework</a> for concurrency.  <code><a href='../concurrent/Actor.html'>Actors</a></code> are light weight objects which asynchronously process work on a background thread.  Actors are given work by sending them asynchronous message.  Actor's then process those messages on background threads controlled by an <a href='#pools'>ActorPool</a>.</p>

<h1 id='actors'>Actors </h1>

<p>The <code><a href='../concurrent/Actor.html'>Actor</a></code> class is used to define new actors.  All actors are constructed within an <a href='#pools'>ActorPool</a> which defines how the actor is executed.</p>

<p>Actors may define their receive behavior in one of two ways:</p>

<ol style='list-style-type:decimal'>
<li>Pass a function to the Actor's constructor</li>

<li>Subclass <code>Actor</code> and override <code><a href='../concurrent/Actor.html#receive'>receive</a></code></li>
</ol>

<p>Here are two simple examples of an actor which receives an Int message and returns the increment:</p>

<pre>// pass receive to constructor as a closure function
a := Actor(pool) |Int msg->Int| { msg + 1 }

// subclass and override receive
const class IncrActor : Actor
{
  new make(ActorPool p) : super(p) {}
  override Obj? receive(Obj? msg) { msg->increment }
}</pre>

<p>An actor is guaranteed to receive its messages atomically - it is never scheduled on multiple threads concurrently.  However, an actor is not guaranteed to receive all of its messages on the same thread over time.  For example if messages A, B, and C are sent to an actor, the runtime may use three different threads to process those messages.  But the actor is guaranteed to process the messages serially one after the other.</p>

<h1 id='locals'>Actor Locals </h1>

<p>Actors are <a href='Classes.html#const'>const classes</a> which means they must be immutable.  This lets you pass actor references between actors, but you can't maintain any mutable state in the actor's fields. Instead you can store the actor's "mutable world state" in <code><a href='../concurrent/Actor.html#locals'>Actor.locals</a></code>.  Actor locals is a string/object map which works like a thread local - a unique map is used for every actor.  To prevent naming collisions, you should prefix your map keys with your pod name:</p>

<pre>// store a actor local
Actor.locals["acme.global"] = "hum bug"

// get a thread local
Actor.locals["acme.global"]</pre>

<p>For example to build an actor which maintains a counter every time it receives a message:</p>

<pre>pool := ActorPool()
a := Actor(pool) |msg|
{
  count := 1 + Actor.locals.get("count", 0)
  Actor.locals["count"] = count
  return count
}

100.times { a.send("ignored") }
echo("Count is now " + a.send("ignored").get)</pre>

<p>Note that in this example, the actor ignores the messages sent to it, so it doesn't really matter what we pass.</p>

<h1 id='messages'>Message Passing </h1>

<p>Actors communicate by sending each other messages.  Messages cannot be used to pass mutable state between actors.  If a message is <a href='Concurrency.html#immutability'>immutable</a> then it passed by reference. Otherwise the message must be <a href='Serialization.html'>serializable</a> in which case a serialized copy of the object is passed.  If a message is neither immutable or serializable, then <code>IOErr</code> is thrown.</p>

<p>Messages are sent to an actor using of three methods:</p>

<ul>
<li><code><a href='../concurrent/Actor.html#send'>send</a></code>: enqueues the message immediately</li>

<li><code><a href='../concurrent/Actor.html#sendLater'>sendLater</a></code>: enqueues the message after a period of time has elapsed</li>

<li><code><a href='../concurrent/Actor.html#sendWhenDone'>sendWhenDone</a></code>: enqueues the message once another message completes processing</li>
</ul>

<h1 id='futures'>Futures </h1>

<p>All three send methods return a <code><a href='../concurrent/Future.html'>Future</a></code> which may used to access the result of that message.  You can poll for the result using <code><a href='../concurrent/Future.html#isDone'>isDone</a></code> - a future enters the done state by one of three transitions:</p>

<ul>
<li>The actor processes the message and returns a result</li>

<li>The actor raises an exception while processing the message</li>

<li>The future is cancelled (see <code><a href='../concurrent/Future.html#cancel'>cancel</a></code>)</li>
</ul>

<p>Once a future enters the done state, the result is available via the <code><a href='../concurrent/Future.html#get'>get</a></code> method.  If the future is not done, then calling <code>get</code> will block the caller until the future becomes done.  A timeout may be used to block for a fixed period of time. Calling <code>get</code> results in one of these outcomes:</p>

<ul>
<li>If the message was processed successfully, then <code>get</code> will return the result</li>

<li>If the actor raised an exception processing the message, then that same exception is raised to the caller of <code>get</code></li>

<li>If the future was cancelled, then calling <code>get</code> will raise <code>CancelledErr</code></li>

<li>If a timeout is used, then <code>TimeoutErr</code> is thrown if the actor doesn't process the message before the timeout elapses</li>
</ul>

<p>Actors which block via <code>Future.get</code> should never receive messages themselves as this might lead to deadlocks.  Best practice is to design service actors using strictly asynchronous messaging, and keep synchronous messaging on client actors which don't service requests themselves.</p>

<h1 id='timers'>Timers </h1>

<p>The <code><a href='../concurrent/Actor.html#sendLater'>sendLater</a></code> method can be used to setup a timer.  Timers post a message back to the actor's queue when they expire.  Example:</p>

<pre>pool := ActorPool()
a := Actor(pool) |Obj msg| { echo("$Time.now: $msg") }
a.send("start")
a.sendLater(1sec, "1sec")
a.sendLater(3sec, "3sec")
a.sendLater(2sec, "2sec")
Actor.sleep(5sec)</pre>

<p>The <code>sendLater</code> method returns a <code>Future</code> which may be used to cancel the timer or poll/block until the message has been processed.</p>

<h1 id='chaining'>Chaining </h1>

<p>The <code><a href='../concurrent/Actor.html#sendWhenDone'>sendWhenDone</a></code> method is used to deliver a message once another message has completed processing. Using <code>sendWhenDone</code> allows asynchronous message chaining.  Consider this code:</p>

<pre>future := actor1.send(msg1)
actor2.sendWhenDone(future, msg2)</pre>

<p>In this example, <code>msg2</code> is enqueued on <code>actor2</code> only after <code>actor1</code> completes processing of <code>msg1</code>.  Typically the future itself is passed as the message:</p>

<pre>a.sendWhenDone(future, future)        // future is message itself
a.sendWhenDone(future, MyMsg(future)) // MyMsg references future</pre>

<p>Remember that <code>sendWhenDone</code> is called no matter how the future completes: successfully, with an error, or cancellation.</p>

<h1 id='coalescing'>Coalescing Messages </h1>

<p>Often when sending messages to an actor, we can merge two messages into a single message to save ourselves some work.  For example, it is common in windowing systems to maintain a single union of all the dirty portions of a window rather than of a bunch of little rectangles.  An actor can have its messages automatically coalesced using the <code><a href='../concurrent/Actor.html#makeCoalescing'>makeCoalescing</a></code> constructor.</p>

<p>Let's look at an example:</p>

<pre>const class Repaint
{
  new make(Window w, Rect d) { ... }
  Window window
  Rect dirty
}

toKey := |Repaint msg->Obj| { msg.window }
coalesce := |Repaint a, Repaint b->Obj| { Repaint(a.window, a.dirty.union(b.dirty)) }
a := Actor.makeCoalescing(g, toKey, coalesce) |Repaint msg| {...}</pre>

<p>In this example the messages are instances of <code>Repaint</code>.  The <code>toKey</code> function is used to obtain the key which determines if two messages can be coalesced. In this example we coalesce repaints per window. If the thread detects two pending messages with the same key (the window in this case), then it calls the <code>coalesce</code> function to merge the messages.  In example we return a new <code>Repaint</code> event with the union of the two dirty regions.</p>

<p>Messages sent with <code>sendLater</code> and <code>sendWhenDone</code> are never coalsesed.</p>

<h1 id='flowControl'>Flow Control </h1>

<p>The current implementation of Fantom uses <em>unbounded</em> message queues.  This means if an actor is receiving messages faster than it can process them, then its queue will continue to grow.  Eventually this might result in out of memory exceptions.  You can use some of the following techniques to implement flow control to prevent unbounded queues from growing forever:</p>

<ul>
<li>Poll futures with <code>isDone</code> or use <code>get</code> with timeouts to cancel messages which aren't processed after a period of time</li>

<li>Use <a href='#coalescing'>coalescing queues</a> to merge pending messages</li>

<li>Use <a href='#timers'>sendLater</a> to schedule watch dog timers on an actor's queue</li>

<li>Use <a href='#chaining'>sendWhenDone</a> to create message feedback loops</li>
</ul>

<p>For example consider a "reader" actor which reads lines of text from a big text file and sends those lines to other "processing" actors for parallel processing.  If the reader pushes the lines of text as fast as it can read them, then it could potentially end up enqueuing large numbers of lines in memory.  A better strategy would be to have the processing actors enqueue themselves with the reader when they are ready to process a line. This would create a natural feedback loop and allow the reader to throttle its IO based on how fast the processors could work.</p>

<h1 id='pools'>Actor Pools </h1>

<p>All actor's are created within an <code><a href='../concurrent/ActorPool.html'>ActorPool</a></code>. ActorPools manage the execution of actors using a shared thread pool.</p>

<p>As messages are sent to actors, they are allocated a thread to perform their work.  An ActorPool will create up to 100 threads, after which actor's must wait for a thread to free up.  Once a thread frees up, then it is used to process the next actor.  If no actor's have pending work, then the thread lingers for a few seconds before being released back to the operating system.  In this model an ActorPool utilizes between zero and a peak of 100 threads depending on how many of the pool's actors currently have work. You can tweak the peak limit by setting <code><a href='../concurrent/ActorPool.html#maxThreads'>Actor.maxThreads</a></code>:</p>

<pre>ActorPool { maxThreads = 10 }</pre>

<p>An ActorPool is immediately considered <em>running</em> as soon as it is constructed.  However, it doesn't actually spawn its first thread until one of its actors is sent a message.  If all of a pool's actors finish processing their messages, then after a linger period all of that pool's threads be freed.</p>

<p>An ActorPool can be manually shutdown using the <code><a href='../concurrent/ActorPool.html#stop'>stop</a></code> method.  Once <code>stop</code> is called, the pool enters the <em>stopped</em> state and actors within the pool may not receive any more messages.  However all pending messages are allowed to continue processing.  Once all pending messages have been processed, the pool enters the <em>done</em> state.  Use the <code><a href='../concurrent/ActorPool.html#join'>join</a></code> method to block until an ActorPool has fully shutdown.</p>

<p>The <code><a href='../concurrent/ActorPool.html#kill'>kill</a></code> method can be used to perform an unorderly shutdown.  Unlike <code>stop</code>, kill doesn't give actors a chance to finish processing their pending message queues - all pending messages are cancelled. Actors which are currently  executing a message are interrupted (which may or may not immediately terminate that thread).  Once all actors have relinquished their threads, the ActorPool enters the <em>done</em> state.</p>
<div class='prevNext'>
<div class='prev'><a href='Concurrency.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Concurrency.html'>Concurrency</a></div>
<div class='next'><a href='Naming.html'>Naming</a> <a href='Naming.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#actors'>Actors </a></li><li><a href='#locals'>Actor Locals </a></li><li><a href='#messages'>Message Passing </a></li><li><a href='#futures'>Futures </a></li><li><a href='#timers'>Timers </a></li><li><a href='#chaining'>Chaining </a></li><li><a href='#coalescing'>Coalescing Messages </a></li><li><a href='#flowControl'>Flow Control </a></li><li><a href='#pools'>Actor Pools </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

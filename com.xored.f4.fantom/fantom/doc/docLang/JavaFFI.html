<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Java FFI</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='JavaFFI.html'>Java FFI</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Closures.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Closures.html'>Closures</a></div>
<div class='next'><a href='DotnetFFI.html'>Dotnet FFI</a> <a href='DotnetFFI.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Java FFI</h1>

<h1 id='overview'>Overview </h1>

<p>The Java Foreign Function Interface (or Java FFI) is a feature which allows Fantom code to easily utilize normal Java libraries.  The Java FFI is basically a mapping of the Java type system into the Fantom type system:</p>

<ul>
<li>Java packages => Fantom pods</li>

<li>Java classes => Fantom classes</li>

<li>Java interfaces => Fantom mixins</li>

<li>Java fields => Fantom fields</li>

<li>Java methods => Fantom methods</li>
</ul>

<p>Fantom was designed to run on the JVM, so mapping between the two worlds is fairly straight foward with a high level of interoperability.  However, there is a level of impedance mismatch between the two type systems. Features supported by the Java FFI:</p>

<ul>
<li>Interop with any Java API except those which use multi-dimensional arrays</li>

<li>Static type checking</li>

<li>Call overloaded Java methods from Fantom</li>

<li>Construct Java classes using the Fantom <a href='Methods.html#constructionCalls'>constructor syntax</a></li>

<li>Extend Java classes (only one level of inheritance allowed right now)</li>

<li>Implement Java interfaces</li>

<li>Implicit coercion between Java primitives and <code>sys::Int</code>, <code>sys::Float</code></li>

<li>Implicit coercion between one-dimensional Object arrays and <code>sys::List</code></li>

<li>Direct mappings for Java one-dimensional primitive arrays</li>

<li>Fantom reflection support for Java members</li>

<li>Dynamic invoke support against Java classes</li>
</ul>

<p>Features which are not yet available in Java FFI:</p>

<ul>
<li>Multi-dimensional arrays</li>

<li>Subclassing a Java class more than one level deep</li>

<li>Attempting to override a Java overloaded method; this means you cannot subclass or extend from a type with abstract overloaded methods</li>
</ul>

<p>Features which are not supported result in a compile time error.</p>

<h1 id='summary'>Interop Summary </h1>

<p>The following table summarizes the mapping of Java types to Fantom types:</p>

<pre>Java Type            Fantom Type
-----------          -----------
foo.bar.Baz          [java]foo.bar::Baz
boolean              sys::Bool
byte                 sys::Int
short                sys::Int
char                 sys::Int
int                  sys::Int
long                 sys::Int
float                sys::Float
double               sys::Float
java.lang.Object     sys::Obj
java.lang.String     sys::Str
java.lang.Boolean    sys::Bool?
java.lang.Long       sys::Int?
java.lang.Double     sys::Float?
java.math.BigDecimal sys::Decimal
Foo[]                Foo[]  // sys::List parameterized with Foo
boolean[]            [java]fanx.interop::BooleanArray
byte[]               [java]fanx.interop::ByteArray
short[]              [java]fanx.interop::ShortArray
char[]               [java]fanx.interop::CharArray
int[]                [java]fanx.interop::IntArray
long[]               [java]fanx.interop::LongArray
float[]              [java]fanx.interop::FloatArray
double[]             [java]fanx.interop::DoubleArray
Foo[][]             // unsupported for both primitivies and Objects</pre>

<p>Quick reference for mapping Java code to Fantom code:</p>

<pre>Java                         Fantom
--------------------------   --------------------------
import javax.swing           using [java] javax.swing
import java.util.Map.Entry   using [java] java.util::Map$Entry as Entry
JFrame f = new JFrame(...)   f := JFrame(...)
array.length                 array.size
array[i]                     array[i]
array[i] = val               array[i] = val
int[] x = new int[5]         x := IntArray(5)</pre>

<h1 id='howItWorks'>How it Works </h1>

<p>The Java FFI does not use any special Fantom syntax.  Java APIs are imported into the Fantom type system via the normal <code>using</code> statement with a special syntax for pod names.  Java packages are mapped to Fantom pods by prefixing the string "[java]".  For example the Java package <code>javax.swing</code> has the Fantom pod name of <code>[java]javax.swing</code>.</p>

<p>The Fantom compiler itself has no knowledge of Java libraries, rather it supports FFI plugins based on pods being prefixed with "[ffi]".  In the case of the Java FFI, the <a href='../compilerJava/index.html'>compilerJava</a> pod is the compiler plugin for importing the Java type system into Fantom.</p>

<p>Fantom code using the Java FFI results in a normal pod file compiled down into fcode.  The only difference is that the fcode contains type and member references which are Java specific.  This means that Fantom pods with Java FFI calls are not necessarily portable; attempting to use a Java FFI call on .NET will fail.</p>

<h1 id='classpath'>Class Path </h1>

<p>The current implementation of the <code>compilerJava</code> plugin is pretty simple.  It looks for packages and classes using the Fantom runtime classpath.  This includes:</p>

<ol style='list-style-type:decimal'>
<li>jars found in "sun.boot.class.path"</li>

<li>{java}lib/rt.jar (only if step above fails to find anything)</li>

<li>{java}lib/ext/*.jar</li>

<li>{fan}lib/java/ext/*.jar</li>

<li>{fan}lib/java/ext/{Env.platform}/*.jar</li>

<li>jars found in "java.class.path" system property</li>
</ol>

<p>In order to use a class found in the classpath, <code>compilerJava</code> uses Java reflection and resolves the class via <code>Class.forName</code> with the current classloader. If you have problems importing classes you can dump the jars and packages found using:</p>

<pre>fan compilerJava::ClassPath</pre>

<h1 id='primitives'>Primitives </h1>

<p>The special Java primitives <code>boolean</code>, <code>long</code>, and <code>double</code> are implicitly mapped to the Fantom types <code>sys::Bool</code>, <code>sys::Int</code>, and <code>sys::Float</code> respectively. The other Java primitives are mapped as follows:</p>

<pre>byte    sys::Int
short   sys::Int
char    sys::Int
int     sys::Int
long    sys::Int
float   sys::Float</pre>

<p>The special primitives above are not directly supported by the Fantom type system. Therefore you cannot use them as local variables or in field or method signatures. They are <em>always</em> coerced to/from their Fantom representation.</p>

<h1 id='reflection'>Reflection </h1>

<p>All Java objects maintain a <code><a href='../sys/Type.html'>sys::Type</a></code> represtation to provide Fantom style reflection.  You can use a dynamic call to <code>toClass</code> to get the <code>java.lang.Class</code> of a <code>sys::Type</code>:</p>

<pre>ArrayList#            // evaluates to sys::Type
ArrayList#->toClass   // evaluates to java.lang.Class</pre>

<h1 id='arrays'>Arrays </h1>

<p>Arrays of Objects are implicitly boxed/unboxed as Fantom <code>sys::List</code>. If you call a method which returns an array of Objects it is boxed into a Fantom list of the appropriate type.  Likewise you pass a Fantom list of the appropriate type whenever a Java array is expected.</p>

<p>Primitive arrays are handled specially without any boxing/unboxing.  They are represented in the Fantom type system via the special types:</p>

<pre>boolean[]  [java]fanx.interop::BooleanArray
byte[]     [java]fanx.interop::ByteArray
short[]    [java]fanx.interop::ShortArray
char[]     [java]fanx.interop::CharArray
int[]      [java]fanx.interop::IntArray
long[]     [java]fanx.interop::LongArray
float[]    [java]fanx.interop::FloatArray
double[]   [java]fanx.interop::DoubleArray</pre>

<p>The <code>make</code>, <code>get</code>, <code>set</code>, and <code>size</code> methods provide symbolic representations for working with primitive arrays.  They are mapped directly to a single opcode in the Java bytecode:</p>

<pre>int[] x = new int[4]  =>  x := IntArray(4)
x[2]                  =>  x[3]
x[3] = 5              =>  x[3] = 5
x.length              =>  x.size</pre>

<h1 id='nullable'>Nullable </h1>

<p>Any Java API which uses reference types are mapped into the Fantom type system as nullable:</p>

<pre>// Java methods
String foo(Object x, int y, Foo z)
void bar(String[] x) {}

// Fantom representation
Str? foo(Obj? x, Int y, Foo? z)
Void bar(Str?[]? x) {}</pre>

<p>Note the case of <code>String[]</code> we assume that the entire array could be null or that any of the array items may be null, so the Fantom mapping is <code>Str?[]?</code>.</p>

<h1 id='overloadedMethods'>Overloaded Methods </h1>

<p>One impedance mismatch between Java and Fantom is that Java permits a field and method to have the same name.  Java also allows method <em>overloading</em> where multiple methods with the same name may be declared with different parameter types.</p>

<p>Fantom only allows a single definition of a slot for a given name.  However when calling out to Java types the compiler will correctly resolve overloaded fields and methods.  Let's consider this Java class:</p>

<pre>class Foo
{
  String a;
  String a() { return a; }
  void a(String x) { a = x; }
  String b() { return a; }
}</pre>

<p>In the class above <code>a</code> is overloaded by a field and two methods.  Let's look at how Fantom code is resolved against the Java members:</p>

<pre>foo.a        // lack of parens indicates field get
foo.a = "x"  // field set
foo.a()      // call Foo.a() method
foo.a("x")   // call Foo.a(String) method
foo.b()      // call Foo.b() method
foo.b        // call Foo.b() method - no ambiguity so we can omit parens</pre>

<p>Resolving a call to an overloaded version of the method follows the same rules as the Java Language Specification. It is a compile time error if the arguments do not match any methods or if they match multiple methods ambiguously.</p>

<h1 id='ctors'>Constructors </h1>

<p>Under the covers Fantom treats Java constructors just like the Java VM treats them - as special methods with the name of <code>&lt;init></code>.  The standard <a href='Methods.html#constructionCalls'>constructor syntax</a> is used to invoke a Java constructor:</p>

<pre>a := Date()
b := Date(millis)
c := Date(2008-1900, 11, 13) // crazy API to create 13-Dec-2008</pre>

<p>The constructor call is resolved against the Java constructors using the same rules for resolving <a href='#overloadedMethods'>overloaded methods</a>.</p>

<h1 id='subclassing'>Subclassing </h1>

<p>The Java FFI enables you to both extend from a Java class and implement Java interfaces.  For example to create a subclass of <code>java.util.Date</code>:</p>

<pre>using [java] java.util::Date as JDate
class FanDate : JDate
{
  new now() : super() {}
  new make(Int millis) : super(millis) {}
}</pre>

<p>The standard <a href='Inheritance.html#syntax'>inheritance syntax</a> is used to extend and implement Java types.</p>

<p>The Fantom subclass must define how the Fantom constructors call the Java superclass constructors.  This is done by calling <code>super</code> as an overloaded constructor (if the base class has multiple constructors).  You may not use a <code>this</code> constructor chain.</p>

<p>Constructors for a Fantom class which subclasses from a Java class are emitted as true Java constructors.  Therefore you may not declare two Fantom constructors with the same parameter types as it would result in duplicate Java constructors. For example the following code would result in a compile time error:</p>

<pre>class FanDate : Date
{
  new now() : super() {}
  new epoch() : super(0) {}
}</pre>

<p>Because of this difference between Fantom constructors versus Java constructors there is currently a restriction that you may only subclass from a Java class one level deep.  You may not subclass from a Fantom class which itself subclasses from a Java class.</p>

<p>Another restriction:  because a Fantom class may not override overloaded methods, you may not create a concrete Fantom class which inherits abstract overloaded methods.</p>

<h1 id='overrides'>Overrides </h1>

<p>When a Fantom type subclasses a Java type, you can override the Java methods using the normal Fantom syntax with the following restrictions:</p>

<ul>
<li>cannot override static or final methods</li>

<li>cannot override a method overloaded by field of same name</li>

<li>cannot override a method overloaded by parameter types</li>

<li>cannot override a method which uses multi-dimensional arrays in its signature</li>
</ul>

<p>Consider this example:</p>

<pre>// Java class
class Java
{
  void alpha() {}
  void alpha(Java x) {}
  void beta(Java x) {}
  int gamma(String[] x) {}
}</pre>

<p>In the example above, the method <code>alpha</code> is overloaded by parameter types, therefore it is not permissible for a Fantom class to override it.  However we can override <code>beta</code> and <code>gamma</code>:</p>

<pre>class Fantom : Java
{
  override Void beta(Java? x) {}
  override Int gamma(Str?[]? x) {}
}</pre>

<p>When we override a Java method we use the Fantom type representation of the signature. In the <code>gamma</code> method we map the return type <code>int</code> to <code>sys::Int</code> and the argument type from <code>String[]</code> to the Fantom list <code>Str[]</code>.</p>

<h1 id='innerClasses'>Inner Classes </h1>

<p>Inner classes in Java source are formatted using a dot, but in the Java VM they are represented using the "$" dollar sign.  We import inner classes into the Fantom type system using the Java VM name:</p>

<pre>using [java] java.util::Map$Entry as Entry</pre>

<p>Note that since the "$" is not a legal identifier char in Fantom, you must <a href='CompilationUnits.html#using'>rename</a> the Java inner class to a valid Fantom identifier with the <code>as</code> keyword.</p>

<h1 id='dynamicCalls'>Dynamic Calls </h1>

<p>Normal Fantom reflection and dynamic invoke is available with Java classes. The Fantom runtime will correctly map reflective calls and dynamic invokes against overloaded methods.  Because it is possible for a Java class to have both a field and method of the same name, <code>Type.field</code> and <code>Type.method</code> might return different results for the same name.  If an attempt is made to use dynamic invoke on slot which has both a field and method of that name, then the method always hides the field.</p>

<h1 id='funcAsInterface'>Functions as Interfaces </h1>

<p>Inner classes are often used in Java as a substitute for closures.  The Java FFI allows you to use a function where an interface with one method is expected. For example the interface <code>Runnable</code> defines one method called <code>run</code>, so we can use a Fantom function whenever a <code>Runnable</code> is expected:</p>

<pre>// Java API
void execute(Runnable r)

// Fantom code
execute |->| { echo("run!") }</pre>

<p>The standard rules for coercion between Java and Fantom types apply for how the function implements the interface's method.</p>

<h1 id='annotations'>Annotations </h1>

<p>Java annotations are imported into the Fantom type system as a special case of <a href='Facets.html'>facets</a>.  Fantom classes and slots may be annotated with a Java annotation using the standard facet syntax:</p>

<pre>// Java annotations
public @interface AnnoA {}
public @interface AnnoB { String value(); }
public @interface AnnoC { int i();  String s(); }

// Fantom syntax
@AnnoA
@AnnoB { value = "foo" }
@AnnoC { i = 34; s = "bar" }
class Fantom {}</pre>

<p>Assuming the annotation has a runtime retention policy, annotations added to a Fantom type or slot are available for Java reflection.  However, the annotation will <strong>not</strong> be reflected in the Fantom type system as a facet.</p>

<p>The following annotation element types are currently supported:</p>

<pre>Java                     Fantom
----                     -------
boolean                  sys::Bool literal
byte, short, int, long   sys::Int literal
float, double            sys::Float literal
String                   sys::Str literal
Class                    sys::Type literal
enum                     Java FFI enum field access
arrays of above          sys::List literal of above</pre>
<div class='prevNext'>
<div class='prev'><a href='Closures.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Closures.html'>Closures</a></div>
<div class='next'><a href='DotnetFFI.html'>Dotnet FFI</a> <a href='DotnetFFI.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#summary'>Interop Summary </a></li><li><a href='#howItWorks'>How it Works </a></li><li><a href='#classpath'>Class Path </a></li><li><a href='#primitives'>Primitives </a></li><li><a href='#reflection'>Reflection </a></li><li><a href='#arrays'>Arrays </a></li><li><a href='#nullable'>Nullable </a></li><li><a href='#overloadedMethods'>Overloaded Methods </a></li><li><a href='#ctors'>Constructors </a></li><li><a href='#subclassing'>Subclassing </a></li><li><a href='#overrides'>Overrides </a></li><li><a href='#innerClasses'>Inner Classes </a></li><li><a href='#dynamicCalls'>Dynamic Calls </a></li><li><a href='#funcAsInterface'>Functions as Interfaces </a></li><li><a href='#annotations'>Annotations </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

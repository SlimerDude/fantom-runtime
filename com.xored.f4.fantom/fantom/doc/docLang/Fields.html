<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Fields</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Fields.html'>Fields</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Methods.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Methods.html'>Methods</a></div>
<div class='next'><a href='Inheritance.html'>Inheritance</a> <a href='Inheritance.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Fields</h1>

<h1 id='overview'>Overview </h1>

<p>Fields are the mechanism used to manage state in classes.  A single field encapsulates three concepts:</p>

<ol style='list-style-type:decimal'>
<li><strong>Storage</strong>: a memory location to store a reference to the field's value</li>

<li><strong>Getter</strong>: a method to get the field</li>

<li><strong>Setter</strong>: a method to set the field</li>
</ol>

<p>The key concept in Fantom is that <em>all</em> fields <em>automatically</em> use a getter and setter method (there are a couple exceptions to this rule we will discuss below).  In Java fields are simply a storage location.  Most Java programmers then wrap the field in a getter and setter method resulting in a huge amount of bloated, boiler plate code.  Then all access is done through a method call which is not exactly the prettiest syntax for field access.  C# is better in that properties are first class language constructs.  However management of storage is still done via a field and all the same boiler plate code is required. These design patterns used in Java and C# don't capture programmer intent very cleanly.  The vast majority of these accessors are boiler plate code that don't actually do anything other than get and set the field.  Plus it requires multiple language constructs to model one logical construct - this makes documentation a pain.</p>

<h1 id='simple'>Simple Fields </h1>

<p>In the simplest case, field declarations look just like Java or C#:</p>

<pre>class Thing
{
  Int id := 0
  Str? name
}</pre>

<p>In the example above <code>id</code> and <code>name</code> are instance fields on the class <code>Thing</code>.  We use the <code>:=</code> operator to provide an initial value for the field which is automatically assigned before the constructor is executed.  If an initial value is not provided, then all fields default to <code>null</code> with the exception of <a href='TypeSystem.html#valueTypes'>value-types</a>.</p>

<p>We access fields using the <code>.</code> operator:</p>

<pre>thing := Thing()
thing.name = "bob"
echo(thing.id)
echo(thing.name)</pre>

<p>In the code above, a getter or setter is not explicitly specified, so they are automatically generated by the compiler.  All access to the field is through the getter and setter method.  So the code <code>thing.name</code> is really a method call to the <code>name</code> getter method.  This enables you to later add an explicit accessor without requiring a recompile of all the client code to your API.</p>

<p>You can also the <code>?.</code> operator to safely handle a null target.  See <a href='Expressions.html#safeInvoke'>safe invokes</a>.</p>

<p>Note: if you don't provide a getter or setter on a non-virtual field, then the compiler will optimize field access internal to your pod.  So inside your pod, accessor methods are only used if you declare explicit accessors. Outside your pod, accessor methods are always used for non-const fields. Abstract and virtual fields always use accessors.</p>

<h1 id='accessors'>Accessor Methods </h1>

<p>The syntax for declaring a getter or setter is similar to C# properties:</p>

<pre>class Thing
{
  Int id := 0
  {
    get { echo("get id"); return &amp;id }
    set { echo("set id"); &amp;id = it }
  }
}</pre>

<p>The accessor section is denoted by a <code>{}</code> block after the initial value assignment (or after the field identifier if no initial value). You can declare both <code>get</code> and <code>set</code> - or if you just declare one, then the other is automatically generated.</p>

<p>Inside the setter, the <code>it</code> keyword references the new value being assigned to the field.  If you need to use <code>it</code> inside a closure, then assign to a local variable:</p>

<pre>set { newVal := it; 3.times { echo(newVal) }; this.&amp;f = newVal }</pre>

<p>The <code>&amp;</code> storage operator is used to access the raw storage of the field (think about like C dereference operator).  The <code>&amp;</code> operator is used when you wish to access the storage location of the field without going through the accessor method.  You can use the <code>&amp;</code> operator in any of your class's methods, but only the declaring class is permitted direct access using the <code>&amp;</code> operator (it is like storage is always <code>private</code> scoped). Inside the accessor itself you are required to use the <code>&amp;</code> operator (otherwise you would likely end up with infinite recursion).</p>

<p>Note that <code>:=</code> field initialization always sets storage directly without calling the setter method (see <a href='#virtual'>below</a> for an exception to this rule).</p>

<h1 id='calculated'>Calculated Fields </h1>

<p>In most cases, the compiler automatically declares storage memory for your field.  However if the compiler detects that a field's storage is never accessed then no memory is allocated.  We call these <em>calculated fields</em>.  Calculated fields must declare both an explicit getter and setter which does not use the <code>&amp;</code> operator to access the field.  Note that assigning an initial value using <code>:=</code> implicitly uses the storage operator and will allocate storage.</p>

<h1 id='const'>Const Fields </h1>

<p>The keyword <code>const</code> can be applied to your fields to indicate that the field is immutable:</p>

<pre>class Thing
{
  new make(Int id) { this.id = id }
  const Int id
}</pre>

<p>In the example above, <code>id</code> is an const instance field.  Const instance fields can only be set in a constructor.  They work a little different than Java final fields - you can set them as many times as you like (or let them default to null), but you can't assign to them outside of the construction process.</p>

<p>Fantom also allows const instance fields to be set during the construction process via an <a href='Closures.html#itBlocks'>it-block</a>:</p>

<pre>class Thing
{
  new make(|This f|? f := null) { if (f != null) f(this) }
  const Str name
}

t := Thing { name = "Brian" }   // ok
t { name = "Andy" }             // throws ConstErr</pre>

<p>Inside of it-blocks, the check for setting a const field is moved from compile-time to run-time.  The compiler will allow <em>any</em> it-block to set a const field on <code>it</code>.  However, if an attempt is made to call the it-block outside of the constructor then <code>ConstErr</code> is thrown.  This gives you flexibility to build APIs which capture a snippet of code used to modify an immutable class.</p>

<p>Const instance fields may also configured during deserialization via the <code><a href='../sys/InStream.html#readObj'>sys::InStream.readObj</a></code> method.</p>

<p>The value of all <code>const</code> fields must be <a href='Concurrency.html#immutability'>immutable</a>. This guarantees that all const fields reference an instance which will not change state.</p>

<p>Const fields do not use accessor methods.  It is a compile time error to declare accessors on a const field.  All field access is performed directly against storage.</p>

<p>Const fields cannot be declared <code>abstract</code> or <code>virtual</code>.  However a const field can <a href='#overrideMethod'>override</a> a virtual method with no parameters. But const fields cannot override fields since that would imply the field could be set.  Example of using this technique to use a pre-calcualted string for <code>Obj.toStr</code>:</p>

<pre>const class Something
{
  new make(...) { toStr = "..." }
  override const Str toStr
}</pre>

<h1 id='static'>Static Fields </h1>

<p>The keyword <code>static</code> is used to create a static class level field:</p>

<pre>class Thing
{
  const static Int nullId := 0xffff
}</pre>

<p>The field <code>nullId</code> is a const static field - there is only one global instance on the class itself.  Const static fields can only be set in <a href='Methods.html#staticCtor'>static constructors</a>.  Static fields must be const - this ensures <a href='Concurrency.html'>thread safety</a>.  Static fields are accessed using the <code>.</code> operator on the class itself:</p>

<pre>Thing.nullId</pre>

<h1 id='protection'>Protection Scope </h1>

<p>You can use the normal slot protection scope keywords with a field: <code>public</code>, <code>protected</code>, <code>internal</code>, and <code>private</code>.  The default is <code>public</code> if a keyword is omitted.</p>

<p>You can narrow the scope of the setter as follows:</p>

<pre>class Thing
{
  Int id { protected set }
  Str name { internal set { &amp;name = it } }
}</pre>

<p>In the example above the fields <code>id</code> and <code>name</code> are publicly scoped.  We've narrowed the scope of the <code>id</code> setter to be protected.  Because there is no method body for the setter of <code>id</code>, then the compiler auto generates one.  The declaration for <code>name</code> shows narrowing the scope <em>and</em> declaring an explicit setter.</p>

<p>Only a protection scope keyword may be used with a setter.  The getter is always the protection scope of the field itself by definition.  It is a compile time error to use keywords like <code>const</code>, <code>virtual</code>, or <code>abstract</code> on an individual getter or setter.</p>

<h1 id='readonly'>Readonly Fields </h1>

<p>It is quite common to publically expose a field's getter, but to hide the setter.  This could be done by narrowing the field's setter to be <code>private</code> as the following code illustrates:</p>

<pre>class Thing
{
  Int id { private set }
  internal Int count { private set }
}</pre>

<p>You can accomplish the same thing a little easier using the <code>readonly</code> keyword:</p>

<pre>class Thing
{
  readonly Int id
  internal readonly Int count
}</pre>

<p>The <code>readonly</code> syntax provides the exact same semantics as narrowing the setter to private.  Note that const fields are truly immutable - they always reference the same immutable instance.  Readonly fields do not imply anything about immutability - they only make the setter private.</p>

<h1 id='virtual'>Virtual Fields </h1>

<p>Instance fields may be declared virtual which allows subclasses to override the getter and setter methods:</p>

<pre>class Thing
{
  virtual Int id := 0
}

class NewThing : Thing
{
  override Int id
  {
    get { echo("NewThing.id get"); return super.id }
    set { echo("NewThing.id set"); super.id = it }
  }
}

class AnotherThing : Thing
{
  override Int id := 100
}</pre>

<p>In this example <code>Thing.id</code> is virtual which allows subclasses to override its getter and setter method (in this case <code>Thing.id</code> accessors are auto generated by the compiler).  The class <code>NewThing</code> overrides the accessors for <code>id</code> to add some tracing, then calls the superclass accessors.  Note that the overridden field must specify the <code>override</code> keyword and must be use the same type (covariance is not supported).</p>

<p>Overridden fields are not given their own storage, rather they should delegate to their superclass accessors using the <code>super</code> keyword.  In the case that an override requires its own storage, you should declare another field to use as storage.</p>

<p>In the example above, the class <code>AnotherThing</code> overrides <code>Thing.id</code> by providing a different default value.  Since no explicit getter or setter is specified, the compiler automatically generates accessors. However the accessors for <code>AnotherThing.id</code> call <code>super.id</code> rather than access storage directly.  Also note that when an overridden field specifies an initial value, the field is initialized via its virtual setter rather than direct storage.</p>

<h1 id='abstract'>Abstract Fields </h1>

<p>A field may be declared abstract:</p>

<pre>abstract class Thing
{
  abstract Int id
}

class NewThing : Thing
{
  override Int id := 0
}</pre>

<p>An abstract field is basically just an abstract getter and setter that a subclass must override.  Abstract fields have no storage and cannot have an initial value.  Overrides of abstract fields are given storage accessed via the <code>&amp;</code> operator (this is different than overriding a normal virtual field).</p>

<h1 id='definiteAssignment'>Definite Assignment </h1>

<p>Non-nullable fields must be assigned in all code pathes.  Each constructor which doesn't chain to <code>this</code> must set each non-nullable field which doesn't meet one of the following criteria:</p>

<ul>
<li>value type fields don't need to be set (Bool, Int, Float)</li>

<li>fields with an initializer don't need to be set</li>

<li>abstract or override fields don't need to be set</li>

<li>native fields don't need to be set</li>

<li><a href='#calculated'>calcualted</a> fields don't need to be set</li>
</ul>

<p>Matching rules apply to static fields which must be set by all code paths in the static initializer.</p>

<p>As a special case, a constructor which takes an it-block as the last parameter allows definite assignment to be postponed to runtime.  The it-block is required to set every non-nullable field or a <code>FieldNotSetErr</code> is raised at runtime.  Consider this example:</p>

<pre>class Foo
{
  new make(|This| f) { f(this) }
  Str name
}

Foo {}                   // throws FieldNotSetErr
Foo { name = "Brian" }   // ok</pre>

<h1 id='overrideMethod'>Overriding a Method </h1>

<p>A field's getter may be used to override a virtual method which has no parameters:</p>

<pre>abstract class Named
{
  abstract Str name()
}

class Person : Named
{
  override Str name
}</pre>

<p>In the example above <code>Named.name</code> is a virtual method that returns a <code>Str</code>. The class <code>Person</code> overrides the <code>Named.name</code> method using a field.  The override of <code>Named.name</code> maps to the getter of <code>Person.name</code>.  Note that the field must specify the <code>override</code> keyword and must have a matching type. Field overrides of a method may use <a href='Inheritance.html#covariance'>covariance</a> - the field may be declared using a more specific type than the method return type.</p>

<p>This design pattern is a handy technique to use in your Fantom code.</p>

<h1 id='mixins'>Mixins </h1>

<p>A mixin can only declare const static fields and abstract fields.  Mixins with abstract fields are basically declaring a getter/setter signature. When implementing a mixin with abstract fields, it is the subclass's responsibility to provide an implementation of the field.  Field access of mixins uses the standard <code>.</code> dot operator too.</p>

<h1 id='native'>Native Fields </h1>

<p>Native fields are implemented in an alternate language which is "native" for each target platform.  Native fields are typically written in Java for the Java VM and C# for the .NET CLR.  Native fields use the <code>native</code> keyword and follow similiar rules to absract fields - no storage or accessors.  The infrastructure for supporting native fields is discussed in the <a href='Natives.html'>Natives</a> chapter.</p>
<div class='prevNext'>
<div class='prev'><a href='Methods.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Methods.html'>Methods</a></div>
<div class='next'><a href='Inheritance.html'>Inheritance</a> <a href='Inheritance.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#simple'>Simple Fields </a></li><li><a href='#accessors'>Accessor Methods </a></li><li><a href='#calculated'>Calculated Fields </a></li><li><a href='#const'>Const Fields </a></li><li><a href='#static'>Static Fields </a></li><li><a href='#protection'>Protection Scope </a></li><li><a href='#readonly'>Readonly Fields </a></li><li><a href='#virtual'>Virtual Fields </a></li><li><a href='#abstract'>Abstract Fields </a></li><li><a href='#definiteAssignment'>Definite Assignment </a></li><li><a href='#overrideMethod'>Overriding a Method </a></li><li><a href='#mixins'>Mixins </a></li><li><a href='#native'>Native Fields </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

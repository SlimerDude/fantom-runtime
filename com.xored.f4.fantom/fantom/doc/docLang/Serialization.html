<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Serialization</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Serialization.html'>Serialization</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Env.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Env.html'>Env</a></div>
<div class='next'><a href='Concurrency.html'>Concurrency</a> <a href='Concurrency.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Serialization</h1>

<h1 id='overview'>Overview </h1>

<p>Serialization is the process of writing objects to an output stream, and reading them back from an input stream.  Serialization provides a simple mechanism to persist objects to a file or to pass objects over a network.  Serialization is also used with <a href='Actors.html'>actors</a> as a safe way to pass messages between actors.  Fantom serialization uses a human friendly text format which looks a lot just like Fantom source code (in fact it is a subset of the source grammar).</p>

<h1 id='model'>Data Model </h1>

<p>Serialization in Java is <em>graph</em> based - it will handle an arbitrary number of references to a particular object.  Fantom serialization is strictly <em>tree</em> based, it will not attempt to keep track of object references - it is up to you design your data models as a tree. If you need to cross reference objects in your tree, then you should use a Uri or some other identifier.</p>

<p>Each object in the tree is classified as a <em>literal</em>, <em>simple</em>, or <em>complex</em>. Most of the standard Fantom literals such as <code>Bool</code>, <code>Int</code>, <code>Str</code> are supported as well as the collections types <code>List</code> and <code>Map</code>.  Simples are leaf nodes serialized via a string representation.  Complexes are an aggregate node defined by their fields which store nested objects (either literals, simples, or other complexes).  You can also mark any complex type as a <a href='#collection'>collection</a>.</p>

<h1 id='serializable'>Serializable </h1>

<p>The <code><a href='../sys/Serializable.html'>sys::Serializable</a></code> facet is used to mark types which are serializable. By default a serializable object will serialize all of its non-static fields. You can use the <code><a href='../sys/Transient.html'>sys::Transient</a></code> facet to annotate a field which should not be serialized.  A contrived example:</p>

<pre>@Serializable
class Rectangle
{
  Int x; Int y
  Int w; Int h
  @Transient Int area
}</pre>

<p>A serializable object must support a <code>make</code> constructor which either takes no parameters or takes an it-block.  If the constructor takes an it-block then the field values are passed in using <code><a href='../sys/Field.html#makeSetFunc'>Field.makeSetFunc</a></code> and the object is given a chance to perform validation.  For example:</p>

<pre>@Serializable
const class Rec
{
  new make(|This| f)
  {
    f(this)
    if (id &lt;= 0) throw ArgErr("id &lt;= 0")
  }
  const Int id
}

"Rec { id = 3 }".in.readObj  // ok
"Rec {}".in.readObj          // throws ArgErr</pre>

<h1 id='simple'>Simple </h1>

<p>Set the <code><a href='../sys/Serializable.html#simple'>Serializable.simple</a></code> field to mark a type which is serialized atomically to and from a string representation. The <code><a href='../sys/Obj.html#toStr'>sys::Obj.toStr</a></code> method must return a suitable string representation of the object.  Each simple type must also declare a static method called <code>fromStr</code> which takes one or more parameters where the first parameter is a <code>Str</code> and returns an instance of the object.  An example:</p>

<pre>@Serializable { simple = true }
class Point
{
  static Point fromStr(Str s) { t := s.split(','); return make(t[0].toInt, t[1].toInt) }
  new make(Int x, Int y) { this.x = x; this.y = y }
  override Str toStr() { return "$x,$y" }
  Int x := 0
  Int y := 0
}</pre>

<h1 id='collection'>Collection </h1>

<p>Set the <code><a href='../sys/Serializable.html#collection'>Serializable.collection</a></code> field to mark a type as a container of child objects. Collections provide a concise syntax for nesting zero or more children items in the same scope as any serialized fields. This allows you to nest configuration items and children inside one set of curly braces.  Every collection type must support an <code>add</code> and <code>each</code> method which are used by <code>readObj</code> and <code>writeObj</code> respectively.  See the <a href='#syntaxCollection'>example code</a>.</p>

<h1 id='streams'>Streams </h1>

<p>The following methods are available for serialization:</p>

<ul>
<li><code><a href='../sys/InStream.html#readObj'>InStream.readObj</a></code>: read single object</li>

<li><code><a href='../sys/OutStream.html#writeObj'>OutStream.writeObj</a></code>: write single object</li>
</ul>

<p>Serializing objects to and from streams is a piece of cake:</p>

<pre>// write an object to an output stream
out.writeObj(obj)

// read an object from an input stream
obj := in.readObj</pre>

<p>Both <code>Buf</code> and <code>File</code> have convenience methods.  For example to serialize to and from a file:</p>

<pre>obj := [true, 5, "hi", `file.txt`]
f := File(`test.txt`)
f.writeObj(obj)
obj2 := f.readObj</pre>

<p>By default <code>writeObj</code> will optimize for performance.  But if you are generating a file which should look pretty for humans to read and edit, you can control the output using options.  For example to indent each level of the output tree by 2 spaces and skip fields at their default values:</p>

<pre>out.writeObj(obj, ["indent":2, "skipDefaults":true])</pre>

<h1 id='syntax'>Syntax </h1>

<p>The Fantom serialization syntax is designed to be easy to read and write by a human, but also efficient for machine processing.  The syntax is based on the Fantom programming language itself, although it is purely declarative (no expressions or behavior). An object is defined as one of:</p>

<ul>
<li>Literal: one of the standard Fantom literals using the exact same representation as you would use in your source code (this includes <code>List</code> and <code>Map</code>)</li>

<li>Simple: the string representation of a simple type</li>

<li>Complex: a type and its list of field name/values pairs</li>
</ul>

<p>The Fantom programming language is a complete superset of the serialization syntax - you can paste any serialized object into a source file as an expression.</p>

<h2 id='using'>Using </h2>

<p>You can include zero or more <code>using</code> statements at the top of a serialized object document.  Using statements allow unqualified type names to be used:</p>

<pre>// qualified names
["red":fwt::Color("#f00"), "blue":fwt::Color("#0f0")]

// unqualified names
using fwt
["red":Color("#f00"), "blue":Color("#0f0")]</pre>

<p>You can use any of the <a href='CompilationUnits.html#using'>standard using</a> statements in your serialization documents:</p>

<pre>using pod                  =>  import all types in pod
using pod::name            =>  import single type
using pod::name as rename  =>  import type with new name</pre>

<p>Note that unlike normal source code, the <code>sys</code> pod is <strong>not</strong> imported automatically.  If you wish to use unqualified type names for the sys pod, then you need to explicitly import via <code>using sys</code>.</p>

<h2 id='syntaxLiterals'>Literals </h2>

<p>Most of the standard Fantom literals are serialized using the same representation as defined by the Fantom programming language:</p>

<ul>
<li><a href='Literals.html#bool'>sys::Bool</a></li>

<li><a href='Literals.html#int'>sys::Int</a></li>

<li><a href='Literals.html#float'>sys::Float</a></li>

<li><a href='Literals.html#decimal'>sys::Decimal</a></li>

<li><a href='Literals.html#str'>sys::Str</a></li>

<li><a href='Literals.html#duration'>sys::Duration</a></li>

<li><a href='Literals.html#uri'>sys::Uri</a></li>

<li><a href='Literals.html#type'>sys::Type</a></li>

<li><a href='Literals.html#slot'>sys::Slot</a></li>

<li><a href='Literals.html#list'>sys::List</a></li>

<li><a href='Literals.html#map'>sys::Map</a></li>
</ul>

<p class='NOTE'>NOTE: the special <code>Float</code> values <code>NaN</code>, <code>INF</code>, and <code>-INF</code> must be represented using the simple syntax: sys::Float("NaN") sys::Float("INF") sys::Float("-INF")</p>

<h2 id='syntaxSimples'>Simples </h2>

<p>A simple is serialized as: <code>&lt;type>("&lt;toStr>")</code>.  When writing the object, the <code>Obj.toStr</code> method is called to obtain the string representation.  When reading the object the static <code>fromStr</code> method is used to decode the string back into an object.  Examples:</p>

<pre>sys::Version("1.2")
sys::Depend("foo 1.2-3.4")</pre>

<p>You may use this syntax directly in source code via the <a href='Expressions.html#simples'>simple expression</a>.</p>

<h2 id='syntaxComplex'>Complex </h2>

<p>A complex is serialized as a list of field name/value pairs separated by a newline or a semicolon (just like Fantom statements).  Any field can be omitted, in which case the field's default is used.  The syntax for a complex is:</p>

<pre>&lt;type>
{
  &lt;field1> = &lt;value1>
  &lt;field2> = &lt;value2>
  ...
}</pre>

<p>An example of a serializable class and an serialized instance:</p>

<pre>@Serializable
class Person
{
  Str name
  Int age
  Str[] children
  Str address
}

acme::Person
{
  name = "Homer Simson"
  age = 39
  children = ["Bart", "Lisa", "Maggie"]
}</pre>

<p>You may use this syntax directly in source code via <a href='Expressions.html#itBlocks'>it-blocks</a>.</p>

<h2 id='syntaxCollection'>Collection </h2>

<p>Collections are serialized just like a complex - all the fields are serialized as name/value pairs.  After the fields are serialized, all the child items iterated by the <code>each</code> method are serialized with a comma separator. During deserialization, the children are added back via the <code>add</code> method.</p>

<p>We can rewrite the <code>Person</code> example above as a collection:</p>

<pre>@Serializable { collection = true }
class Person
{
  Void add(Person kid) { kids.add(kid) }
  Void each(|Person kid| f) { kids.each(f) }
  Str name
  @transient private Person[] kids := Person[,]
}

acme::Person
{
  name = "Homer Simson"
  acme::Person { name = "Bart" },
  acme::Person { name = "Lisa" },
  acme::Person { name = "Maggie" },
}</pre>

<p>This syntax is also supported directly in source code via <a href='Expressions.html#itBlocks'>it-blocks</a>.</p>

<h2 id='syntaxGrammar'>Grammar </h2>

<p>The formal grammar of the Fantom serialization formats:</p>

<pre>// .fog file format for single object
objDoc    := header obj

header    := [using]*
using     := usingPod | usingType | usingAs
usingPod  := "using" id eos
usingType := "using" id "::" id eos
usingAs   := "using" id "::" id "as" id eos
obj       := literal | simple | complex
literal   := bool | int | float | decimal | str | duration | uri |
             typeLiteral | slotLiteral | list | map
simple    := type "(" str ")"
complex   := type ["{" [children] "}"]
children  := child [(eos|",") child]*
child     := field | item
eos       := ";" | newline
field     := id "=" obj
item      := obj</pre>

<p>The <code>literal</code>, <code>using</code>, and <code>type</code> productions use the same <a href='Grammar.html'>grammar</a> as the Fantom programming language.  However the <code>type</code> production can never be a function type.</p>
<div class='prevNext'>
<div class='prev'><a href='Env.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Env.html'>Env</a></div>
<div class='next'><a href='Concurrency.html'>Concurrency</a> <a href='Concurrency.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#model'>Data Model </a></li><li><a href='#serializable'>Serializable </a></li><li><a href='#simple'>Simple </a></li><li><a href='#collection'>Collection </a></li><li><a href='#streams'>Streams </a></li><li><a href='#syntax'>Syntax </a><ul>
<li><a href='#using'>Using </a></li><li><a href='#syntaxLiterals'>Literals </a></li><li><a href='#syntaxSimples'>Simples </a></li><li><a href='#syntaxComplex'>Complex </a></li><li><a href='#syntaxCollection'>Collection </a></li><li><a href='#syntaxGrammar'>Grammar </a></li></ul>
</li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

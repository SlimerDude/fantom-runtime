<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Inheritance</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Inheritance.html'>Inheritance</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Fields.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Fields.html'>Fields</a></div>
<div class='next'><a href='Facets.html'>Facets</a> <a href='Facets.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Inheritance</h1>

<h1 id='overview'>Overview </h1>

<p>Inheritance is the mechanism used to reuse existing types when defining a new type.  We use inheritance for two purposes:</p>

<ul>
<li><a href='#specialization'>contract specialization</a></li>

<li><a href='#implReuse'>implementation reuse</a></li>
</ul>

<h2 id='specialization'>Contract Specialization </h2>

<p>Types define an explicit and implicit <a href='TypeSystem.html#contracts'>contract</a>. The implicit contract defines semantics to help humans understand the code.  The explicit contract is defined by the set of public slots.  Let's look at an example:</p>

<pre>class File
{
  virtual Int size() {...}
  private Void checkNotDir() {...}
}</pre>

<p>In the code above the class File declares a method called <code>size</code> which returns an <code>Int</code>.  This is part of the type's contract - given an instance of <code>File</code>, we always know there will be a method called <code>size</code> that returns an <code>Int</code> for the number of bytes in the file.</p>

<p>On the other hand, the <code>checkNotDir</code> method is not part of the type's contract because it is private.  It is an implementation detail of the class, rather than a public API.</p>

<p>When we create a subclass of File, we are specializing the contract:</p>

<pre>class HttpFile : File
{
  Str:Str httpHeaders
}</pre>

<p>By subclassing <code>File</code>, the <code>HttpFile</code> class inherits the contract of <code>File</code> and must support all the same public slots.  However we also specialize the base class by adding HTTP specific features such as exposing the HTTP headers.</p>

<h2 id='implReuse'>Implementation Reuse </h2>

<p>If a type declares only abstract slots, then a subclass is inheriting purely the type contract - this is what happens in Java or C# when declaring an interface.  However, in Fantom both classes and mixins can declare an implementation for their slots.  Subclasses can then inherit the implementation of their super type slots.  We call this technique <em>implementation reuse</em> - it gives us a convenient mechanism to organize our code and keep things nice and <a href='http://www.artima.com/intv/dry.html'>DRY</a>.</p>

<h1 id='syntax'>Syntax </h1>

<p>The syntax for inheritance is to include zero or more type definitions in the class declaration after a colon:</p>

<pre>// inheriting from Obj
class SubObj {}
class SubObj : sys::Obj {}

// class inheritance
class SubClassA : BaseClass {}
class SubClassB : MixinA, MixinB {}
class SubClassC : BaseClass, MixinA, MixinB {}

// mixin inheritance
mixin MixinC : MixinA {}
mixin MixinD : MixinA, MixinB {}</pre>

<p>The order of the declaration does matter in some cases.  If the inheritance types include a class and one or more mixins, then the class type must be declared first.</p>

<h1 id='rules'>Inheritance Rules </h1>

<p>The following rules define how slots are inherited by a subtype:</p>

<ol style='list-style-type:decimal'>
<li>Constructors are never inherited</li>

<li>Private slots are never inherited</li>

<li>Internal slots are inherited only by types within the same pod</li>

<li>All other slots are inherited</li>
</ol>

<p>These rules follow the logic laid out in when discussing <a href='#specialization'>contract specialization</a>.  Private and internal slots are implementation details, so they don't become part of the type's contract.  Constructors are always tied exactly to their declaring class, so they are not inherited either.  These rules are applied by both the compiler and the reflection APIs to determine the slot namespace of a given type.</p>

<h1 id='restrictions'>Inheritance Restrictions </h1>

<p>The inheritance rules listed above define which slots get inherited into a subtype's slot namespace.  Remember that a type's slots are keyed only by name, so under no circumstances can a type have two different slots with the same name.  Because of this axiom, there are cases which prevent creating a subtype from conflicting super types:</p>

<ol style='list-style-type:decimal'>
<li>Two types with static methods of the same name can't be combined into a subtype</li>

<li>Two types with const fields (either instance or static) of the same name can't be combined into a subtype</li>

<li>Two types with instance slots of the same name and different signatures can't be combined into a subtype</li>

<li>Two types with instance slots of the same name and same signature can be combined provided the following holds true:
<ol style='list-style-type:lower-alpha'>
<li>One is concrete and the other is abstract</li>

<li>Both are virtual and the subtype overrides to provide unambiguous definition</li>
</ol>
</li>
</ol>

<p>Using the rules above, Fantom avoids the diamond inheritance problem.  First mixins can't declare concrete fields, which mean they never store state. Second any ambiguity that arises from diamond inheritance or otherwise requires the subclass to explicitly disambiguate (or if the inherited slots are not virtual, then the subtype simply cannot be created).</p>

<h1 id='overrides'>Overrides </h1>

<p>When inheriting slots from one or more super types, a type has the option to override any of the super type's virtual slots. There are three mechanisms of override:</p>

<ol style='list-style-type:decimal'>
<li>Method overrides Method (see <a href='Methods.html#virtual'>virtual methods</a>)</li>

<li>Field overrides Field (see <a href='Fields.html#virtual'>virtual fields</a>)</li>

<li>Field overrides Method (see <a href='Fields.html#overrideMethod'>overriding a method</a>)</li>
</ol>

<h1 id='covariance'>Covariance </h1>

<p>Typically when overriding a slot, the signature of the override must match the super type's signature exactly.  However in some cases, the return type of a method may be narrowed - this feature is called <em>covariance</em>.  Covariance is a technique of specialization because the super type's contract remains intact, we've only narrowed the contract of the subtype.  The following details the covariance support:</p>

<ol style='list-style-type:decimal'>
<li>Method overrides Method: supported - <a href='Methods.html#covariance'>details</a></li>

<li>Field overrides Field: unsupported</li>

<li>Field overrides Method: supported - <a href='Fields.html#overrideMethod'>details</a></li>
</ol>

<h1 id='super'>Super </h1>

<p>Often when overriding a method or field, it is desirable to call the super type's implementation.  This is done using the <code>super</code> keyword.  There are two ways to use <code>super</code>:</p>

<pre>// unnamed super
super.someMethod()

// named super
BaseType.super.someMethod()</pre>

<p>The following rules define the use of <code>super</code>:</p>

<ol style='list-style-type:decimal'>
<li>An unnamed super is always on the super class, never a super mixin</li>

<li>Obviously you can't use a named super on something which isn't one of your super types</li>

<li>Named supers allow you to jump up multiple levels of inheritance</li>

<li>Mixins cannot use unnamed super because that would be a non-virtual call on Obj (which is itself really just a problem with Java's lame rules on <code>invokespecial</code>)</li>

<li>Mixins can use named supers on their super mixins</li>
</ol>
<div class='prevNext'>
<div class='prev'><a href='Fields.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Fields.html'>Fields</a></div>
<div class='next'><a href='Facets.html'>Facets</a> <a href='Facets.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a><ul>
<li><a href='#specialization'>Contract Specialization </a></li><li><a href='#implReuse'>Implementation Reuse </a></li></ul>
</li><li><a href='#syntax'>Syntax </a></li><li><a href='#rules'>Inheritance Rules </a></li><li><a href='#restrictions'>Inheritance Restrictions </a></li><li><a href='#overrides'>Overrides </a></li><li><a href='#covariance'>Covariance </a></li><li><a href='#super'>Super </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

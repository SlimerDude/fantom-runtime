<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Functions</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Functions.html'>Functions</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Facets.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Facets.html'>Facets</a></div>
<div class='next'><a href='Closures.html'>Closures</a> <a href='Closures.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Functions</h1>

<h1 id='overview'>Overview </h1>

<p>Functions are first class objects in Fantom modeled via the <code><a href='../sys/Func.html'>sys::Func</a></code> class.  Functions have a signature formally defined as a set of <em>parameter types</em> and a <em>return type</em>.  Functions which don't return an object have a <code>Void</code> return type.  Functions are created one of three ways:</p>

<ol style='list-style-type:decimal'>
<li><strong>Methods</strong>: all methods are really <a href='#methods'>wrappers</a> for a function</li>

<li><strong>Closures</strong>: <a href='Closures.html'>closures</a> are expressions which result in a function</li>

<li><strong>Bind</strong>:  the <code><a href='../sys/Func.html#bind'>Func.bind</a></code> method is used to create a new function by binding arguments to an existing function</li>
</ol>

<h1 id='signatures'>Function Signatures </h1>

<p>The <code>Func</code> class is a built-in generic type, with a custom <a href='TypeSystem.html#funcSignature'>parameterization syntax</a>:</p>

<pre>// format
|A a, B b ... H h -> R|

// examples
|Int a, Int b->Str|  // function which takes two Int args and returns a Str
|Int, Int->Str|      // same as above omitting parameter names
|->Bool|             // function which takes zero args and returns Bool
|Str s->Void|        // function which takes one Str arg and returns void
|Str s|              // same as above, omitting optional void return
|->Void|             // function which takes no arguments and returns void
|->|                 // shortcut for above</pre>

<p>The examples above are type signatures much like you'd use <code>Str</code> or <code>Str[]</code>.</p>

<h1 id='calling'>Calling Functions </h1>

<p>Functions are just objects like everything else in Fantom.  All functions subclass the <code><a href='../sys/Func.html'>Func</a></code> class which provides methods for invoking the function.  The most basic method is <code><a href='../sys/Func.html#callList'>Func.callList</a></code> which takes a list of arguments and returns the result (or null if the return if void):</p>

<pre>// func is a function which takes two Int args and returns an Int
|Int a, Int b->Int| func
func.callList([7, 8])</pre>

<p>The <code>Func</code> class also supports the <code>call</code> method for calling with different arity (zero through eight).  For example to call the function above with two arguments:</p>

<pre>func.call(7, 8)</pre>

<p>Using the <code>call</code> arity versions provides better performance in most cases because it skips packaging up the arguments in a list.</p>

<p>Fantom also supports a bit of syntax sugar to call a function like a normal method call using the <code>()</code> operator.  For example we could call the function above using this syntax:</p>

<pre>func(7, 8)    // syntax sugar for func.call(7, 8)</pre>

<h1 id='typeCompatibility'>Type Compatibility </h1>

<p>Functions have some special rules when it comes to type compatibility. The axiom for type compatibility is that type <code>A</code> is compatible for type <code>B</code> if <code>A</code> can be used whenever <code>B</code> is expected.  Most of the time this means <code>A</code> extends from <code>B</code> through inheritance. For example <code>Int</code> is type compatible with <code>Num</code> because anyplace <code>Num</code> is expected, we can pass an <code>Int</code>.</p>

<p>A type declaration for a function means "these are the are the arguments I'm going to pass to this function and the result I expect back".  So function type <code>A</code> is compatible with function type <code>B</code> if <code>A</code> can accept the arguments which <code>B</code> declares it is going to pass and returns an expected type.  Specifically, function type <code>A</code> is compatible with function type <code>B</code> if these rules apply:</p>

<ol style='list-style-type:decimal'>
<li><code>A</code> declares the same number or less parameters than <code>B</code></li>

<li>Each parameter type in <code>A</code> is compatible with its respective parameter type in <code>B</code></li>

<li><code>A</code> returns a type compatible with <code>B</code> (or if <code>B</code> returns void, then <code>A</code> can return anything)</li>
</ol>

<p>The following table illustrates some examples which shows what <code><a href='../sys/Type.html#fits'>Type.fits</a></code> would report:</p>

<pre>Num  fits  Int  =>  false
Int  fits  Num  =>  true

|Int a|  fits  |Int a|  =>  true
|Num a|  fits  |Int a|  =>  true
|Int a|  fits  |Num a|  =>  false

|Int a|  fits  |Int a, Int b|  =>  true
|Int a, Int b|  fits  |Int a|  =>  false

|->Void|  fits  |->Int|    =>  false
|->Int|   fits  |->Void|   =>  true
|->Int|   fits  |->Num|    =>  true
|->Num|   fits  |->Int|    =>  false</pre>

<p>The first two items in the table above are for reference - <code>Int</code> fits a <code>Num</code>, but not vise versa.  Next let's look closely at this example:</p>

<pre>|Num a|  fits  |Int a| =>  true</pre>

<p>What this shows is that if a function type is declared to take an <code>Int</code>, we can pass a function that accepts a <code>Num</code>.  That may seem counterintuitive at first, but remember that functions are the flip side of normal type checking.  Here is a concrete example of that concept in terms a typical Java or C# programmer might find more natural:</p>

<pre>class WidgetEvent {}
class ButtonEvent : WidgetEvent {}
addButtonListener(|ButtonEvent evt| callback)</pre>

<p>In the code above <code>ButtonEvent</code> is a subclass of <code>WidgetEvent</code>. We've got a method which registers a callback to invoke when a button is pressed - the argument passed to the callback will be a <code>ButtonEvent</code>. However, if we happen to have a function that accepts any <code>WidgetEvent</code>, then it will quite happily accept <code>ButtonEvent</code> arguments:</p>

<pre>static void anyWidgetCallback(WidgetEvent evt) { ... }

button.addButtonListener(&amp;anyWidgetCallback)</pre>

<p>This is what is meant by functions being the "flip side" of normal type checking.  Where normal type checking accepts any <em>specialization</em> of a type, function type checking accepts any <em>generalization</em> of a function.</p>

<h2 id='arityCompatibility'>Arity Compatibility </h2>

<p>Next let's look at how arity (number of parameters) figures into functional type compatibility by dissecting these examples:</p>

<pre>|Int a|  fits  |Int a, Int b|  =>  true
|Int a, Int b|  fits  |Int a|  =>  false</pre>

<p>Here we see that a function that accepts one <code>Int</code> is compatible with a function type that generates two <code>Ints</code>.  This is an ability of all functions in Fantom - to accept more arguments than they will use.  It is kind of like <a href='Methods.html#defaultParams'>default parameters</a> in reverse.  We use this technique all the time in the core classes.  For example the <code><a href='../sys/Map.html#each'>Map.each</a></code> method is used to iterate the key/value pairs:</p>

<pre>// actual signature of Map.each
Void each(|V value, K key| c)

// iterate with function that only accepts value
map.each |Obj value| { echo(value) }

// or iterate with function that accepts both value and key
map.each |Obj value, Obj key| { echo("$key = $value") }</pre>

<p>Many of the APIs which accept a function will pass multiple parameters, but you don't actually have to use all of those parameters.</p>

<h1 id='methods'>Methods </h1>

<p>In Fantom, all methods wrap a function accessed via the <code><a href='../sys/Method.html#func'>Method.func</a></code> method.  The <code>Func</code> for a method serves as its reflective handle.  This relationship between functions and methods is a key aspect of how Fantom bridges object oriented and functional programming (the flip side is that all functions are an object).</p>

<p>Mapping static methods to functions is straight forward:</p>

<pre>static Int add(Int a, Int b) { return a + b }

func := type.method("add").func
nine := func(7, 2)</pre>

<p>One gotcha to be aware of - you can't access the <code>Method.func</code> method without parenthesis, and then use the parenthesis to invoke the function because the parenthesis will bind to the <code>Method.func</code> call:</p>

<pre>type.method("add").func               // returns Func
type.method("add").func()             // same as above

type.method("add").func().call(7,2)   // invoke function
type.method("add").func()(7,2)        // same as above</pre>

<p>Instance methods map to a function where the first argument is the implicit <code>this</code> parameter.  If you've ever used Python this concept is pretty much in your face with the explicit <code>self</code> argument. Fantom lets you use instance methods like Java or C#, but we still need to map those OO methods to functions.  Let's consider this example:</p>

<pre>m := Str#replace
f := m.func

// note method params does not include the
// implicit this, but the function params does
m.params  => [sys::Str from, sys::Str to]
f.params  => [sys::Str this, sys::Str from, sys::Str to]

// both of these result in "hello!"
s1 := "hi!".replace("hi", "hello")
s2 := f("hi!", "hi", "hello")</pre>

<p>The code above gets the <code>Str.replace</code> instance method as a function.  The <code>replace</code> method takes two string arguments, but when flattened into a function it takes three string arguments because we have to account for the implicit <code>this</code> argument.</p>

<h1 id='immutable'>Immutable Functions </h1>

<p>An immutable function is one proven to be thread safe.  You can check immutability at runtime via <code><a href='../sys/Obj.html#isImmutable'>sys::Obj.isImmutable</a></code> and attempt to convert a function via <code><a href='../sys/Obj.html#toImmutable'>sys::Obj.toImmutable</a></code>.  Immutable functions are often required when working with <a href='Actors.html'>actors</a>.</p>

<p>Immutability works as follows:</p>

<ul>
<li>Method functions are always immutable - see <code><a href='../sys/Method.html#func'>sys::Method.func</a></code></li>

<li>Closures which only capture final, const variables are always immutable; toImmutable always returns this</li>

<li>Closures which capture non-final or non-const variables are always mutable; toImmutable always throws NotImmutableErr</li>

<li>Closure which capture non-final variables which aren't known to be immutable until runtime (such as Obj or List) will return false for isImmutable, but will provide a toImmutable method which attempts to bind to the current variables by calling toImmutable on each one</li>

<li>Functions created by <code><a href='../sys/Func.html#bind'>Func.bind</a></code> are immutable if the original function is immutable <em>and</em> every bound argument is immutable</li>
</ul>

<p>The definition of a <em>final variable</em> is a variable which is never reassigned after it is initialized.  Any variable which is reassigned is considered a non-final variable.</p>
<div class='prevNext'>
<div class='prev'><a href='Facets.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Facets.html'>Facets</a></div>
<div class='next'><a href='Closures.html'>Closures</a> <a href='Closures.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#signatures'>Function Signatures </a></li><li><a href='#calling'>Calling Functions </a></li><li><a href='#typeCompatibility'>Type Compatibility </a><ul>
<li><a href='#arityCompatibility'>Arity Compatibility </a></li></ul>
</li><li><a href='#methods'>Methods </a></li><li><a href='#immutable'>Immutable Functions </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

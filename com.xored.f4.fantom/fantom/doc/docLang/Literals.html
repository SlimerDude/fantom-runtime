<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Literals</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Literals.html'>Literals</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Structure.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Structure.html'>Structure</a></div>
<div class='next'><a href='Expressions.html'>Expressions</a> <a href='Expressions.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Literals</h1>

<h1 id='overview'>Overview </h1>

<p>The following types have a literal syntax:</p>

<ul>
<li><a href='#bool'>sys::Bool</a></li>

<li><a href='#int'>sys::Int</a></li>

<li><a href='#float'>sys::Float</a></li>

<li><a href='#decimal'>sys::Decimal</a></li>

<li><a href='#str'>sys::Str</a></li>

<li><a href='#duration'>sys::Duration</a></li>

<li><a href='#uri'>sys::Uri</a></li>

<li><a href='#type'>sys::Type</a></li>

<li><a href='#slot'>sys::Slot</a></li>

<li><a href='#range'>sys::Range</a></li>

<li><a href='#list'>sys::List</a></li>

<li><a href='#map'>sys::Map</a></li>
</ul>

<p>The three types <code>Bool</code>, <code>Int</code>, and <code>Float</code> are <a href='TypeSystem.html#valueTypes'>value-types</a>. These types are not necessarily passed as object references, but rather passed by value on the call stack.  When value types are coerced to/from reference types like <code>Obj</code> and <code>Num</code>, the compiler will generate boxing/unboxing operations.</p>

<h1 id='bool'>Bool </h1>

<p>There are exactly two values of <code><a href='../sys/Bool.html'>sys::Bool</a></code> which are represented using the <code>true</code> and <code>false</code> keywords.</p>

<p>As a value-type <code>Bool</code> fields default to <code>false</code> instead of <code>null</code>. However <code>Bool?</code> does default to null.</p>

<h1 id='int'>Int </h1>

<p><code><a href='../sys/Int.html'>sys::Int</a></code> is used to represent a 64-bit signed integer.  Fantom does not have any integer types for smaller precisions.  Fantom also uses Int to represent a single character of a string as a Unicode code point (which happens to be handy because there are actually more than 2^16 Unicode characters).  Int is <code>const</code> which means that all instances are immutable.</p>

<p>Int literals are expressed as a string of decimal digits.  An Int can also be represented in hexadecimal if prefixed with <code>0x</code>.  Octal notation is not supported.  You can use the <code>_</code> underbar anywhere within an <code>Int</code> literal as a separator to make your code more readable.</p>

<p>Fantom also permits C style character literals to represent a Unicode code point as an <code>Int</code> literal.  Character literals are surrounded with the tick and support the following escapes:</p>

<pre>\b  \f  \n  \r  \t  \"  \'  \` \$  \\  \uXXXX</pre>

<p>The last escape <code>\uXXXX</code> specifies a Unicode code point using a a four digit hexadecimal number.</p>

<p><code>Int</code> literal examples:</p>

<pre>45
-89_039
0xcafebabe
0xCAFE_BABE
'?'
'\n'
'\u03ab'
'\u00F2'</pre>

<p>As a value-type <code>Int</code> fields default to <code>0</code> instead of <code>null</code>. However <code>Int?</code> does default to null.</p>

<h1 id='float'>Float </h1>

<p><code><a href='../sys/Float.html'>sys::Float</a></code> is used to represent a 64-bit floating point number.  Fantom does not have a type for 32-bit floats.  Float is <code>const</code> which means that instances are immutable.</p>

<p>Float literals are expressed like C, Java, etc using a string of decimal digits, optional dot and fraction, and optional exponent.  A "f" or "F" suffix is required on Floats to distinguish from Decimals.  You can use the <code>_</code> underbar as a separator.  Examples of <code>Float</code> literals:</p>

<pre>3.0f
3f
3.0F
123_456.0f
3e6f
0.2e+6f
1_2.3_7e-5_6f</pre>

<p>As a value-type <code>Float</code> fields default to <code>0.0f</code> instead of <code>null</code>. However <code>Float?</code> does default to null.</p>

<h1 id='decimal'>Decimal </h1>

<p><code><a href='../sys/Decimal.html'>sys::Decimal</a></code> is used to immutably represent a decimal floating point which provides better precision than a Float.  Decimals are ideal for financial applications where Floats may incur rounding errors. Decimals are backed by <code>BigDecimal</code> in Java and <code>System.Decimal</code> in .NET.</p>

<p>Decimal literals are expressed just like Float literals except they use the "d" or "D" suffix.  If a float literal with a fraction or exponent is expressed with no suffix, then it is assumed to be a decimal.  Examples of <code>Decimal</code> literals:</p>

<pre>4d
4.0
4.00
123_456d
3e6
0.2e+6D
1_2.3_7e-5_6</pre>

<p class='NOTE'>NOTE: decimals don't operate exactly the same between the Java and .NET platform.  Java uses BigDecimal which has an infinite range, while .NET uses System.Decimal with a range of of 28 significant digits and a range of 1E-28 to 7.9E+28.  There is also a difference in equality between the two platforms:</p>

<pre>3.00 == 3.0   =>  false on Java
3.00 == 3.0   =>  true on .NET
3.00 &lt;=> 3.0  =>  zero on both platforms</pre>

<p>Java treats trailing zeros as significant for equality, but they are insignificant on .NET.  However both platforms produce consistent results for the <code>Obj.compare</code> method.</p>

<h1 id='str'>Str </h1>

<p><code><a href='../sys/Str.html'>sys::Str</a></code> is used to represent a sequence of Unicode characters.  Str is <code>const</code> which means all instances of Str are immutable.  Use <code><a href='../sys/StrBuf.html'>sys::StrBuf</a></code> when you need a mutable sequence of characters.</p>

<p>Str literals are surrounded by the <code>"</code> double quote character.  Special characters may be escaped using the list of escape sequences specified above for <a href='#int'>Int</a> character literals. A couple <code>Str</code> literal examples:</p>

<pre>"hello"
"line 1\nline 2"
"It is 73\u00B0 Fahrenheit outside!"</pre>

<h2 id='multiLineStr'>Multi-line Strs </h2>

<p>Str literals may span multiple lines in which case the newlines are always normalized to <code>\n</code> regardless of how newlines were encoded in the source code text.  The first non-whitespace char of each line must be aligned to the right of the opening quote or else it is a compile time error:</p>

<pre>x :=
  "line 1
    line 2
   line3"</pre>

<p>The example above compiles into <code>"line1\n line2\nline3"</code>.  Note that spacing to the right of the quote is maintained, but spacing to the left is stripped off in the string literal.  If you use tabs then you must use a matching number of leading tabs followed by space characters:</p>

<pre>\t\tx := "line 1
\t\t      line 2"</pre>

<h2 id='interpolation'>Str Interpolation </h2>

<p>Str literals support string interpolation which allow arbitrary Fantom expressions to be embedded inside the string literals.  Embedded expressions are prefixed using the <code>$</code> dollar sign and surrounded with <code>{</code> and <code>}</code> braces. If the expression is a simple identifier or sequence of dotted identifiers then the braces may be omitted.  Use the <code>\$</code> escape sequence if you wish to express the dollar sign itself.</p>

<p>Interpolated strings are expressions which compute a new Str at runtime - they are merely syntax sugar for string concatenation.  For example:</p>

<pre>"x is $x, in hex $x.toHex, and x+8 is ${x+8}"</pre>

<p>is syntax sugar for:</p>

<pre>"x is " + x + ", in hex " + x.toHex + ", and x+8 is " + (x+8)</pre>

<p>String interpolation makes string formatting easier to read and write. Fantom coding convention is to always use string interpolation rather than concatenation.</p>

<h2 id='localeLiterals'>Locale Literals </h2>

<p>Str interpolation supports a special syntax to easily work with localized strings:</p>

<pre>// qualified pod::key
"$&lt;pod::key>"  =>  Pod.find("pod").locale("key")

// lookup key within current pod
"$&lt;key>" =>  EnclosingType#.pod.locale("key")

// lookup key and automatically add key to `locale/en.props`
"$&lt;key=Text>"  =>  EnclosingType#.pod.locale("key", "Text")</pre>

<p>Refer to <a href='Localization.html#localeLiterals'>Localization</a> for in in-depth discussion.</p>

<h2 id='tripleQuotes'>Triple Quotes </h2>

<p>Fantom also supports <code>"""</code> triple quoted string literals.  These work exactly like normal string literals except that you don't need to escape the double quote <code>"</code> character.  Interpolation and multi-line work exactly the same:</p>

<pre>echo("""Do you know "What lies beneath the shadow of the statue"?""")</pre>

<h2 id='strDsl'>Str DSL </h2>

<p>You can also write a Str literal using the <a href='DSLs.html'>DSL syntax</a>.  A Str DSL can contain any character except the sequence "|>".  Neither the "\" or "$" character are treated specially:</p>

<pre>echo(Str &lt;|no \ or $ escapes need, and
           multi-line works too|>)</pre>

<p>Str DSL literals may be multi-line following the leading whitespace rules for standard strings.</p>

<h1 id='duration'>Duration </h1>

<p>In Java, an API which requires a measurement of time typically uses a long with the number of milliseconds.  This tends to be a bit ambiguous and becomes problematic when you need finer precision.  Fantom APIs always use a typed value for time.  Absolute time measurement is represented using <code><a href='../sys/DateTime.html'>sys::DateTime</a></code> and relative time measurement is represented by <code><a href='../sys/Duration.html'>sys::Duration</a></code> - both are normalized using nanosecond precision. For example to represent 5 seconds you could use the <code>Duration.make</code> constructor:</p>

<pre>Duration.make(5_000_000_000)  // longhand
Duration(5_000_000_000)       // shorthand</pre>

<p>But all those zeros make it unwieldy.  Plus it is a little inefficient because it requires creating a new instance of <code>Duration</code> every time the expression is executed. In Fantom, <code>Durations</code> are expressed using a literal syntax formatted as a decimal number with an optional dotted fraction and one of the following suffixes:</p>

<pre>ns:  nanoseconds  (x 1)
ms:  milliseconds (x 1,000,000)
sec: seconds      (x 1,000,000,000)
min: minutes      (x 60,000,000,000)
hr:  hours        (x 3,600,000,000,000)
day: days         (x 86,400,000,000,000)</pre>

<p>Examples of <code>Duration</code> literals:</p>

<pre>4ns
100ms
-0.5hr</pre>

<h1 id='uri'>Uri </h1>

<p>The <code><a href='../sys/Uri.html'>sys::Uri</a></code> class is used to represent a Uniform Resource Identifier which is the foundation of Fantom's subsystem for naming and resolution.  <code>Uris</code> have their own literal syntax using the back tick:</p>

<pre>`index.html`
`/some/path/file.txt`
`http://fantom.org/`
`TPS Report.doc`</pre>

<p>Note that when working with URIs in Fantom and representing them as literals we always use <em>standard form</em>.  For example a space is represented using a normal space, not encoded as "%20":</p>

<pre>`TPS Report.doc`.toStr      // yields "TPS Report.doc"
`TPS Report.doc`.encode     // yields "TPS%20Report.doc"
`TPS%20Report.doc`.toStr    // yields "TPS%20Report.doc" (probably not what you want)
`TPS%20Report.doc`.encode   // yields "TPS%2520Report.doc" (probably not what you want)</pre>

<p>Like strings, you can embed the standard <a href='#int'>escape sequences</a> into a Uri literal including Unicode code points.  Unicode chars are UTF-8 encoded into octects before the URI is percent encoded according to RFC 3986 (see <code><a href='../sys/Uri.html#encode'>sys::Uri.encode</a></code>).</p>

<p>Uris support interpolation following the same rules as <a href='#interpolation'>Str interpolation</a>:</p>

<pre>file := "file.txt"
`/dir/$file`  =>  ("/dir/" + file).toUri</pre>

<h1 id='type'>Type </h1>

<p>The <code><a href='../sys/Type.html'>sys::Type</a></code> class is the foundation of the Fantom reflection APIs.  Typically <code>Type</code> instances are queried using the <code><a href='../sys/Type.html#of'>sys::Type.of</a></code> method.  But you can also represent a <code>Type</code> instance using the type literal syntax which is simply a type name followed by the <code>#</code> symbol:</p>

<pre>Str#
acme::SomeType#</pre>

<p>If a fully qualified type name is not specified, then the typename is resolved according to the source file's <code>using</code> statements.</p>

<h1 id='slot'>Slot </h1>

<p>You can create a slot literal using the syntax:</p>

<pre>Int#plus
#echo</pre>

<p>If the type name is omitted, then the slot literal is resolved against the enclosing class.  A slot literal resolves to a <code><a href='../sys/Field.html'>sys::Field</a></code> or <code><a href='../sys/Method.html'>sys::Method</a></code>. Slot literals have the same semantics as reflection via <code>Type.slot</code> except they can be statically checked by the compiler.</p>

<h1 id='range'>Range </h1>

<p>A <code><a href='../sys/Range.html'>sys::Range</a></code> represents a contiguous range of integers from start to end.  Ranges may be represented as literals in Fantom source code as <code>start..end</code> for an inclusive end or <code>start..&lt;end</code> for an exclusive range.  Inclusive and exclusive determines if the end index is included in the range (start is always inclusive).  Example of <code>Range</code> literals:</p>

<pre>0..5    // 0 to 5 (end is inclusive)
0..&lt;5   // 0 to 4 (end is exclusive)
x..&lt;y   // x to y-1 (end is exclusive)</pre>

<p>Note that the <code>..</code> and <code>..&lt;</code> operators may be used with any arbitrary expression according to <a href='Expressions.html#precedence'>operator precedence</a>.  These operators are just syntax sugar for constructing a range via <code><a href='../sys/Range.html#make'>sys::Range.make</a></code>.</p>

<h1 id='list'>List </h1>

<p>The <code><a href='../sys/List.html'>sys::List</a></code> class stores an ordered list of objects.  Lists may be instantiated using the following literal syntax:</p>

<pre>// syntax format where V is the optional item type, and
// the items are arbitrary expressions:
V[item0, item1, ... itemN]

// examples
Int[10, 20, 30]     // list of the three Ints 10, 20, and 30
[10, 20, 30]        // same as above using type inference
Int[,]              // empty list of Ints
[,]                 // empty list of Obj?</pre>

<p>In most simple cases a <code>List</code> literal is just a list of comma separated expressions inside square brackets.  If the type prefix is omitted, then <em>type inference</em> is used to determine the type of the items.  The type of the items is determined by computing the most specific class all the items share (mixins types are not taken into account).  For example:</p>

<pre>[1, 2, 3]        // evaluates to Int[]
[1, null, 3]     // evaluates to Int?[]
[1f, 2f, 3f]     // evaluates to Float[]
[1, 2f, 3]       // evaluates to Num[]
[1, "2", 3]      // evaluates to Obj[]
Num[1, 2, 3]     // evaluates to Num[]
[[10,20], [30]]  // evaluates to Int[][]</pre>

<p>In the case of <code>[1,2f,3]</code> the list contains both <code>Ints</code> and <code>Floats</code> which share <code>Num</code> as their most specific common base class.  However the list <code>[1,"2",3]</code> contains <code>Ints</code> and <code>Strs</code> which don't share a common base class other than <code>Obj</code>.  The list <code>Num[1,2,3]</code> would evaluate to <code>Int[]</code> if type inference was used, but if we might put <code>Floats</code> into the list, then we need to explicitly specify the type.</p>

<p>Often the compiler will infer a list to have a non-nullable type. If the list might store null values, then you will need to explicitly type it:</p>

<pre>[1,2,3]       // cannot store null
Int?[1,2,3]   // can store null</pre>

<p>The empty list is denoted using the special syntax <code>[,]</code>.  Often you will specify a type - for example <code>Str[,]</code> is an empty list of strings.  If a type is not specified, then the empty list evaluates to a <code>Obj?[,]</code>.</p>

<p>If a list literal without an explicit type is used as a field initializer, then it infers its type from the field's declared type:</p>

<pre>Str[] names := [,]     // initial value inferred to be Str[,]
Num[] nums  := Int[,]  // initial value is Int[,]</pre>

<p>See <a href='Appendix.html#typeInference'>Appendix</a> for the formal rules used for type inference of lists.</p>

<h1 id='map'>Map </h1>

<p>The <code><a href='../sys/Map.html'>sys::Map</a></code> class stores a set of key/value pairs using a hash table.  Maps may be instantiated using the following literal syntax:</p>

<pre>// syntax format where K:V is the optional map type,
// and the keys and values are arbitrary expressions:
[V:K][key0:value0, key1:value1, ... keyN:valueN]

// examples
[Int:Str][1:"one", 2:"two"]  // map of Strs keyed by Int
Int:Str[1:"one", 2:"two"]    // same as above with shorthand type syntax
[1:"one", 2:"two"]           // same as above using type inference
Int:Str[:]                   // empty Int:Str map
[:]                          // empty map of Obj:Obj?</pre>

<p>The <code>Map</code> literal syntax is like <code>List</code> except we specify the key value pairs using a colon.  The type prefix of a map literal is any valid <a href='TypeSystem.html#mapSignature'>map signature</a>.  If the type prefix is omitted, then type inference is used to determine the type of the keys and values using the same rules as list literals.  For example:</p>

<pre>[1:"one", 2:"two"]    // evaluates to Int:Str
[1:"one", 2:null]     // evaluates to Int:Str?
[1:"one", 2f:"two"]   // evaluates to Num:Str
[1:"one", 2f:null]    // evaluates to Num:Str?
[1:"one", 2f:0xabcd]  // evaluates to Num:Obj
[0:["one"]]           // evaluates to Int:Str[]</pre>

<p>The empty map is denoted using the special syntax <code>[:]</code> with or without a type prefix.</p>

<p>Note that maps may not be typed with a nullable key.  If you are using type inference, you might need to explicitly type a map which will store null:</p>

<pre>[1:"one", 2:"two"]           // cannot store null values
Int:Str?[1:"one", 2:"two"]   // can store null values</pre>

<p>The type <code>Int:Str?</code> is a map with <code>Int</code> keys and <code>Str?</code> values.  However the type <code>[Int:Str]?</code> is map of <code>Int:Str</code> where the map variable itself might be null.</p>

<p>If a map literal without an explicit type is used as a field initializer, then it infers its type from the field's declared type:</p>

<pre>Str:File[] files := [:]   // initial value inferred as Str:File[:]</pre>

<p>See <a href='Appendix.html#typeInference'>Appendix</a> for the formal rules used for type inference of maps.</p>
<div class='prevNext'>
<div class='prev'><a href='Structure.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Structure.html'>Structure</a></div>
<div class='next'><a href='Expressions.html'>Expressions</a> <a href='Expressions.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#bool'>Bool </a></li><li><a href='#int'>Int </a></li><li><a href='#float'>Float </a></li><li><a href='#decimal'>Decimal </a></li><li><a href='#str'>Str </a><ul>
<li><a href='#multiLineStr'>Multi-line Strs </a></li><li><a href='#interpolation'>Str Interpolation </a></li><li><a href='#localeLiterals'>Locale Literals </a></li><li><a href='#tripleQuotes'>Triple Quotes </a></li><li><a href='#strDsl'>Str DSL </a></li></ul>
</li><li><a href='#duration'>Duration </a></li><li><a href='#uri'>Uri </a></li><li><a href='#type'>Type </a></li><li><a href='#slot'>Slot </a></li><li><a href='#range'>Range </a></li><li><a href='#list'>List </a></li><li><a href='#map'>Map </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

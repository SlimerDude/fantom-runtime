<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>Expressions</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>docLang</a></li>
  <li>&gt;</li>
  <li><a href='Expressions.html'>Expressions</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='prevNext'>
<div class='prev'><a href='Literals.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Literals.html'>Literals</a></div>
<div class='next'><a href='Statements.html'>Statements</a> <a href='Statements.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
<h1 class='title'>Expressions</h1>

<h1 id='precedence'>Operator Precedence </h1>

<p>Fantom's expression syntax is very similar to C, Java, C# and company. Operators in order of precedence:</p>

<ul>
<li>Primary: <code>(x)   x.y   x.y()   x->y()   x?.y   x?.y()   x?->y()   x[y]</code></li>

<li>Unary: <code>++x   --x   x++   x--  !x   +x   -x   (T)x   &amp;x</code></li>

<li>Multiplicative: <code>*   /   %</code></li>

<li>Additive: <code>+   -</code></li>

<li>Range: <code>..   ..&lt;</code></li>

<li>Relational: <code>&lt;   &lt;=   >=   >   &lt;=>   is   isnot   as</code></li>

<li>Equality: <code>==   !=   ===   !==</code></li>

<li>Conditional And: <code>&amp;&amp;</code></li>

<li>Conditional Or: <code>||</code></li>

<li>If Expr: <code>x?t:f   x?:y</code></li>

<li>Assignment: <code>=   *=   /=   %=   +=   -=</code></li>

<li>Collection Add: <code>,</code></li>
</ul>

<h1 id='shortcuts'>Shortcut Operators </h1>

<p>Fantom is a pure OO language in that everything is an object you can call methods on - even value-types such as <code>Bool</code> and <code>Int</code>.  As such almost all the operators are really just method calls.  We call these operators the <em>shortcut operators</em> because they are just syntax sugar for calling a specific method:</p>

<pre>a + b     =>  a.plus(b)
a - b     =>  a.minus(b)
a * b     =>  a.mult(b)
a / b     =>  a.div(b)
a % b     =>  a.mod(b)
a[b]      =>  a.get(b)
a[b] = c  =>  a.set(b, c)
-a        =>  a.negate()
++a, a++  =>  a = a.increment()
--a, a--  =>  a = a.decrement()
a == b    =>  a.equals(b)
a != b    =>  !a.equals(b)
a &lt;=> b   =>  a.compare(b)
a > b     =>  a.compare(b) > 0
a >= b    =>  a.compare(b) >= 0
a &lt; b     =>  a.compare(b) &lt; 0
a &lt;= b    =>  a.compare(b) &lt;= 0
a,b,c     =>  it.add(a).add(b).add(c)</pre>

<p>For example say we have two variables <code>a</code> and <code>b</code> both of type <code>Int</code>. Then the expression <code>a+b</code> is really just syntax sugar for calling <code><a href='../sys/Int.html#plus'>sys::Int.plus</a></code> as <code>a.plus(b)</code>.  See <a href='Methods.html#operators'>Method Operators</a> for a detailed discussion.</p>

<h2 id='prefixPostfix'>Prefix and Postfix Operators </h2>

<p>The <code>++</code> and <code>--</code> operators can be prefix or postfix just like C family languages.  Both of these operators assign the result of the call to <code>increment</code> or <code>decrement</code> to the operand variable. If prefix then the expression evaluates to the assignment.  If postfix then the expression evaluates to the value of the operand before <code>increment</code> or <code>decrement</code> is assigned.</p>

<h2 id='equality'>Equality Operators </h2>

<p>The equality operators <code>==</code> and <code>!=</code> both make use of the <code><a href='../sys/Obj.html#equals'>sys::Obj.equals</a></code> virtual method.  Most types override this method to compare value equality. If <code>equals</code> is not overridden, then the default behavior is to compare reference equality.</p>

<h2 id='relational'>Relational Operators </h2>

<p>The relational operators like <code>&lt;</code> and <code>></code> all use the <code><a href='../sys/Obj.html#compare'>sys::Obj.compare</a></code> virtual method.  Many types with the notation of ordering will override this method to return -1, 0, or 1.  If <code>compare</code> is not overridden, then the default implementation will compare the result of the operands <code>toStr</code> method.</p>

<p>The compiler translates the numeric return into a boolean condition based on which operator was used.  The special <code>&lt;=></code> operator returns the <code>Int</code> value of -1, 0, 1 directly.  You will commonly use the <code>&lt;=></code> operator for custom sorts with a closure:</p>

<pre>people.sort |Person a, Person b->Int| { return a.age &lt;=> b.age }</pre>

<p>If that code doesn't make any sense to you, then don't worry - just keep reading until we cover <a href='Closures.html'>closures</a>.</p>

<h2 id='comparisonsWithNull'>Comparisons with Null </h2>

<p>The equality and relational operators have special handling if either operand is <code>null</code> such that a <code>NullErr</code> exception is never raised. For equality a non-null and null are never equal, but two nulls are always equal.  For relational operators, null is always less than a non-null object.  Special handling for null does <em>not</em> apply if the <code>equals</code> or <code>compare</code> method is used as a normal method call.  Nor does this special handling apply for other shortcut operators.</p>

<h1 id='same'>Same Operators </h1>

<p>The <code>===</code> and <code>!==</code> operators are called the <em>same</em> and <em>not same</em> operators.  These operators are used to check if two variables reference the same object instance in memory.  Unlike the <code>==</code> and <code>!=</code> shortcut operators, the same and not same operators do not result in the <code>equals</code> method call.  These operators are not allowed to be used against value-types.</p>

<h1 id='cond'>Conditional Operators </h1>

<p>The conditional <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> operators are used with boolean expressions.  Use <code>&amp;&amp;</code> to perform a logical <code>and</code> and <code>||</code> to perform a logical <code>or</code>.  Both of these operators are short circuiting in that the second test is skipped if the first test is conclusive ('false' for <code>&amp;&amp;</code> and <code>true</code> for <code>||</code>).  The <code>!</code> operator performs a logical <code>not</code>. Code examples for the conditional operators:</p>

<pre>t := true
f := false
t &amp;&amp; f  => evaluates to false
t &amp;&amp; t  => evaluates to true
f || t  => evaluates to true
!t      => evaluates to false</pre>

<h1 id='ternary'>Ternary Operator </h1>

<p>The ternary operator combines three expressions as a convenient way to assign a value based on an if/else condition:</p>

<pre>condExpr ? trueExpr : falseExpr</pre>

<p>The <code>condExpr</code> must evaluate to a boolean.  If <code>condExpr</code> evaluates to <code>true</code> then the whole expression evaluates to <code>trueExpr</code>, otherwise to <code>falseExpr</code>.  Examples:</p>

<pre>3 > 4 ? "yes" : "no"  => evaluates to "no"
6 > 4 ? "yes" : "no"  => evaluates to "yes"</pre>

<p>Fantom also supports use of a <code>throw</code> statement as one of the results of a ternary operation:</p>

<pre>val := isValid(key) ? map[key] : throw ArgErr("invalid key")</pre>

<h1 id='nullConvenience'>Null Convenience Operators </h1>

<p>Fantom supports several of the operators found in Groovy to make working with null more convenient:</p>

<ul>
<li><strong>Elvis Operator</strong> <code>x ?: y</code>  (look at it sideways as a "smiley" face)</li>

<li><strong>Safe Invoke</strong> <code>x?.y</code></li>

<li><strong>Safe Dynamic Invoke</strong> <code>x?->y</code></li>
</ul>

<h2 id='elvis'>Elvis Operator </h2>

<p>The elvis operator evaluates the left hand side.  If it is non-null then it is result of the whole expression.  If it is null, then the result of the whole expression is the right hand side expression. The right hand side expression is short circuited if the left hand side evaluates to non-null.  It is similar to how you might use the ternary operator:</p>

<pre>// hard way
file != null ? file : defaultFile

// easy way
file ?: defaultFile</pre>

<p>The elvis operator may not be used on a non-nullable type since by definition it will not be null.</p>

<p>Like the <a href='#ternary'>ternary</a> operator the elvis operator may use a <code>throw</code> statement as the right hand side of the expression:</p>

<pre>val := map[key] ?: throw ArgErr("key not found")</pre>

<h2 id='safeInvoke'>Safe Invoke </h2>

<p>The safe invoke operators are designed to short circuit if the target of method call or field access is null.  If short circuited, then the whole expression evaluates to null.  It is quite useful to skip checking a bunch of values for null during a call chain:</p>

<pre>// hard way
Str? email := null
if (userList != null)
{
  user := userList.findUser("bob")
  if (user != null) email = user.email
}

// easy way
email := userList?.findUser("bob")?.email</pre>

<p>If at any point in a null-safe call chain we detect null, then the whole expression is short circuited and the expression evaluates to null.  You can use <code>?-></code> as a null-safe version of the <a href='Methods.html#dynamicInvoke'>dynamic invoke operator</a>.</p>

<p>The safe invoke operator may not be used on a non-nullable type since by definition it will not be null.  The result of a safe invoke is always nullable:</p>

<pre>x := str.size   =>  x is typed as Int
x := str?.size  =>  x is typed as Int?</pre>

<h1 id='typeChecking'>Type Checking </h1>

<p>The cast operator is used to perform a type conversion.  The cast syntax uses parenthesis like C languages - such as <code>(Int)x</code>.  If a type cast fails at runtime, then a <code><a href='../sys/CastErr.html'>sys::CastErr</a></code> exception is raised.</p>

<p>The <code>is</code>, <code>isnot</code>, and <code>as</code> operators are used check an object's type at runtime:</p>

<ul>
<li><code>is</code> operator returns a <code>Bool</code> if the operand implements the specified type (like Java's <code>instanceof</code> operator).  If target is null, then evaluates to false.</li>

<li><code>isnot</code> operator is semantically equivalent to <code>!(x is Type)</code>. If target is null then evaluates to true.</li>

<li>The <code>as</code> operator returns the object cast to the specified type or <code>null</code> it not an instance of that type (like C#):</li>
</ul>

<pre>Obj obj := 123
obj is Str     =>  evaluates to false
obj is Num     =>  evaluates to true
obj isnot Str  =>  evaluates to true
obj isnot Num  =>  evaluates to false
obj as Float   =>  evaluates to null
obj as Int     =>  evaluates to 6 (expr is typed as Int)</pre>

<p>Nullability of types is not considered when using the <code>is</code>, <code>isnot</code>, and <code>as</code> operators.  For example these two expressions are considered equivalent:</p>

<pre>obj is Str
obj is Str?</pre>

<p>The <code>as</code> operator by definition returns a nullable type.  For example the following expression evaluates to <code>Str?</code>, not <code>Str</code>:</p>

<pre>x := obj as Str  => x is typed as Str?</pre>

<h1 id='indexing'>Indexing </h1>

<p>Depending on how it is used, the <code>[]</code> operator maps to three different shortcuts:</p>

<pre>a[b]      =>  a.get(b)
a[b] = c  =>  a.set(b, c)
a[b]      =>  a.getRange(b) if b is Range</pre>

<p>Typically <code>a[b]</code> is a shortcut for calling <code>a.get(b)</code>.  For example the <code><a href='../sys/List.html#get'>sys::List.get</a></code> method allows you to lookup a list item by it's <code>Int</code> index.  Whenever a class supports a <code>get</code> operator method you can use <code>[]</code> as a shortcut.  Consider this code:</p>

<pre>list := ["a", "b", "c"]
list.get(2)
list[2]
list.get("2")  // error
list["2"]      // error</pre>

<p>The expression <code>list[2]</code> is exactly the same code as <code>list.get(2)</code>.  The last two lines result in a compiler error because we are attempting to pass a <code>Str</code> when an <code>Int</code> is expected.</p>

<p>When the indexing shortcut is used on the left hand side of an assignment such as <code>a[b] = c</code> then the index operator maps to <code>a.set(b, c)</code>.  For example these two lines of code have identical behavior:</p>

<pre>map.set("tmj", "Too Much Joy")
map["tmj"] = "Too Much Joy"</pre>

<p>If the <code>[]</code> operator is used with a <code><a href='../sys/Range.html'>sys::Range</a></code> index, then we map to the <code>a.getRange(b)</code> method which performs a slice.  Slicing is used to create sub-strings and sub-lists.  Some example code which creates sub-strings:</p>

<pre>s := "abcd"
s[0..2]  => "abc"
s[3..3]  => "d"
s[0..&lt;2] => "ab"

start := 0; end := 2
s[start..&lt;end] => "ab"</pre>

<p>We use <code>..</code> to specify an inclusive end index, and <code>..&lt;</code> to specify an exclusive end index.  Also note how we can use any arbitrary expression with the range operators to define compact slice expressions.</p>

<p>By convention Fantom APIs which support integer indexing allow the use of negative integers to index from the end of the list.  For example <code>-1</code> can be used to index the last item of a list (or the last character of a string).  Using negative indexes works with all three shortcuts:</p>

<pre>list := ["a", "b", "c", "d"]
list[-2]           =>  evaluates to "c"
list[-1] = "last"  =>  replaces list[3] with "last"
list[1..-1]        =>  evaluates to ["b", "c", "last"]</pre>

<p>Use of negative indexes applies to most methods on <code>List</code> and <code>Str</code> which take an index argument.</p>

<h1 id='bitwise'>Bitwise Operators </h1>

<p>Fantom doesn't have bitwise operators, instead normal method calls are used:</p>

<pre>~a      =>   a.not
a &amp; b   =>   a.and(b)
a | b   =>   a.or(b)
a ^ b   =>   a.xor(b)
a &lt;&lt; b  =>   a.shiftl(b)
a >> b  =>   a.shiftr(b)</pre>

<h1 id='serialization'>Serialization Expressions </h1>

<p>Fantom supports three expression constructs which are designed to make the programming language a true superset of the <a href='Serialization.html'>serialization</a> syntax:</p>

<ul>
<li>Simples</li>

<li>It-Blocks</li>

<li>Collections</li>
</ul>

<h2 id='simples'>Simples </h2>

<p><a href='Serialization.html#simple'>Simples</a> are special serializable types which serialize via a string represenation.  Fantom allows the use of a simple expression:</p>

<pre>&lt;type>(&lt;str>)

// for example:
Version("3.2")

// is syntax sugar for
Version.fromStr("3.2")</pre>

<p>To use this expression, the type must have a static method called <code>fromStr</code> which takes a <code>Str</code> parameter and returns an instance of itself.  The method may contain additional parameters if they have default values.  The type does not have to implement the <code><a href='../sys/Serializable.html'>sys::Serializable</a></code> facet to use this expression (although it does if you want to serialize it).  Simple expressions are a subset of <a href='Methods.html#constructionCalls'>construction calls</a>.</p>

<h2 id='itBlocks'>It-Blocks </h2>

<p><a href='Closures.html#itBlocks'>It-blocks</a> enable you write compound expressions - they are typically used to initialize an instance.  This feature is a clean a superset of how <a href='Serialization.html#syntaxComplex'>complex</a> types are serialized.  An example it-block expression:</p>

<pre>Address
{
  street = "123 Happy Lane"
  city   = "Houston"
  state  = "TX"
}

// is syntax sugar for (note: can't actually use it as param name)
Address.make.with |Address it|
{
  it.street = "123 Happy Lane"
  it.city   = "Houston"
  it.state  = "TX"
}</pre>

<h2 id='collections'>Collections </h2>

<p>It-blocks may also be used to initialize a collection if <code>it</code> supports a method called "add".  Any expression inside an it-block suffixed with a comma is assumed to be a call to <code>it.add</code>:</p>

<pre>a,       =>  it.add(a)
a, b,    =>  it.add(a).add(b)
a, b, c  =>  it.add(a).add(b).add(c)</pre>

<p>Note the comma operator chains the calls to <code>add</code>, therefore the <code>add</code> method must return a chainable type (typically <code>This</code>).</p>

<p>Here is an FWT example:</p>

<pre>Menu
{
  text = "File"
  MenuItem { text = "Open"; onSelect=#open.func } },
  MenuItem { text = "Save"; onSelect=#save.func },
}

// is syntax sugar for (note: can't actually use it as param name)
Menu.make.with |Menu it|
{
  it.text = "File"
  it.add(MenuItem { text = "Open"; onSelect=#open.func })
   .add(MenuItem { text = "Save"; onSelect=#save.func })
}</pre>

<h1 id='advances'>Advanced Operators </h1>

<p>Fantom has a couple other operators which will be discussed later:</p>

<ul>
<li><a href='Closures.html'>Closures</a> are expressions which create a new function inside a method body.</li>

<li><a href='Functions.html#calling'>Call</a> operator <code>()</code> is used to invoke a function variable.</li>

<li><a href='Methods.html#dynamicInvoke'>Dynamic invoke</a> operator <code>-></code> is used to call a method without compile time type checking.</li>

<li><a href='Fields.html#accessors'>Field storage</a> operator <code>&amp;</code> is used to access a field's raw storage without going through its getter/setter methods.</li>
</ul>
<div class='prevNext'>
<div class='prev'><a href='Literals.html'><img src='../go-previous.png' alt='prev' /></a> <a href='Literals.html'>Literals</a></div>
<div class='next'><a href='Statements.html'>Statements</a> <a href='Statements.html'><img src='../go-next.png' alt='next' /></a></div>
</div>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#precedence'>Operator Precedence </a></li><li><a href='#shortcuts'>Shortcut Operators </a><ul>
<li><a href='#prefixPostfix'>Prefix and Postfix Operators </a></li><li><a href='#equality'>Equality Operators </a></li><li><a href='#relational'>Relational Operators </a></li><li><a href='#comparisonsWithNull'>Comparisons with Null </a></li></ul>
</li><li><a href='#same'>Same Operators </a></li><li><a href='#cond'>Conditional Operators </a></li><li><a href='#ternary'>Ternary Operator </a></li><li><a href='#nullConvenience'>Null Convenience Operators </a><ul>
<li><a href='#elvis'>Elvis Operator </a></li><li><a href='#safeInvoke'>Safe Invoke </a></li></ul>
</li><li><a href='#typeChecking'>Type Checking </a></li><li><a href='#indexing'>Indexing </a></li><li><a href='#bitwise'>Bitwise Operators </a></li><li><a href='#serialization'>Serialization Expressions </a><ul>
<li><a href='#simples'>Simples </a></li><li><a href='#itBlocks'>It-Blocks </a></li><li><a href='#collections'>Collections </a></li></ul>
</li><li><a href='#advances'>Advanced Operators </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
docLang 1.0.56
[11-Nov-2010 Thu 10:08:28AM EST]
</p>
</div>
</div>
</body>
</html>

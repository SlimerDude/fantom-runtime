<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>fwt::CommandStack</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>fwt</a></li>
  <li>&gt;</li>
  <li><a href='CommandStack.html'>CommandStack</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>final class</h2>
<h1>fwt::CommandStack</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  fwt::CommandStack</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2008, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   22 Jul 08  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='k'>using</span> gfx

<span class='z'>**</span>
<span class='z'>** Command packages up the diplay name, icon, execution,</span>
<span class='z'>** and undo support for a user command.  You can create a</span>
<span class='z'>** command two ways:</span>
<span class='z'>**   1. use a closure (or any function) for `onInvoke`</span>
<span class='z'>**   2. subclass Command and override `invoked`</span>
<span class='z'>**</span>
<span class='z'>** If the command supports undo, then you must create a</span>
<span class='z'>** a subclass and override `undo`.</span>
<span class='z'>**</span>
<span class='z'>** Commands are often used to centralize control of multiple</span>
<span class='z'>** widgets.  For example if a Command is associated with</span>
<span class='z'>** both a menu item and a toolbar button, then disabling the</span>
<span class='z'>** command will disable both the menu item and toolbar button.</span>
<span class='z'>**</span>
<span class='z'>** See [pod doc]`pod-doc#commands` for details.</span>
<span class='z'>**</span>
@Js
<span class='k'>class</span> Command
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Name of the command.</span>
  <span class='z'>**</span>
  Str name

  <span class='z'>**</span>
  <span class='z'>** Icon of the command or null.  Typically a 16x16.</span>
  <span class='z'>**</span>
  Image? icon

  <span class='z'>**</span>
  <span class='z'>** Accelerator of the command or null.</span>
  <span class='z'>**</span>
  Key? accelerator

  <span class='z'>**</span>
  <span class='z'>** The function to invoke when the command is executed.  If</span>
  <span class='z'>** empty, then `invoke` must be overridden.</span>
  <span class='z'>**</span>
  @Transient <span class='k'>readonly</span> EventListeners onInvoke := EventListeners<span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** The command mode determines who associated widgets are</span>
  <span class='z'>** visualized.  The CommandMode maps to the `ButtonMode`</span>
  <span class='z'>** and `MenuItemMode`.  The default is 'push'.</span>
  <span class='z'>**</span>
  CommandMode mode := CommandMode.push

  <span class='z'>**</span>
  <span class='z'>** If this command is using toggle mode, then set the</span>
  <span class='z'>** selected state and update all the registered widgets.</span>
  <span class='z'>**</span>
  Bool selected := <span class='k'>false</span>
  <span class='b'>{</span>
    set
    <span class='b'>{</span>
      newVal := it
      <span class='k'>if</span> <span class='b'>(</span>mode != CommandMode.toggle<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>this</span>.&amp;selected = newVal
      widgets.each |Widget w|
      <span class='b'>{</span>
        <span class='k'>try</span> <span class='b'>{</span> w-&gt;selected = newVal <span class='b'>}</span> <span class='k'>catch</span> <span class='b'>{}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Construct a command with the specified onInvoke function.</span>
  <span class='z'>** If onInvoke is not specified, then the `invoke` method</span>
  <span class='z'>** must be overridden to execute the command.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> make<span class='b'>(</span>Str name := <span class='s'>""</span>, Image? icon := <span class='k'>null</span>, |Event event|? onInvoke := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.name = name
    <span class='k'>this</span>.icon = icon
    <span class='k'>if</span> <span class='b'>(</span>onInvoke != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.onInvoke.add<span class='b'>(</span>onInvoke<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Construct a localized command using the specified pod name</span>
  <span class='z'>** and keyBase.  The command is initialized from the following</span>
  <span class='z'>** [localized]`sys::Env.locale` properties:</span>
  <span class='z'>**   - "{keyBase}.name.{plat}": text string for the command</span>
  <span class='z'>**   - "{keyBase}.icon.{plat}": uri for the icon image</span>
  <span class='z'>**   - "{keyBase}.accelerator.{plat}": string representation of Key</span>
  <span class='z'>**</span>
  <span class='z'>** The '{plat}' string comes from `Desktop.platform`.  If the</span>
  <span class='z'>** paltform specific key is not found, then we attempt to fallback</span>
  <span class='z'>** to a generic key.  For example:</span>
  <span class='z'>**</span>
  <span class='z'>**    back.name=Back</span>
  <span class='z'>**    back.accelerator=Alt+Left</span>
  <span class='z'>**    back.accelerator.mac=Command+[</span>
  <span class='z'>**</span>
  <span class='z'>** On all platforms the command name would be "Back".  On Macs</span>
  <span class='z'>** the accelerator would be 'Command+[', and all others it would</span>
  <span class='z'>** be 'Alt+Left'.  If running on a Mac and an explicit ".mac"</span>
  <span class='z'>** property was not specified, then we automatically swizzle Ctrl</span>
  <span class='z'>** to Command.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> makeLocale<span class='b'>(</span>Pod pod, Str keyBase, |Event event|? onInvoke := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    plat := Desktop.platform

    <span class='y'>// name</span>
    name := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.name.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>name == <span class='k'>null</span><span class='b'>)</span>
      name = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.name"</span><span class='b'>)</span>
    <span class='k'>this</span>.name = name

    <span class='y'>// icon</span>
    locIcon := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.icon.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>locIcon == <span class='k'>null</span><span class='b'>)</span>
      locIcon = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.icon"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>locIcon != <span class='k'>null</span><span class='b'>)</span>
        <span class='k'>this</span>.icon = Image.make<span class='b'>(</span>locIcon.toUri<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> Command#.pod.log.err<span class='b'>(</span><span class='s'>"Command: cannot load '${keyBase}.icon' =&gt; $locIcon"</span><span class='b'>)</span>

    <span class='y'>// accelerator</span>
    locAcc := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.accelerator.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    locAccPlat := locAcc != <span class='k'>null</span>
    <span class='k'>if</span> <span class='b'>(</span>locAcc == <span class='k'>null</span><span class='b'>)</span>
      locAcc = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.accelerator"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>locAcc != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>this</span>.accelerator = Key.fromStr<span class='b'>(</span>locAcc<span class='b'>)</span>

        <span class='y'>// if on a Mac and an explicit .mac prop was not defined,</span>
        <span class='y'>// then automatically swizzle Ctrl to Command</span>
        <span class='k'>if</span> <span class='b'>(</span>!locAccPlat &amp;&amp; Desktop.isMac<span class='b'>)</span>
          <span class='k'>this</span>.accelerator = <span class='k'>this</span>.accelerator.replace<span class='b'>(</span>Key.ctrl, Key.command<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> Command#.pod.log.err<span class='b'>(</span><span class='s'>"Command: cannot load '${keyBase}.accelerator ' =&gt; $locAcc"</span><span class='b'>)</span>

    <span class='y'>// onInvoke</span>
    <span class='k'>if</span> <span class='b'>(</span>onInvoke != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.onInvoke.add<span class='b'>(</span>onInvoke<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Methods</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the window associated with this command.  If this</span>
  <span class='z'>** command is being used as the action of a dialog, then</span>
  <span class='z'>** return the dialog.  Otherwise try to map to a window</span>
  <span class='z'>** via one of the widgets bound to this command.  Return</span>
  <span class='z'>** null if no associated window can be found.</span>
  <span class='z'>**</span>
  Window? window<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>assocDialog != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> assocDialog
    <span class='k'>return</span> widgets.eachWhile |Widget w-&gt;Window| <span class='b'>{</span> w.window <span class='b'>}</span>
  <span class='b'>}</span>
  <span class='k'>internal</span> Dialog? assocDialog

  <span class='z'>**</span>
  <span class='z'>** The enable state of the command automatically controls</span>
  <span class='z'>** the enabled state of all the registered widgets.</span>
  <span class='z'>**</span>
  Bool enabled := <span class='k'>true</span>
  <span class='b'>{</span>
    set
    <span class='b'>{</span>
      newVal := it
      <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span>.&amp;enabled == newVal<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>this</span>.&amp;enabled = newVal
      registry.each |Widget w| <span class='b'>{</span> w.enabled = newVal <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get the associated widgets with this command.  Widgets are</span>
  <span class='z'>** automatically associated with their command field is set.</span>
  <span class='z'>**</span>
  Widget<span class='b'>[]</span> widgets<span class='b'>()</span> <span class='b'>{</span> registry.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Register a widget with this command.  This is done</span>
  <span class='z'>** automatically by the widget.  You only need to call</span>
  <span class='z'>** this method if you are developing a custom widget.</span>
  <span class='z'>**</span>
  Void register<span class='b'>(</span>Widget w<span class='b'>)</span> <span class='b'>{</span> registry.add<span class='b'>(</span>w<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Unregister a widget with this command.  This is done</span>
  <span class='z'>** automatically by the widget.  You only need to call</span>
  <span class='z'>** this method if you are developing a custom widget.</span>
  <span class='z'>**</span>
  Void unregister<span class='b'>(</span>Widget w<span class='b'>)</span> <span class='b'>{</span> registry.removeSame<span class='b'>(</span>w<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return name.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str toStr<span class='b'>()</span> <span class='b'>{</span> name <span class='b'>}</span>

  <span class='k'>private</span> Widget<span class='b'>[]</span> registry := Widget<span class='b'>[</span>,<span class='b'>]</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Invoke</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Invoke the command.  If the user event is known</span>
  <span class='z'>** then is passed, otherwise it might be null.</span>
  <span class='z'>**</span>
  Void invoke<span class='b'>(</span>Event? event<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
      invoked<span class='b'>(</span>event<span class='b'>)</span>
    <span class='k'>catch</span> <span class='b'>(</span>Err e<span class='b'>)</span>
      onInvokeErr<span class='b'>(</span>event, e<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Subclass hook to handle invoke event.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>virtual</span> Void invoked<span class='b'>(</span>Event? event<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>onInvoke.isEmpty<span class='b'>)</span> <span class='k'>throw</span> UnsupportedErr<span class='b'>(</span><span class='s'>"Must set onInvoke or override invoke: $name"</span><span class='b'>)</span>
    onInvoke.fire<span class='b'>(</span>event<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Subclass hook to handle when an exception is raised</span>
  <span class='z'>** by invoke.  Default implementation raises an error dialog.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>virtual</span> Void onInvokeErr<span class='b'>(</span>Event? event, Err err<span class='b'>)</span>
  <span class='b'>{</span>
    window := event?.window ?: registry.first?.window
    Dialog.openErr<span class='b'>(</span>window, <span class='s'>"$name: $err"</span>, err<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Undo</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if the command can be undone.  Default implementation</span>
  <span class='z'>** returns true if the `undo` method has been overridden.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool undoable<span class='b'>()</span>
  <span class='b'>{</span>
    Type.of<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>.method<span class='b'>(</span><span class='s'>"undo"</span><span class='b'>)</span>.parent != Command#
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** This method is invoked when the command invoked as</span>
  <span class='z'>** a redo.  It is not called on the first invocation.</span>
  <span class='z'>** Default calls `invoke` with a null event.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Void redo<span class='b'>()</span>
  <span class='b'>{</span>
    invoke<span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** This method is invoked to undo the command.  This</span>
  <span class='z'>** method is only used if `undoable` returns true.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Void undo<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>throw</span> UnsupportedErr<span class='b'>(</span><span class='s'>"Command not undoable $name"</span><span class='b'>)</span>
  <span class='b'>}</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** CommandStack</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** Manages a stack of commands for undo/redo.</span>
<span class='z'>**</span>
<span class='k'>final</span> <span class='k'>class</span> CommandStack
<span class='b'>{</span>
  <span class='z'>**</span>
  <span class='z'>** Max number of undo commands stored in the stack.</span>
  <span class='z'>**</span>
  Int <span id='limit'>limit</span> := 1000

  <span class='z'>**</span>
  <span class='z'>** Return is both the undo and redo lists are empty.</span>
  <span class='z'>**</span>
  Bool <span id='isEmpty'>isEmpty</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.isEmpty &amp;&amp; redoStack.isEmpty <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Are any commands available for undo.</span>
  <span class='z'>**</span>
  Bool <span id='hasUndo'>hasUndo</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.size &gt; 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Are any commands available for redo.</span>
  <span class='z'>**</span>
  Bool <span id='hasRedo'>hasRedo</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> redoStack.size &gt; 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List all the undo commands in the stack.</span>
  <span class='z'>**</span>
  Command<span class='b'>[]</span> <span id='listUndo'>listUndo</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List all the redo commands in the stack.</span>
  <span class='z'>**</span>
  Command<span class='b'>[]</span> <span id='listRedo'>listRedo</span><span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> redoStack.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Clear the undo/redo stacks.  Return this.</span>
  <span class='z'>**</span>
  CommandStack <span id='clear'>clear</span><span class='b'>()</span> <span class='b'>{</span> undoStack.clear; redoStack.clear; fireModified; <span class='k'>return</span> <span class='k'>this</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Callback when command stack is modified.</span>
  <span class='z'>**</span>
  @Transient <span class='k'>readonly</span> EventListeners <span id='onModify'>onModify</span> := EventListeners<span class='b'>()</span>

  <span class='k'>private</span> Void <span id='fireModified'>fireModified</span><span class='b'>()</span> <span class='b'>{</span> onModify.fire<span class='b'>(</span>Event <span class='b'>{</span> id = EventId.modified <span class='b'>})</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Push a command onto the undo stack.  This clears</span>
  <span class='z'>** the redo stack.  If c is null or returns false</span>
  <span class='z'>** for `Command.undoable` then ignore this call.</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  CommandStack <span id='push'>push</span><span class='b'>(</span>Command? c<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span> || !c.undoable<span class='b'>)</span> <span class='k'>return</span> <span class='k'>this</span>
    undoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>undoStack.size &gt; limit<span class='b'>)</span> undoStack.removeAt<span class='b'>(</span>0<span class='b'>)</span>
    redoStack.clear
    fireModified
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Call `Command.undo` on the last undo command and</span>
  <span class='z'>** then push it onto the redo stack.  If the undo stack</span>
  <span class='z'>** is empty, then ignore this call.  Return command undone.</span>
  <span class='z'>**</span>
  Command? <span id='undo'>undo</span><span class='b'>()</span>
  <span class='b'>{</span>
    c := undoStack.pop
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    c.undo
    redoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    fireModified
    <span class='k'>return</span> c
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Call `Command.redo` on the last redo command and</span>
  <span class='z'>** then push it onto the undo stack.  If the redo stack</span>
  <span class='z'>** is empty, then ignore this call.  Return command redone.</span>
  <span class='z'>**</span>
  Command? <span id='redo'>redo</span><span class='b'>()</span>
  <span class='b'>{</span>
    c := redoStack.pop
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    c.redo
    undoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    fireModified
    <span class='k'>return</span> c
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return debug string representation.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"CommandStack undo=${listUndo.size} redo=${listRedo.size}"</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Create a shallow copy of the undo and redo stacks.  The</span>
  <span class='z'>** copy maintains references to the original command instances.</span>
  <span class='z'>**</span>
  This <span id='dup'>dup</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> CommandStack
    <span class='b'>{</span>
      it.undoStack = <span class='k'>this</span>.undoStack.dup
      it.redoStack = <span class='k'>this</span>.redoStack.dup
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Command<span class='b'>[]</span> <span id='undoStack'>undoStack</span> := Command<span class='b'>[</span>,<span class='b'>]</span>
  <span class='k'>private</span> Command<span class='b'>[]</span> <span id='redoStack'>redoStack</span> := Command<span class='b'>[</span>,<span class='b'>]</span>
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='CommandStack.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#clear'>clear</a></li>
  <li style='display: block;'><a href='#dup'>dup</a></li>
  <li class='hidden' style='display: block;'><a href='#fireModified'>fireModified</a></li>
  <li style='display: block;'><a href='#hasRedo'>hasRedo</a></li>
  <li style='display: block;'><a href='#hasUndo'>hasUndo</a></li>
  <li style='display: block;'><a href='#isEmpty'>isEmpty</a></li>
  <li style='display: block;'><a href='#limit'>limit</a></li>
  <li style='display: block;'><a href='#listRedo'>listRedo</a></li>
  <li style='display: block;'><a href='#listUndo'>listUndo</a></li>
  <li style='display: block;'><a href='#onModify'>onModify</a></li>
  <li style='display: block;'><a href='#push'>push</a></li>
  <li style='display: block;'><a href='#redo'>redo</a></li>
  <li class='hidden' style='display: block;'><a href='#redoStack'>redoStack</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
  <li style='display: block;'><a href='#undo'>undo</a></li>
  <li class='hidden' style='display: block;'><a href='#undoStack'>undoStack</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
fwt 1.0.56
[11-Nov-2010 Thu 10:08:25AM EST]
</p>
</div>
</div>
</body>
</html>

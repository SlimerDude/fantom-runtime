<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>fwt::Command</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>fwt</a></li>
  <li>&gt;</li>
  <li><a href='Command.html'>Command</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>fwt::Command</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  fwt::Command</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2008, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   22 Jul 08  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='k'>using</span> gfx

<span class='z'>**</span>
<span class='z'>** Command packages up the diplay name, icon, execution,</span>
<span class='z'>** and undo support for a user command.  You can create a</span>
<span class='z'>** command two ways:</span>
<span class='z'>**   1. use a closure (or any function) for `onInvoke`</span>
<span class='z'>**   2. subclass Command and override `invoked`</span>
<span class='z'>**</span>
<span class='z'>** If the command supports undo, then you must create a</span>
<span class='z'>** a subclass and override `undo`.</span>
<span class='z'>**</span>
<span class='z'>** Commands are often used to centralize control of multiple</span>
<span class='z'>** widgets.  For example if a Command is associated with</span>
<span class='z'>** both a menu item and a toolbar button, then disabling the</span>
<span class='z'>** command will disable both the menu item and toolbar button.</span>
<span class='z'>**</span>
<span class='z'>** See [pod doc]`pod-doc#commands` for details.</span>
<span class='z'>**</span>
@Js
<span class='k'>class</span> Command
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Fields</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Name of the command.</span>
  <span class='z'>**</span>
  Str <span id='name'>name</span>

  <span class='z'>**</span>
  <span class='z'>** Icon of the command or null.  Typically a 16x16.</span>
  <span class='z'>**</span>
  Image? <span id='icon'>icon</span>

  <span class='z'>**</span>
  <span class='z'>** Accelerator of the command or null.</span>
  <span class='z'>**</span>
  Key? <span id='accelerator'>accelerator</span>

  <span class='z'>**</span>
  <span class='z'>** The function to invoke when the command is executed.  If</span>
  <span class='z'>** empty, then `invoke` must be overridden.</span>
  <span class='z'>**</span>
  @Transient <span class='k'>readonly</span> EventListeners <span id='onInvoke'>onInvoke</span> := EventListeners<span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** The command mode determines who associated widgets are</span>
  <span class='z'>** visualized.  The CommandMode maps to the `ButtonMode`</span>
  <span class='z'>** and `MenuItemMode`.  The default is 'push'.</span>
  <span class='z'>**</span>
  CommandMode <span id='mode'>mode</span> := CommandMode.push

  <span class='z'>**</span>
  <span class='z'>** If this command is using toggle mode, then set the</span>
  <span class='z'>** selected state and update all the registered widgets.</span>
  <span class='z'>**</span>
  Bool <span id='selected'>selected</span> := <span class='k'>false</span>
  <span class='b'>{</span>
    set
    <span class='b'>{</span>
      newVal := it
      <span class='k'>if</span> <span class='b'>(</span>mode != CommandMode.toggle<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>this</span>.&amp;selected = newVal
      widgets.each |Widget w|
      <span class='b'>{</span>
        <span class='k'>try</span> <span class='b'>{</span> w-&gt;selected = newVal <span class='b'>}</span> <span class='k'>catch</span> <span class='b'>{}</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Construct a command with the specified onInvoke function.</span>
  <span class='z'>** If onInvoke is not specified, then the `invoke` method</span>
  <span class='z'>** must be overridden to execute the command.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>Str name := <span class='s'>""</span>, Image? icon := <span class='k'>null</span>, |Event event|? onInvoke := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>this</span>.name = name
    <span class='k'>this</span>.icon = icon
    <span class='k'>if</span> <span class='b'>(</span>onInvoke != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.onInvoke.add<span class='b'>(</span>onInvoke<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Construct a localized command using the specified pod name</span>
  <span class='z'>** and keyBase.  The command is initialized from the following</span>
  <span class='z'>** [localized]`sys::Env.locale` properties:</span>
  <span class='z'>**   - "{keyBase}.name.{plat}": text string for the command</span>
  <span class='z'>**   - "{keyBase}.icon.{plat}": uri for the icon image</span>
  <span class='z'>**   - "{keyBase}.accelerator.{plat}": string representation of Key</span>
  <span class='z'>**</span>
  <span class='z'>** The '{plat}' string comes from `Desktop.platform`.  If the</span>
  <span class='z'>** paltform specific key is not found, then we attempt to fallback</span>
  <span class='z'>** to a generic key.  For example:</span>
  <span class='z'>**</span>
  <span class='z'>**    back.name=Back</span>
  <span class='z'>**    back.accelerator=Alt+Left</span>
  <span class='z'>**    back.accelerator.mac=Command+[</span>
  <span class='z'>**</span>
  <span class='z'>** On all platforms the command name would be "Back".  On Macs</span>
  <span class='z'>** the accelerator would be 'Command+[', and all others it would</span>
  <span class='z'>** be 'Alt+Left'.  If running on a Mac and an explicit ".mac"</span>
  <span class='z'>** property was not specified, then we automatically swizzle Ctrl</span>
  <span class='z'>** to Command.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='makeLocale'>makeLocale</span><span class='b'>(</span>Pod pod, Str keyBase, |Event event|? onInvoke := <span class='k'>null</span><span class='b'>)</span>
  <span class='b'>{</span>
    plat := Desktop.platform

    <span class='y'>// name</span>
    name := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.name.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>name == <span class='k'>null</span><span class='b'>)</span>
      name = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.name"</span><span class='b'>)</span>
    <span class='k'>this</span>.name = name

    <span class='y'>// icon</span>
    locIcon := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.icon.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>locIcon == <span class='k'>null</span><span class='b'>)</span>
      locIcon = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.icon"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>locIcon != <span class='k'>null</span><span class='b'>)</span>
        <span class='k'>this</span>.icon = Image.make<span class='b'>(</span>locIcon.toUri<span class='b'>)</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> Command#.pod.log.err<span class='b'>(</span><span class='s'>"Command: cannot load '${keyBase}.icon' =&gt; $locIcon"</span><span class='b'>)</span>

    <span class='y'>// accelerator</span>
    locAcc := pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.accelerator.${plat}"</span>, <span class='k'>null</span><span class='b'>)</span>
    locAccPlat := locAcc != <span class='k'>null</span>
    <span class='k'>if</span> <span class='b'>(</span>locAcc == <span class='k'>null</span><span class='b'>)</span>
      locAcc = pod.locale<span class='b'>(</span><span class='s'>"${keyBase}.accelerator"</span>, <span class='k'>null</span><span class='b'>)</span>
    <span class='k'>try</span>
    <span class='b'>{</span>
      <span class='k'>if</span> <span class='b'>(</span>locAcc != <span class='k'>null</span><span class='b'>)</span>
      <span class='b'>{</span>
        <span class='k'>this</span>.accelerator = Key.fromStr<span class='b'>(</span>locAcc<span class='b'>)</span>

        <span class='y'>// if on a Mac and an explicit .mac prop was not defined,</span>
        <span class='y'>// then automatically swizzle Ctrl to Command</span>
        <span class='k'>if</span> <span class='b'>(</span>!locAccPlat &amp;&amp; Desktop.isMac<span class='b'>)</span>
          <span class='k'>this</span>.accelerator = <span class='k'>this</span>.accelerator.replace<span class='b'>(</span>Key.ctrl, Key.command<span class='b'>)</span>
      <span class='b'>}</span>
    <span class='b'>}</span>
    <span class='k'>catch</span> Command#.pod.log.err<span class='b'>(</span><span class='s'>"Command: cannot load '${keyBase}.accelerator ' =&gt; $locAcc"</span><span class='b'>)</span>

    <span class='y'>// onInvoke</span>
    <span class='k'>if</span> <span class='b'>(</span>onInvoke != <span class='k'>null</span><span class='b'>)</span> <span class='k'>this</span>.onInvoke.add<span class='b'>(</span>onInvoke<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Methods</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the window associated with this command.  If this</span>
  <span class='z'>** command is being used as the action of a dialog, then</span>
  <span class='z'>** return the dialog.  Otherwise try to map to a window</span>
  <span class='z'>** via one of the widgets bound to this command.  Return</span>
  <span class='z'>** null if no associated window can be found.</span>
  <span class='z'>**</span>
  Window? <span id='window'>window</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>assocDialog != <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> assocDialog
    <span class='k'>return</span> widgets.eachWhile |Widget w-&gt;Window| <span class='b'>{</span> w.window <span class='b'>}</span>
  <span class='b'>}</span>
  <span class='k'>internal</span> Dialog? <span id='assocDialog'>assocDialog</span>

  <span class='z'>**</span>
  <span class='z'>** The enable state of the command automatically controls</span>
  <span class='z'>** the enabled state of all the registered widgets.</span>
  <span class='z'>**</span>
  Bool <span id='enabled'>enabled</span> := <span class='k'>true</span>
  <span class='b'>{</span>
    set
    <span class='b'>{</span>
      newVal := it
      <span class='k'>if</span> <span class='b'>(</span><span class='k'>this</span>.&amp;enabled == newVal<span class='b'>)</span> <span class='k'>return</span>
      <span class='k'>this</span>.&amp;enabled = newVal
      registry.each |Widget w| <span class='b'>{</span> w.enabled = newVal <span class='b'>}</span>
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Get the associated widgets with this command.  Widgets are</span>
  <span class='z'>** automatically associated with their command field is set.</span>
  <span class='z'>**</span>
  Widget<span class='b'>[]</span> <span id='widgets'>widgets</span><span class='b'>()</span> <span class='b'>{</span> registry.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Register a widget with this command.  This is done</span>
  <span class='z'>** automatically by the widget.  You only need to call</span>
  <span class='z'>** this method if you are developing a custom widget.</span>
  <span class='z'>**</span>
  Void <span id='register'>register</span><span class='b'>(</span>Widget w<span class='b'>)</span> <span class='b'>{</span> registry.add<span class='b'>(</span>w<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Unregister a widget with this command.  This is done</span>
  <span class='z'>** automatically by the widget.  You only need to call</span>
  <span class='z'>** this method if you are developing a custom widget.</span>
  <span class='z'>**</span>
  Void <span id='unregister'>unregister</span><span class='b'>(</span>Widget w<span class='b'>)</span> <span class='b'>{</span> registry.removeSame<span class='b'>(</span>w<span class='b'>)</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return name.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span> <span class='b'>{</span> name <span class='b'>}</span>

  <span class='k'>private</span> Widget<span class='b'>[]</span> <span id='registry'>registry</span> := Widget<span class='b'>[</span>,<span class='b'>]</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Invoke</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Invoke the command.  If the user event is known</span>
  <span class='z'>** then is passed, otherwise it might be null.</span>
  <span class='z'>**</span>
  Void <span id='invoke'>invoke</span><span class='b'>(</span>Event? event<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>try</span>
      invoked<span class='b'>(</span>event<span class='b'>)</span>
    <span class='k'>catch</span> <span class='b'>(</span>Err e<span class='b'>)</span>
      onInvokeErr<span class='b'>(</span>event, e<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Subclass hook to handle invoke event.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>virtual</span> Void <span id='invoked'>invoked</span><span class='b'>(</span>Event? event<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>onInvoke.isEmpty<span class='b'>)</span> <span class='k'>throw</span> UnsupportedErr<span class='b'>(</span><span class='s'>"Must set onInvoke or override invoke: $name"</span><span class='b'>)</span>
    onInvoke.fire<span class='b'>(</span>event<span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Subclass hook to handle when an exception is raised</span>
  <span class='z'>** by invoke.  Default implementation raises an error dialog.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>virtual</span> Void <span id='onInvokeErr'>onInvokeErr</span><span class='b'>(</span>Event? event, Err err<span class='b'>)</span>
  <span class='b'>{</span>
    window := event?.window ?: registry.first?.window
    Dialog.openErr<span class='b'>(</span>window, <span class='s'>"$name: $err"</span>, err<span class='b'>)</span>
  <span class='b'>}</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Undo</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if the command can be undone.  Default implementation</span>
  <span class='z'>** returns true if the `undo` method has been overridden.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Bool <span id='undoable'>undoable</span><span class='b'>()</span>
  <span class='b'>{</span>
    Type.of<span class='b'>(</span><span class='k'>this</span><span class='b'>)</span>.method<span class='b'>(</span><span class='s'>"undo"</span><span class='b'>)</span>.parent != Command#
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** This method is invoked when the command invoked as</span>
  <span class='z'>** a redo.  It is not called on the first invocation.</span>
  <span class='z'>** Default calls `invoke` with a null event.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Void <span id='redo'>redo</span><span class='b'>()</span>
  <span class='b'>{</span>
    invoke<span class='b'>(</span><span class='k'>null</span><span class='b'>)</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** This method is invoked to undo the command.  This</span>
  <span class='z'>** method is only used if `undoable` returns true.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Void <span id='undo'>undo</span><span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>throw</span> UnsupportedErr<span class='b'>(</span><span class='s'>"Command not undoable $name"</span><span class='b'>)</span>
  <span class='b'>}</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** CommandStack</span>
<span class='z'>**************************************************************************</span>

<span class='z'>**</span>
<span class='z'>** Manages a stack of commands for undo/redo.</span>
<span class='z'>**</span>
<span class='k'>final</span> <span class='k'>class</span> CommandStack
<span class='b'>{</span>
  <span class='z'>**</span>
  <span class='z'>** Max number of undo commands stored in the stack.</span>
  <span class='z'>**</span>
  Int limit := 1000

  <span class='z'>**</span>
  <span class='z'>** Return is both the undo and redo lists are empty.</span>
  <span class='z'>**</span>
  Bool isEmpty<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.isEmpty &amp;&amp; redoStack.isEmpty <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Are any commands available for undo.</span>
  <span class='z'>**</span>
  Bool hasUndo<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.size &gt; 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Are any commands available for redo.</span>
  <span class='z'>**</span>
  Bool hasRedo<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> redoStack.size &gt; 0 <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List all the undo commands in the stack.</span>
  <span class='z'>**</span>
  Command<span class='b'>[]</span> listUndo<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> undoStack.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** List all the redo commands in the stack.</span>
  <span class='z'>**</span>
  Command<span class='b'>[]</span> listRedo<span class='b'>()</span> <span class='b'>{</span> <span class='k'>return</span> redoStack.ro <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Clear the undo/redo stacks.  Return this.</span>
  <span class='z'>**</span>
  CommandStack clear<span class='b'>()</span> <span class='b'>{</span> undoStack.clear; redoStack.clear; fireModified; <span class='k'>return</span> <span class='k'>this</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Callback when command stack is modified.</span>
  <span class='z'>**</span>
  @Transient <span class='k'>readonly</span> EventListeners onModify := EventListeners<span class='b'>()</span>

  <span class='k'>private</span> Void fireModified<span class='b'>()</span> <span class='b'>{</span> onModify.fire<span class='b'>(</span>Event <span class='b'>{</span> id = EventId.modified <span class='b'>})</span> <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Push a command onto the undo stack.  This clears</span>
  <span class='z'>** the redo stack.  If c is null or returns false</span>
  <span class='z'>** for `Command.undoable` then ignore this call.</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  CommandStack push<span class='b'>(</span>Command? c<span class='b'>)</span>
  <span class='b'>{</span>
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span> || !c.undoable<span class='b'>)</span> <span class='k'>return</span> <span class='k'>this</span>
    undoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    <span class='k'>if</span> <span class='b'>(</span>undoStack.size &gt; limit<span class='b'>)</span> undoStack.removeAt<span class='b'>(</span>0<span class='b'>)</span>
    redoStack.clear
    fireModified
    <span class='k'>return</span> <span class='k'>this</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Call `Command.undo` on the last undo command and</span>
  <span class='z'>** then push it onto the redo stack.  If the undo stack</span>
  <span class='z'>** is empty, then ignore this call.  Return command undone.</span>
  <span class='z'>**</span>
  Command? undo<span class='b'>()</span>
  <span class='b'>{</span>
    c := undoStack.pop
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    c.undo
    redoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    fireModified
    <span class='k'>return</span> c
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Call `Command.redo` on the last redo command and</span>
  <span class='z'>** then push it onto the undo stack.  If the redo stack</span>
  <span class='z'>** is empty, then ignore this call.  Return command redone.</span>
  <span class='z'>**</span>
  Command? redo<span class='b'>()</span>
  <span class='b'>{</span>
    c := redoStack.pop
    <span class='k'>if</span> <span class='b'>(</span>c == <span class='k'>null</span><span class='b'>)</span> <span class='k'>return</span> <span class='k'>null</span>
    c.redo
    undoStack.push<span class='b'>(</span>c<span class='b'>)</span>
    fireModified
    <span class='k'>return</span> c
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Return debug string representation.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str toStr<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> <span class='s'>"CommandStack undo=${listUndo.size} redo=${listRedo.size}"</span>
  <span class='b'>}</span>

  <span class='z'>**</span>
  <span class='z'>** Create a shallow copy of the undo and redo stacks.  The</span>
  <span class='z'>** copy maintains references to the original command instances.</span>
  <span class='z'>**</span>
  This dup<span class='b'>()</span>
  <span class='b'>{</span>
    <span class='k'>return</span> CommandStack
    <span class='b'>{</span>
      it.undoStack = <span class='k'>this</span>.undoStack.dup
      it.redoStack = <span class='k'>this</span>.redoStack.dup
    <span class='b'>}</span>
  <span class='b'>}</span>

  <span class='k'>private</span> Command<span class='b'>[]</span> undoStack := Command<span class='b'>[</span>,<span class='b'>]</span>
  <span class='k'>private</span> Command<span class='b'>[]</span> redoStack := Command<span class='b'>[</span>,<span class='b'>]</span>
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Command.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#accelerator'>accelerator</a></li>
  <li class='hidden' style='display: block;'><a href='#assocDialog'>assocDialog</a></li>
  <li style='display: block;'><a href='#enabled'>enabled</a></li>
  <li style='display: block;'><a href='#icon'>icon</a></li>
  <li style='display: block;'><a href='#invoke'>invoke</a></li>
  <li style='display: block;'><a href='#invoked'>invoked</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#makeLocale'>makeLocale</a></li>
  <li style='display: block;'><a href='#mode'>mode</a></li>
  <li style='display: block;'><a href='#name'>name</a></li>
  <li style='display: block;'><a href='#onInvoke'>onInvoke</a></li>
  <li style='display: block;'><a href='#onInvokeErr'>onInvokeErr</a></li>
  <li style='display: block;'><a href='#redo'>redo</a></li>
  <li style='display: block;'><a href='#register'>register</a></li>
  <li class='hidden' style='display: block;'><a href='#registry'>registry</a></li>
  <li style='display: block;'><a href='#selected'>selected</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
  <li style='display: block;'><a href='#undo'>undo</a></li>
  <li style='display: block;'><a href='#undoable'>undoable</a></li>
  <li style='display: block;'><a href='#unregister'>unregister</a></li>
  <li style='display: block;'><a href='#widgets'>widgets</a></li>
  <li style='display: block;'><a href='#window'>window</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
fwt 1.0.56
[11-Nov-2010 Thu 10:08:25AM EST]
</p>
</div>
</div>
</body>
</html>

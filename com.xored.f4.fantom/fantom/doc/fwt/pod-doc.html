<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>fwt PodDoc</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>fwt</a></li>
  <li>&gt;</li>
  <li><a href='pod-doc.html'>fwt PodDoc</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
 <div class='overview'>
  <h2>pod</h2>
  <h1>fwt</h1>
 </div>
</div>

<h1 id='overview'>Overview </h1>

<p>Fantom Widget Toolkit or <a href='index.html'>FWT</a> provides a toolkit for building both desktop and HTML5 browser based applications:</p>

<ul>
<li>Widgets are reusable UI components such as buttons, text fields, dialogs, etc</li>

<li>Graphics for 2D rendering</li>

<li>Eventing for user input: keyboard, mouse, and focus eventing</li>

<li>UI layout</li>
</ul>

<p>The fwt defines the basic low level infrastructure for applications. <a href='../flux/pod-doc.html'>Flux</a> is built on top of the fwt to provide a more advanced application framework for desktop apps.</p>

<h1 id='widgets'>Widgets </h1>

<p>The <code><a href='Widget.html'>fwt::Widget</a></code> class is the root of the widget class hierarchy. Widgets represent UI components such as buttons or text fields.</p>

<h2 id='widgetTree'>Widget Tree </h2>

<p>Widgets are structured as a tree.  Typically the root of a visible widget tree is a <code><a href='Window.html'>fwt::Window</a></code> on the screen. Any widget is a potential container for other widgets - although typically only Panes contain children. The following methods are used to work with the widget tree:</p>

<ul>
<li><code><a href='Widget.html#parent'>Widget.parent</a></code>: get the parent of a mounted widget</li>

<li><code><a href='Widget.html#window'>Widget.window</a></code>: get the window ancestor</li>

<li><code><a href='Widget.html#children'>Widget.children</a></code>: list the children widgets</li>

<li><code><a href='Widget.html#each'>Widget.each</a></code>: iterate the children widgets</li>

<li><code><a href='Widget.html#add'>Widget.add</a></code>: add a child widget</li>

<li><code><a href='Widget.html#remove'>Widget.remove</a></code>: remove a child widget</li>
</ul>

<p>A widget may only be mounted under one parent.  If you attempt to add a widget to multiple parents an exception is thrown.</p>

<h2 id='panes'>Panes </h2>

<p>Widgets come in two flavors: panes and controls.  <code><a href='Pane.html'>Panes</a></code> are widgets which are designed to be containers for other widgets.  Panes are responsible for laying out their children.  Widgets which don't subclass from Pane are most often leaf widgets which provide some control such as a button or text field.</p>

<h2 id='customWidgets'>Custom Widgets </h2>

<p>Most often you will use the predefined widgets in the toolkit.  However you can create your own widgets too.  Typically you will subclass <code><a href='Pane.html'>fwt::Pane</a></code> to create a new container widget or <code><a href='Canvas.html'>fwt::Canvas</a></code> for a new control. Panes are responsible for deciding how to layout their children.  Controls will typically define custom painting and eventing.</p>

<h1 id='painting'>Painting </h1>

<p><code><a href='Canvas.html'>Canvas</a></code> widgets may override the <code><a href='Canvas.html#onPaint'>onPaint</a></code> method to provide custom painting.  Painting is done via the <code><a href='../gfx/Graphics.html'>gfx::Graphics</a></code> API:</p>

<ul>
<li>draw geometries</li>

<li>fill geometries</li>

<li>draw text</li>

<li>draw images</li>

<li>coordinate system transformations</li>

<li>clipping</li>
</ul>

<p>A Graphics instance maintains state for how it renders:</p>

<ul>
<li><code><a href='../gfx/Pen.html'>gfx::Pen</a></code> defines how geometries are drawn</li>

<li><code><a href='../gfx/Brush.html'>gfx::Brush</a></code> defines how geometries and text are drawn and filled</li>

<li><code><a href='../gfx/Font.html'>gfx::Font</a></code> defines how text is rendered</li>

<li><code><a href='../gfx/Image.html'>gfx::Image</a></code> models an image - typically loaded from a png, gif, or jpeg file</li>

<li>current clipping region</li>

<li>current transform to apply to the coordinate system</li>
</ul>

<p>You can use the <code><a href='../gfx/Graphics.html#push'>push</a></code> and <code><a href='../gfx/Graphics.html#pop'>pop</a></code> methods to create a <em>stack</em> of Graphics instances and their associated state.  A typical pattern is:</p>

<pre>g.push
try
{
  g.translate(...)
  ...
}
finally
{
  g.pop
}</pre>

<p>The following is a simple widget which paints itself as a red box with a blue outline:</p>

<pre>using gfx
using fwt
class RedBox : Canvas
{
  override Void onPaint(Graphics g)
  {
    w := size.w
    h := size.h
    g.brush = Color.red
    g.fillRect(0, 0, w, h)
    g.brush = Color.blue
    g.drawRect(0, 0, w-1, h-1)
  }

  Void main()
  {
    Window { InsetPane { content = RedBox() }, }.open
  }
}</pre>

<h1 id='layout'>Layout </h1>

<p>Every widget plays a role in how the UI is laid out.  Leaf widgets define a preferred size by overriding the <code><a href='Widget.html#prefSize'>prefSize</a></code> method. The <code>prefSize</code> method takes a <code><a href='../gfx/Hints.html'>gfx::Hints</a></code> which contains an optional width and height constraint.</p>

<p>Panes which contain children implement a layout strategy by overriding the <code><a href='Pane.html#onLayout'>onLayout</a></code> method.  This callback is used to set the bounds of all the children widgets.  Often panes will also override <code>prefSize</code> to compute the containers preferred size from the children.</p>

<h1 id='eventing'>Eventing </h1>

<p>All widgets support a set of eventing callbacks which by convention start with the "on" prefix.  Widget events are declared as fields of type <code><a href='EventListeners.html'>fwt::EventListeners</a></code> which maintain a list of callback functions. Event callbacks take a single <code><a href='Event.html'>Event</a></code> argument.  Refer to the fandoc of each event to see how the Event fields are used.</p>

<p>The following illustrates a simple text field with some event handlers:</p>

<pre>class EventTest
{
  Void main()
  {
    text := Text
    {
      onAction.add |->| { echo("onAction!") }
      onModify.add |event| { echo(event) }
    }

    Window { GridPane { text, }, }.open
  }
}</pre>

<p>The example illustrates creating two callbacks using closures.  The <code>onAction</code> event handler is a closure with no arguments (remember that you can use functions which take <a href='../docLang/Functions.html#arityCompatibility'>fewer arguments</a>). The <code>onModify</code> event handler takes an event parameter.</p>

<h1 id='commands'>Commands </h1>

<p>A common technique in user interfaces to separate the UI elements from the command logic.  For example you might have both a menu item and a toolbar button for a "Save" command.  The <code><a href='Command.html'>fwt::Command</a></code> class is used to manage this design pattern.</p>

<p>Commands are responsible for the text, icon, accelerator, and how a command is executed.  Commands may optionally handle undo/redo. Often the visual elements of a command are stored in a <a href='../docLang/Localization.html#props'>localization props</a> file.  For example to create a localized "Save" command:</p>

<pre>// locale/en.props
save.name=Save
save.icon=fan://icons/x16/save.png
save.accelerator=Ctrl+S

// create Command instance
save := Command.makeLocale(Pod.find("flux"), "save") |->| { echo("save!") }</pre>

<p>You can create UI widgets from commands:</p>

<pre>menu.addCommand(save)
toolBar.addCommand(save)</pre>

<p>Widgets which are mapped to a command are said to be <em>registered</em>.  Registration occurs automatically when setting a widget's <code>command</code> field.  If you create your own custom widgets with command support you should follow the pattern used by <code>Button</code> and <code>MenuItem</code>.  Once a widget is registered with a command, it tracks the command's state.  For example enabling or disabling the command will automatically enable/disable as its registered widgets.  For toggle commands its widgets automatically track the command's select state.</p>
</div>
<div class='sidebar'>
<h2>Contents</h2>
<ul>
<li><a href='#overview'>Overview </a></li><li><a href='#widgets'>Widgets </a><ul>
<li><a href='#widgetTree'>Widget Tree </a></li><li><a href='#panes'>Panes </a></li><li><a href='#customWidgets'>Custom Widgets </a></li></ul>
</li><li><a href='#painting'>Painting </a></li><li><a href='#layout'>Layout </a></li><li><a href='#eventing'>Eventing </a></li><li><a href='#commands'>Commands </a></li></ul>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
fwt 1.0.56
[11-Nov-2010 Thu 10:08:25AM EST]
</p>
</div>
</div>
</body>
</html>

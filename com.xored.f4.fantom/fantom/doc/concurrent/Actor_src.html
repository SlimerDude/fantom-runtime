<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>concurrent::Actor</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>concurrent</a></li>
  <li>&gt;</li>
  <li><a href='Actor.html'>Actor</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>const class</h2>
<h1>concurrent::Actor</h1>
<pre><a href='../sys/Obj.html'>sys::Obj</a>
  concurrent::Actor</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2009, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   26 Mar 09  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Actor is a worker who processes messages asynchronously.</span>
<span class='z'>**</span>
<span class='z'>** See [docLang::Actors]`docLang::Actors` and</span>
<span class='z'>** [examples]`examples::concurrent-actors`.</span>
<span class='z'>**</span>
@Js
<span class='k'>native</span> <span class='k'>const</span> <span class='k'>class</span> Actor
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Construction</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Create an actor whose execution is controlled by the given ActorPool.</span>
  <span class='z'>** If receive is non-null, then it is used to process messages sent to</span>
  <span class='z'>** this actor.  If receive is specified then it must be an immutable</span>
  <span class='z'>** function (it cannot capture state from the calling thread), otherwise</span>
  <span class='z'>** NotImmutableErr is thrown.  If receive is null, then you must subclass</span>
  <span class='z'>** Actor and override the `receive` method.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='make'>make</span><span class='b'>(</span>ActorPool pool, |Obj? -&gt; Obj?|? receive := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Create an actor with a coalescing message loop.  This constructor</span>
  <span class='z'>** follows the same semantics as `make`, but has the ability to coalesce</span>
  <span class='z'>** the messages pending in the thread's message queue.  Coalesced</span>
  <span class='z'>** messages are merged into a single pending message with a shared</span>
  <span class='z'>** Future.</span>
  <span class='z'>**</span>
  <span class='z'>** The 'toKey' function is used to derive a key for each message,</span>
  <span class='z'>** or if null then the message itself is used as the key.  If the 'toKey'</span>
  <span class='z'>** function returns null, then the message is not considered for coalescing.</span>
  <span class='z'>** Internally messages are indexed by key for efficient coalescing.</span>
  <span class='z'>**</span>
  <span class='z'>** If an incoming message has the same key as a pending message</span>
  <span class='z'>** in the queue, then the 'coalesce' function is called to coalesce</span>
  <span class='z'>** the messages into a new merged message.  If 'coalesce' function itself</span>
  <span class='z'>** is null, then we use the incoming message (last one wins).  The coalesced</span>
  <span class='z'>** message occupies the same position in the queue as the original</span>
  <span class='z'>** and reuses the original message's Future instance.</span>
  <span class='z'>**</span>
  <span class='z'>** Both the 'toKey' and 'coalesce' functions are called while holding</span>
  <span class='z'>** an internal lock on the queue.  So the functions must be efficient</span>
  <span class='z'>** and never attempt to interact with other actors.</span>
  <span class='z'>**</span>
  <span class='k'>new</span> <span id='makeCoalescing'>makeCoalescing</span><span class='b'>(</span>ActorPool pool,
                     |Obj? msg -&gt; Obj?|? toKey,
                     |Obj? orig, Obj? incoming -&gt; Obj?|? coalesce,
                     |Obj? -&gt; Obj? |? receive := <span class='k'>null</span><span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Messaging</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** The pool used to control execution of this actor.</span>
  <span class='z'>**</span>
  ActorPool <span id='pool'>pool</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Asynchronously send a message to this actor for processing.</span>
  <span class='z'>** If msg is not immutable or serializable, then IOErr is thrown.</span>
  <span class='z'>** Throw Err if this actor's pool has been stopped.  Return</span>
  <span class='z'>** a future which may be used to obtain the result once it the</span>
  <span class='z'>** actor has processed the message.  If the message is coalesced</span>
  <span class='z'>** then this method returns the original message's future reference.</span>
  <span class='z'>** Also see `sendLater` and `sendWhenDone`.</span>
  <span class='z'>**</span>
  Future <span id='send'>send</span><span class='b'>(</span>Obj? msg<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Schedule a message for delivery after the specified period of</span>
  <span class='z'>** duration has elapsed.  Once the period has elapsed the message is</span>
  <span class='z'>** appended to the end of this actor's queue.  Accuracy of scheduling</span>
  <span class='z'>** is dependent on thread coordination and pending messages in the queue.</span>
  <span class='z'>** Scheduled messages are not guaranteed to be processed if the</span>
  <span class='z'>** actor's pool is stopped.  Scheduled messages are never coalesced.</span>
  <span class='z'>** Also see `send` and `sendWhenDone`.</span>
  <span class='z'>**</span>
  Future <span id='sendLater'>sendLater</span><span class='b'>(</span>Duration d, Obj? msg<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Schedule a message for delivery after the given future has completed.</span>
  <span class='z'>** Completion may be due to the future returning a result, throwing an</span>
  <span class='z'>** exception, or cancellation.  Send when done messages are never</span>
  <span class='z'>** coalesced.  Also see `send` and `sendLater`.</span>
  <span class='z'>**</span>
  Future <span id='sendWhenDone'>sendWhenDone</span><span class='b'>(</span>Future f, Obj? msg<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** The receive behavior for this actor is handled by overriding</span>
  <span class='z'>** this method or by passing a function to the constructor.  Return</span>
  <span class='z'>** the result made available by the Future.  If an exception</span>
  <span class='z'>** is raised by this method, then it is raised by 'Future.get'.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>virtual</span> Obj? <span id='receive'>receive</span><span class='b'>(</span>Obj? msg<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Utils</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Put the currently executing actor thread to sleep for the</span>
  <span class='z'>** specified period.  If the thread is interrupted for any</span>
  <span class='z'>** reason while sleeping, then InterruptedErr is thrown.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Void <span id='sleep'>sleep</span><span class='b'>(</span>Duration duration<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return the map of "global" variables visibile only to the current</span>
  <span class='z'>** actor (similar to how thread locals work in Java).  These variables</span>
  <span class='z'>** are keyed by a string name - by convention use a dotted notation</span>
  <span class='z'>** beginning with your pod name to avoid naming collisions.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Str:Obj? <span id='locals'>locals</span><span class='b'>()</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Actor.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#locals'>locals</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#makeCoalescing'>makeCoalescing</a></li>
  <li style='display: block;'><a href='#pool'>pool</a></li>
  <li style='display: block;'><a href='#receive'>receive</a></li>
  <li style='display: block;'><a href='#send'>send</a></li>
  <li style='display: block;'><a href='#sendLater'>sendLater</a></li>
  <li style='display: block;'><a href='#sendWhenDone'>sendWhenDone</a></li>
  <li style='display: block;'><a href='#sleep'>sleep</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
concurrent 1.0.56
[11-Nov-2010 Thu 10:08:19AM EST]
</p>
</div>
</div>
</body>
</html>

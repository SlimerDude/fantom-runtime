<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>sys::File</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>sys</a></li>
  <li>&gt;</li>
  <li><a href='File.html'>File</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>abstract const class</h2>
<h1>sys::File</h1>
<pre><a href='Obj.html'>sys::Obj</a>
  sys::File</pre>
</div>
<div class='detail'>

<p>File is used to represent a Uri path to a file or directory. See <a href='../examples/sys-files.html'>examples</a>.</p>
</div>
</div>
<div class='slots'>
<div class='detail'>
<h2>Slots</h2>
<dl>
<dt id='basename' class='method'>basename<a href='File_src.html#basename'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a> basename()</code></p>

<p>Convenience for <code><a href='Uri.html#basename'>uri.basename</a></code>.</p>
</dd>
<dt id='copyInto' class='method'>copyInto<a href='File_src.html#copyInto'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a> copyInto(<a href='File.html'>File</a> dir, [<a href='Str.html'>Str</a>:<a href='Obj.html'>Obj</a>]? options := null)</code></p>

<p>Copy this file under the specified directory and return the destination file.  This method is a convenience for:</p>

<pre>return this.copyTo(dir + this.name, options)</pre>
</dd>
<dt id='copyTo' class='method'>copyTo<a href='File_src.html#copyTo'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a> copyTo(<a href='File.html'>File</a> to, [<a href='Str.html'>Str</a>:<a href='Obj.html'>Obj</a>]? options := null)</code></p>

<p>Copy this file or directory to the new specified location. If this file represents a directory, then it recursively copies the entire directory tree.</p>

<p>The options map is used to customize how the copy is performed. The following summarizes the options:</p>

<ul>
<li>exclude:   Regex or |File f->Bool|</li>

<li>overwrite: Bool or |File f->Bool|</li>
</ul>

<p>If the "exclude" option is a Regex - each source file's Uri string is is checked for a match to skip.  If a directory is skipped, then its children are skipped also.  The exclude option can also be a function of type <code>|File f->Bool|</code> to check each file.  Exclude processing is performed first before checking for an overwrite.</p>

<p>If during the copy, an existing file of the same name is found, then the "overwrite" option should be to <code>true</code> to overwrite or <code>false</code> to skip.  The overwrite option can also be a function of type <code>|File f->Bool|</code> which is passed every destination file to be overwritten.  If the overwrite function throws an exception, it is raised to the <code>copyTo</code> caller.  If a directory overwrite is skipped, then it its children are skipped too.  If options are null or overwrite is unspecified then the copy is immediately terminated with an IOErr.</p>

<p>Any IOErr or other error encountered during the file copy immediately terminates the copy and is raised to the caller, which might leave the copy in an unfinished state.</p>

<p>Return the <code>to</code> destination file.</p>
</dd>
<dt id='create' class='method'>create<a href='File_src.html#create'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a> create()</code></p>

<p>Create a file or directory represented by this Uri.  If isDir() is false then create an empty file, or if the file already exists overwrite it to empty.  If isDir() is true then create a directory, or if the directory already exists do nothing.  This method will automatically create any parent directories.  Throw IOErr on error. Return this.</p>
</dd>
<dt id='createDir' class='method'>createDir<a href='File_src.html#createDir'>Source</a></dt>
<dd>
<p><code class='sig'><a href='File.html'>File</a> createDir(<a href='Str.html'>Str</a> name)</code></p>

<p>Create a sub-directory under this directory.  Convenience for <a href='File.html#create'>create</a>:</p>

<pre>return (this+name/.toUri).create</pre>

<p>Throw IOErr is this file is not a directory or if there is a error creating the new directory.  Return the directory created.</p>
</dd>
<dt id='createFile' class='method'>createFile<a href='File_src.html#createFile'>Source</a></dt>
<dd>
<p><code class='sig'><a href='File.html'>File</a> createFile(<a href='Str.html'>Str</a> name)</code></p>

<p>Create a file under this directory.  Convenience for <a href='File.html#create'>create</a>:</p>

<pre>return (this+name.toUri).create</pre>

<p>Throw IOErr is this file is not a directory or if there is a error creating the new file.  Return the file created.</p>
</dd>
<dt id='createTemp' class='method'>createTemp<a href='File_src.html#createTemp'>Source</a></dt>
<dd>
<p><code class='sig'>static <a href='File.html'>File</a> createTemp(<a href='Str.html'>Str</a> prefix := "fan", <a href='Str.html'>Str</a> suffix := ".tmp", <a href='File.html'>File</a>? dir := null)</code></p>

<p>Create a temporary file which is guaranteed to be a new, empty file with a unique name.  The file name will be generated using the specified prefix and suffix.  If dir is non-null then it is used as the file's parent directory, otherwise the system's default temporary directory is used.  If dir is specified it must be a directory on the local file system.  See <a href='File.html#deleteOnExit'>deleteOnExit</a> if you wish to have the file automatically deleted on exit.  Throw IOErr on error.</p>

<p>Examples:</p>

<pre>File.createTemp("x", ".txt") => `/tmp/x67392.txt`
File.createTemp.deleteOnExit => `/tmp/fan5284.tmp`</pre>
</dd>
<dt id='delete' class='method'>delete<a href='File_src.html#delete'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Void.html'>Void</a> delete()</code></p>

<p>Delete this file.  If this file represents a directory, then recursively delete it.  If the file does not exist, then no action is taken.  Throw IOErr on error.</p>
</dd>
<dt id='deleteOnExit' class='method'>deleteOnExit<a href='File_src.html#deleteOnExit'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a> deleteOnExit()</code></p>

<p>Request that the file or directory represented by this File be deleted when the virtual machine exits.  Long running applications should use this method will care since each file marked to delete will consume resources.  Throw IOErr on error.  Return this.</p>
</dd>
<dt id='eachLine' class='method'>eachLine<a href='File_src.html#eachLine'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Void.html'>Void</a> eachLine(|<a href='Str.html'>Str</a>| f)</code></p>

<p>Convenience for <code><a href='File.html#eachLine'>in.eachLine</a></code>. The input stream is guaranteed to be closed.</p>
</dd>
<dt id='equals' class='method'>equals<a href='File_src.html#equals'>Source</a></dt>
<dd>
<p><code class='sig'>override <a href='Bool.html'>Bool</a> equals(<a href='Obj.html'>Obj</a>? that)</code></p>
<div class='slotInfo'>
<p>Overrides <a href='Obj.html#equals'>sys::Obj.equals</a></p>
</div>

<p>File equality is based on the un-normalized Uri used to create the File.</p>
</dd>
<dt id='exists' class='method'>exists<a href='File_src.html#exists'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Bool.html'>Bool</a> exists()</code></p>

<p>Return if this file exists.</p>
</dd>
<dt id='ext' class='method'>ext<a href='File_src.html#ext'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a>? ext()</code></p>

<p>Convenience for <code><a href='Uri.html#ext'>uri.ext</a></code>.</p>
</dd>
<dt id='hash' class='method'>hash<a href='File_src.html#hash'>Source</a></dt>
<dd>
<p><code class='sig'>override <a href='Int.html'>Int</a> hash()</code></p>
<div class='slotInfo'>
<p>Overrides <a href='Obj.html#hash'>sys::Obj.hash</a></p>
</div>

<p>Return <code>uri.hash</code>.</p>
</dd>
<dt id='in' class='method'>in<a href='File_src.html#in'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='InStream.html'>InStream</a> in(<a href='Int.html'>Int</a>? bufferSize := (Int?)4096)</code></p>

<p>Open a new buffered InStream used to read from this file.  A bufferSize of null or zero will return an unbuffered input stream. Throw IOErr on error.</p>
</dd>
<dt id='isDir' class='method'>isDir<a href='File_src.html#isDir'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Bool.html'>Bool</a> isDir()</code></p>

<p>Convenience for <code><a href='Uri.html#isDir'>uri.isDir</a></code></p>
</dd>
<dt id='list' class='method'>list<a href='File_src.html#list'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a>[] list()</code></p>

<p>List the files contained by this directory.  This list includes both child sub-directories and normal files.  If the directory is empty or this file doesn't represent a directory, then return an empty list.</p>
</dd>
<dt id='listDirs' class='method'>listDirs<a href='File_src.html#listDirs'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a>[] listDirs()</code></p>

<p>List the child sub-directories contained by this directory.  If the directory doesn't contain any sub-direcotries or this file doesn't represent a directory, then return an empty list.</p>
</dd>
<dt id='listFiles' class='method'>listFiles<a href='File_src.html#listFiles'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a>[] listFiles()</code></p>

<p>List the child files (excludes directories) contained by this directory.  If the directory doesn't contain any child files or this file doesn't represent a directory, then return an empty list.</p>
</dd>
<dt id='make' class='method'>make<a href='File_src.html#make'>Source</a></dt>
<dd>
<p><code class='sig'>static <a href='File.html'>File</a> make(<a href='Uri.html'>Uri</a> uri, <a href='Bool.html'>Bool</a> checkSlash := true)</code></p>

<p>Make a File for the Uri which represents a file on the local file system.  If creating a Uri to a directory, then the Uri must end in a trailing "/" slash or IOErr is thrown - or you may pass false for checkSlash in which case the trailing slash is implicitly added.  However if a trailing slash is added, then the resulting File's uri will not match the uri passed to this method. If the file doesn't exist, then it is assumed to be to a directory based on a trailing slash (see <a href='File.html#isDir'>isDir</a>).  If the Uri has a relative path, then it is assumed to be relative to the current working directory.  Throw ArgErr if the Uri has a scheme other than null or "file:".</p>
</dd>
<dt id='makeNew' class='method'>makeNew<a href='File_src.html#makeNew'>Source</a></dt>
<dd>
<p><code class='sig'>new makeNew(<a href='Uri.html'>Uri</a> uri)</code></p>

<p>Protected constructor for subclasses.</p>
</dd>
<dt id='mimeType' class='method'>mimeType<a href='File_src.html#mimeType'>Source</a></dt>
<dd>
<p><code class='sig'><a href='MimeType.html'>MimeType</a>? mimeType()</code></p>

<p>Convenience for <code><a href='Uri.html#mimeType'>uri.mimeType</a></code>.</p>
</dd>
<dt id='mmap' class='method'>mmap<a href='File_src.html#mmap'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Buf.html'>Buf</a> mmap(<a href='Str.html'>Str</a> mode := "rw", <a href='Int.html'>Int</a> pos := 0, <a href='Int.html'>Int</a>? size := null)</code></p>

<p>Memory map the region of the file specified by <code>pos</code> and <code>size</code>. The file is paged into virtual memory on demand.  Modes are:</p>

<ul>
<li>"r": map the file for reading only.  Throws IOErr if file does not exist.</li>

<li>"rw": open the file for reading and writing; create if the file does not exist.</li>

<li>"p": private read/write mode will not propagate changes to other processes which have mapped the file.</li>
</ul>
</dd>
<dt id='modified' class='field'>modified<a href='File_src.html#modified'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='DateTime.html'>DateTime</a>? modified</code></p>

<p>Get time the file was last modified or null if unknown.</p>
</dd>
<dt id='moveInto' class='method'>moveInto<a href='File_src.html#moveInto'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a> moveInto(<a href='File.html'>File</a> dir)</code></p>

<p>Move this file under the specified directory and return the destination file.  This method is a convenience for:</p>

<pre>return this.moveTo(dir + this.name)</pre>
</dd>
<dt id='moveTo' class='method'>moveTo<a href='File_src.html#moveTo'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a> moveTo(<a href='File.html'>File</a> to)</code></p>

<p>Move this file to the specified location.  If this file is a directory, then the entire directory is moved.  If the target file already exists or the move fails, then an IOErr is thrown.  Return the <code>to</code> destination file.</p>
</dd>
<dt id='name' class='method'>name<a href='File_src.html#name'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a> name()</code></p>

<p>Convenience for <code><a href='Uri.html#name'>uri.name</a></code>.</p>
</dd>
<dt id='normalize' class='method'>normalize<a href='File_src.html#normalize'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a> normalize()</code></p>

<p>Normalize this file path to its canonical representation. If a file on the local file system, then the uri will include the "file:" scheme.  Throw IOErr on error.</p>
</dd>
<dt id='open' class='method'>open<a href='File_src.html#open'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Buf.html'>Buf</a> open(<a href='Str.html'>Str</a> mode := "rw")</code></p>

<p>Open this file for random access.  Modes are:</p>

<ul>
<li>"r": open the file for reading only.  Throws IOErr if file does not exist.</li>

<li>"rw": open the file for reading and writing; create if the file does not exist.</li>
</ul>

<p>The Buf instance returned is backed by a random access file pointer. It provides the same functionality as a memory backed buffer, except for a couple exceptions such as <code><a href='Buf.html#unread'>Buf.unread</a></code>. The resulting Buf is a raw interface to the random access file, no buffering is provided at the framework level - so use methods which only access a few bytes carefully.  However methods which transfer data with other Bufs and IO streams will use an internal buffer for efficiency.</p>
</dd>
<dt id='os' class='method'>os<a href='File_src.html#os'>Source</a></dt>
<dd>
<p><code class='sig'>static <a href='File.html'>File</a> os(<a href='Str.html'>Str</a> osPath)</code></p>

<p>Make a File for the specified operating system specific path on the local file system.</p>
</dd>
<dt id='osPath' class='method'>osPath<a href='File_src.html#osPath'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Str.html'>Str</a>? osPath()</code></p>

<p>Get this File as an operating system specific path on the local system.  If this File doesn't represent a path on the local file system then return null.</p>
</dd>
<dt id='osRoots' class='method'>osRoots<a href='File_src.html#osRoots'>Source</a></dt>
<dd>
<p><code class='sig'>static <a href='File.html'>File</a>[] osRoots()</code></p>

<p>Get the root directories of the operating system's local file system.</p>
</dd>
<dt id='out' class='method'>out<a href='File_src.html#out'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='OutStream.html'>OutStream</a> out(<a href='Bool.html'>Bool</a> append := false, <a href='Int.html'>Int</a>? bufferSize := (Int?)4096)</code></p>

<p>Open a new buffered OutStream used to write to this file.  If append is true, then we open the file to append to the end, otherwise it is opened as an empty file.  A bufferSize of null or zero will return an unbuffered input stream.  Throw IOErr on error.</p>
</dd>
<dt id='parent' class='method'>parent<a href='File_src.html#parent'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='File.html'>File</a>? parent()</code></p>

<p>Get the parent directory of this file or null. Also see <code><a href='Uri.html#parent'>Uri.parent</a></code>.</p>
</dd>
<dt id='path' class='method'>path<a href='File_src.html#path'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a>[] path()</code></p>

<p>Convenience for <code><a href='Uri.html#path'>uri.path</a></code>.</p>
</dd>
<dt id='pathSep' class='field'>pathSep<a href='File_src.html#pathSep'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='Str.html'>Str</a> pathSep</code></p>

<p>Return the platform's separator for a list of paths: semicolon on Windows, colon on Unix.</p>
</dd>
<dt id='pathStr' class='method'>pathStr<a href='File_src.html#pathStr'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a> pathStr()</code></p>

<p>Convenience for <code><a href='Uri.html#pathStr'>uri.pathStr</a></code>.</p>
</dd>
<dt id='plus' class='method'>plus<a href='File_src.html#plus'>Source</a></dt>
<dd>
<p><code class='sig'>@<a href='Operator.html'>Operator</a> <br/>
abstract <a href='File.html'>File</a> plus(<a href='Uri.html'>Uri</a> path, <a href='Bool.html'>Bool</a> checkSlash := true)</code></p>

<p>Make a new File instance by joining this file's Uri together with the specified path.  If the file maps to a directory and the resulting Uri doesn't end in slash then an IOErr is thrown - or pass false for checkSlash to have the slash implicitly added.</p>

<p>Examples:</p>

<pre>File(`a/b/`) + `c` => File(`a/b/c`)
File(`a/b`) + `c`  => File(`a/c`)</pre>
</dd>
<dt id='readAllBuf' class='method'>readAllBuf<a href='File_src.html#readAllBuf'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Buf.html'>Buf</a> readAllBuf()</code></p>

<p>Convenience for <code><a href='File.html#readAllBuf'>in.readAllBuf</a></code>. The input stream is guaranteed to be closed.</p>
</dd>
<dt id='readAllLines' class='method'>readAllLines<a href='File_src.html#readAllLines'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a>[] readAllLines()</code></p>

<p>Convenience for <code><a href='File.html#readAllLines'>in.readAllLines</a></code>. The input stream is guaranteed to be closed.</p>
</dd>
<dt id='readAllStr' class='method'>readAllStr<a href='File_src.html#readAllStr'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a> readAllStr(<a href='Bool.html'>Bool</a> normalizeNewlines := true)</code></p>

<p>Convenience for <code><a href='File.html#readAllStr'>in.readAllStr</a></code>. The input stream is guaranteed to be closed.</p>
</dd>
<dt id='readObj' class='method'>readObj<a href='File_src.html#readObj'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Obj.html'>Obj</a>? readObj([<a href='Str.html'>Str</a>:<a href='Obj.html'>Obj</a>]? options := null)</code></p>

<p>Convenience for <code><a href='InStream.html#readObj'>in.readObj</a></code> The input stream is guaranteed to be closed.</p>
</dd>
<dt id='readProps' class='method'>readProps<a href='File_src.html#readProps'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Str.html'>Str</a>:<a href='Str.html'>Str</a> readProps()</code></p>

<p>Convenience for <code><a href='File.html#readProps'>in.readProps()</a></code>. The input stream is guaranteed to be closed.</p>
</dd>
<dt id='rename' class='method'>rename<a href='File_src.html#rename'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='File.html'>File</a> rename(<a href='Str.html'>Str</a> newName)</code></p>

<p>Renaming this file within its current directory. It is a convenience for:</p>

<pre>return this.moveTo(parent + newName)</pre>
</dd>
<dt id='sep' class='field'>sep<a href='File_src.html#sep'>Source</a></dt>
<dd>
<p><code class='sig'>const static <a href='Str.html'>Str</a> sep</code></p>

<p>Return the platform's separator for names within in a path: backslash on Windows, forward slash on Unix.</p>
</dd>
<dt id='size' class='method'>size<a href='File_src.html#size'>Source</a></dt>
<dd>
<p><code class='sig'>abstract <a href='Int.html'>Int</a>? size()</code></p>

<p>Return the size of the file in bytes otherwise null if a directory or unknown.</p>
</dd>
<dt id='toStr' class='method'>toStr<a href='File_src.html#toStr'>Source</a></dt>
<dd>
<p><code class='sig'>override <a href='Str.html'>Str</a> toStr()</code></p>
<div class='slotInfo'>
<p>Overrides <a href='Obj.html#toStr'>sys::Obj.toStr</a></p>
</div>

<p>Return <code>uri.toStr</code>.</p>
</dd>
<dt id='uri' class='method'>uri<a href='File_src.html#uri'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Uri.html'>Uri</a> uri()</code></p>

<p>Return the Uri path used to create this File. This Uri may be absolute or relative.</p>
</dd>
<dt id='walk' class='method'>walk<a href='File_src.html#walk'>Source</a></dt>
<dd>
<p><code class='sig'>virtual <a href='Void.html'>Void</a> walk(|<a href='File.html'>File</a>| c)</code></p>

<p>Recursively walk this file/directory top down.  If this file is not a directory then the callback is invoked exactly once with this file.  If a directory, then the callback is invoked with this file, then recursively for each child file.</p>
</dd>
<dt id='writeObj' class='method'>writeObj<a href='File_src.html#writeObj'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Void.html'>Void</a> writeObj(<a href='Obj.html'>Obj</a>? obj, [<a href='Str.html'>Str</a>:<a href='Obj.html'>Obj</a>]? options := null)</code></p>

<p>Convenience for <code><a href='OutStream.html#writeObj'>out.writeObj</a></code> The output stream is guaranteed to be closed.</p>
</dd>
<dt id='writeProps' class='method'>writeProps<a href='File_src.html#writeProps'>Source</a></dt>
<dd>
<p><code class='sig'><a href='Void.html'>Void</a> writeProps(<a href='Str.html'>Str</a>:<a href='Str.html'>Str</a> props)</code></p>

<p>Convenience for <code><a href='File.html#writeProps'>out.writeProps()</a></code>. The output stream is guaranteed to be closed.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class='sidebar'>
<h2>Type</h2>
<ul class='clean'>
  <li><a href='File_src.html'>View Source</a></li>
  <li><a href='#' onclick='ShowSlots.toggle(event); return false;'>Show All Slots</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li><a href='#basename'>basename</a></li>
  <li><a href='#copyInto'>copyInto</a></li>
  <li><a href='#copyTo'>copyTo</a></li>
  <li><a href='#create'>create</a></li>
  <li><a href='#createDir'>createDir</a></li>
  <li><a href='#createFile'>createFile</a></li>
  <li><a href='#createTemp'>createTemp</a></li>
  <li><a href='#delete'>delete</a></li>
  <li><a href='#deleteOnExit'>deleteOnExit</a></li>
  <li><a href='#eachLine'>eachLine</a></li>
  <li><a href='#equals'>equals</a></li>
  <li><a href='#exists'>exists</a></li>
  <li><a href='#ext'>ext</a></li>
  <li><a href='#hash'>hash</a></li>
  <li><a href='#in'>in</a></li>
  <li><a href='#isDir'>isDir</a></li>
  <li><a href='#list'>list</a></li>
  <li><a href='#listDirs'>listDirs</a></li>
  <li><a href='#listFiles'>listFiles</a></li>
  <li><a href='#make'>make</a></li>
  <li><a href='#makeNew'>makeNew</a></li>
  <li><a href='#mimeType'>mimeType</a></li>
  <li><a href='#mmap'>mmap</a></li>
  <li><a href='#modified'>modified</a></li>
  <li><a href='#moveInto'>moveInto</a></li>
  <li><a href='#moveTo'>moveTo</a></li>
  <li><a href='#name'>name</a></li>
  <li><a href='#normalize'>normalize</a></li>
  <li><a href='#open'>open</a></li>
  <li><a href='#os'>os</a></li>
  <li><a href='#osPath'>osPath</a></li>
  <li><a href='#osRoots'>osRoots</a></li>
  <li><a href='#out'>out</a></li>
  <li><a href='#parent'>parent</a></li>
  <li><a href='#path'>path</a></li>
  <li><a href='#pathSep'>pathSep</a></li>
  <li><a href='#pathStr'>pathStr</a></li>
  <li><a href='#plus'>plus</a></li>
  <li><a href='#readAllBuf'>readAllBuf</a></li>
  <li><a href='#readAllLines'>readAllLines</a></li>
  <li><a href='#readAllStr'>readAllStr</a></li>
  <li><a href='#readObj'>readObj</a></li>
  <li><a href='#readProps'>readProps</a></li>
  <li><a href='#rename'>rename</a></li>
  <li><a href='#sep'>sep</a></li>
  <li><a href='#size'>size</a></li>
  <li><a href='#toStr'>toStr</a></li>
  <li><a href='#uri'>uri</a></li>
  <li><a href='#walk'>walk</a></li>
  <li><a href='#writeObj'>writeObj</a></li>
  <li><a href='#writeProps'>writeProps</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
sys 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>

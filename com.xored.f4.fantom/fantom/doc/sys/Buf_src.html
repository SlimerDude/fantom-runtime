<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>sys::Buf</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>sys</a></li>
  <li>&gt;</li>
  <li><a href='Buf.html'>Buf</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>class</h2>
<h1>sys::Buf</h1>
<pre><a href='Obj.html'>sys::Obj</a>
  sys::Buf</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   16 Mar 06  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Buf is used to model a block of bytes with random access.  Buf is</span>
<span class='z'>** typically backed by a block of memory, but can also be backed by</span>
<span class='z'>** a file:</span>
<span class='z'>**   - `Buf.make`: backed by RAM</span>
<span class='z'>**   - `File.open`: backed by random access file</span>
<span class='z'>**   - `File.mmap`: backed by memory mapped file</span>
<span class='z'>**</span>
<span class='z'>** Buf provides an `InStream` and `OutStream` to read and write into</span>
<span class='z'>** the buffer using a configurable position accessed via `Buf.pos`</span>
<span class='z'>** and `Buf.seek`.</span>
<span class='z'>**</span>
<span class='z'>** When using an InStream, bytes are read starting at pos where pos</span>
<span class='z'>** is advanced after each read.  The end of stream is reached when pos</span>
<span class='z'>** reaches size.  When using the OutStream, bytes are written starting at pos</span>
<span class='z'>** with pos advanced after each write.  If pos is less then size then</span>
<span class='z'>** the existing bytes are rewritten and size is not advanced, otherwise</span>
<span class='z'>** the buffer is automatically grown and size is advanced as bytes are</span>
<span class='z'>** appended.  It is common to write bytes into the buffer using the</span>
<span class='z'>** OutStream, then call `Buf.flip` to prepare the buffer to be used for reading.</span>
<span class='z'>**</span>
<span class='k'>class</span> Buf
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Factory</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Allocate a byte buffer in RAM with the initial given capacity.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Buf <span id='make'>make</span><span class='b'>(</span>Int capacity := 1024<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Generate a random series of bytes.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.random(8).toHex  =&gt; "d548b54989028b90"</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Buf <span id='random'>random</span><span class='b'>(</span>Int size<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Buf cannot be subclassed outside of sys since we do</span>
  <span class='z'>** much optimization under the covers in Java and C#.</span>
  <span class='z'>**</span>
  <span class='k'>internal</span> <span class='k'>new</span> <span id='internalMake'>internalMake</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Identity</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Buf equality is based on reference equality using the === operator.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Bool <span id='equals'>equals</span><span class='b'>(</span>Obj? that<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return string summary of the buffer.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Access</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if size() == 0.</span>
  <span class='z'>**</span>
  Bool <span id='isEmpty'>isEmpty</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the total number of bytes in the buffer.  If the size is</span>
  <span class='z'>** set greater than capacity then the buffer's capacity is automatically</span>
  <span class='z'>** grown, otherwise capacity remains the same.  Setting size does not</span>
  <span class='z'>** actually change any bytes in the buffer.  A mmap buffer can never</span>
  <span class='z'>** be increased from its initial size.</span>
  <span class='z'>**</span>
  Int <span id='size'>size</span>

  <span class='z'>**</span>
  <span class='z'>** The number of bytes this buffer can hold without allocating more</span>
  <span class='z'>** memory.  Capacity is always greater or equal to size.  If adding a</span>
  <span class='z'>** large number of bytes, it may be more efficient to manually set</span>
  <span class='z'>** capacity.  See the `trim` method to automatically set capacity to</span>
  <span class='z'>** size.  Throw ArgErr if attempting to set capacity less than size.</span>
  <span class='z'>** This method is ignored on a file buffer, and unsupported on mmap.</span>
  <span class='z'>**</span>
  Int <span id='capacity'>capacity</span>

  <span class='z'>**</span>
  <span class='z'>** Return the current position for the next read or write.  The</span>
  <span class='z'>** position is always between 0 and `size`.  If pos is less then</span>
  <span class='z'>** size then future writes will rewrite the existing bytes without</span>
  <span class='z'>** growing size.  Change the position with `seek`.</span>
  <span class='z'>**</span>
  Int <span id='pos'>pos</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the remaining number of bytes to read: size-pos.</span>
  <span class='z'>**</span>
  Int <span id='remaining'>remaining</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if more bytes are available to read: remaining() &gt; 0.</span>
  <span class='z'>**</span>
  Bool <span id='more'>more</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Set the current position to the specified byte offset.  A</span>
  <span class='z'>** negative index may be used to access from the end of the buffer.</span>
  <span class='z'>** For example seek(-1) is translated into seek(size-1).</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='seek'>seek</span><span class='b'>(</span>Int pos<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Flip a buffer from write-mode to read-mode.  This method sets</span>
  <span class='z'>** total size to current position, and position to 0.  Return this.</span>
  <span class='z'>**</span>
  This <span id='flip'>flip</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get the byte at the specified absolute index.  A negative index</span>
  <span class='z'>** may be used to access from the end of the buffer.  For example</span>
  <span class='z'>** get(-1)  is translated into get(size()-1).  This method accesses</span>
  <span class='z'>** the buffer absolutely independent of current position.  The get</span>
  <span class='z'>** method is accessed via the [] shortcut operator.  Throw IndexErr</span>
  <span class='z'>** if index out of range.</span>
  <span class='z'>**</span>
  @Operator Int <span id='get'>get</span><span class='b'>(</span>Int index<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return a new buffer containing the bytes in the specified absolute</span>
  <span class='z'>** range.  Negative indexes may be used to access from the end of</span>
  <span class='z'>** the buf.  This method accesses the buffer absolutely independent</span>
  <span class='z'>** of current position.  This method is accessed via the [] operator.</span>
  <span class='z'>** Throw IndexErr if range illegal.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   buf := Buf.make</span>
  <span class='z'>**   buf.write(0xaa).write(0xbb).write(0xcc).write(0xdd)</span>
  <span class='z'>**   buf[0..2]   =&gt; 0x[aabbcc]</span>
  <span class='z'>**   buf[3..3]   =&gt; 0x[dd]</span>
  <span class='z'>**   buf[-2..-1] =&gt; 0x[ccdd]</span>
  <span class='z'>**   buf[0..&lt;2]  =&gt; 0x[aabb]</span>
  <span class='z'>**   buf[1..-2]  =&gt; 0x[bbcc]</span>
  <span class='z'>**</span>
  @Operator Buf <span id='getRange'>getRange</span><span class='b'>(</span>Range range<span class='b'>)</span>

  <span class='z'>** TODO: use `getRange`</span>
  @Deprecated Buf <span id='slice'>slice</span><span class='b'>(</span>Range range<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Create a new buffer in memory which deeply clones this buffer.</span>
  <span class='z'>**</span>
  Buf <span id='dup'>dup</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Modification</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Set is used to overwrite the byte at the specified the index.  A</span>
  <span class='z'>** negative index may be used to access an index from the end of the</span>
  <span class='z'>** buffer.  The set method is accessed via the []= shortcut operator.</span>
  <span class='z'>** Return this.  Throw IndexErr if index is out of range.</span>
  <span class='z'>**</span>
  @Operator This <span id='set'>set</span><span class='b'>(</span>Int index, Int byte<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Read the buffer for a fresh read by reseting the buffer's pos</span>
  <span class='z'>** and size to zero.  The buffer's capacity remains the same.</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='clear'>clear</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Trim the capacity such that the underlying storage is optimized</span>
  <span class='z'>** for the current size.  Return this.</span>
  <span class='z'>**</span>
  This <span id='trim'>trim</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** If this buffer is backed by a file, then close it.  If a memory</span>
  <span class='z'>** buffer then do nothing.  This method is guaranteed to never</span>
  <span class='z'>** throw an IOErr.  Return true if the buffer was closed</span>
  <span class='z'>** successfully or false if closed abnormally.</span>
  <span class='z'>**</span>
  Bool <span id='close'>close</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** If this Buf is backed by a file, then force all changes</span>
  <span class='z'>** to the storage device.  Throw IOErr on error.  Return this.</span>
  <span class='z'>**</span>
  This <span id='flush'>flush</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Byte order mode for both OutStream and InStream.</span>
  <span class='z'>** Default is `Endian.big` (network byte order).</span>
  <span class='z'>**</span>
  Endian <span id='endian'>endian</span>

  <span class='z'>**</span>
  <span class='z'>** Character set for both the OutStream and InStream.</span>
  <span class='z'>**</span>
  Charset <span id='charset'>charset</span>

  <span class='z'>**</span>
  <span class='z'>** Write the specified byte to the end of the buffer using given count.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Buf().fill(0xff, 4)  =&gt;  0xffffffff</span>
  <span class='z'>**</span>
  This <span id='fill'>fill</span><span class='b'>(</span>Int byte, Int times<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// OutStream</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the OutStream which writes to this buffer.</span>
  <span class='z'>** This method always returns the same instance.</span>
  <span class='z'>** If this buffer is backed by a file, then 'out.close'</span>
  <span class='z'>** will not close the file - you must use `Buf.close`.</span>
  <span class='z'>**</span>
  OutStream <span id='out'>out</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.write]`OutStream.write`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='write'>write</span><span class='b'>(</span>Int byte<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeBuf]`OutStream.writeBuf`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeBuf'>writeBuf</span><span class='b'>(</span>Buf buf, Int n := buf.remaining<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeI2]`OutStream.writeI2`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeI2'>writeI2</span><span class='b'>(</span>Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeI4]`OutStream.writeI4`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeI4'>writeI4</span><span class='b'>(</span>Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeI8]`OutStream.writeI8`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeI8'>writeI8</span><span class='b'>(</span>Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeF4]`OutStream.writeF4`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeF4'>writeF4</span><span class='b'>(</span>Float r<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeF8]`OutStream.writeF8`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeF8'>writeF8</span><span class='b'>(</span>Float r<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeDecimal]`OutStream.writeDecimal`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeDecimal'>writeDecimal</span><span class='b'>(</span>Decimal d<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeBool]`OutStream.writeBool`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeBool'>writeBool</span><span class='b'>(</span>Bool b<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeUtf]`OutStream.writeUtf`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeUtf'>writeUtf</span><span class='b'>(</span>Str s<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeChar]`OutStream.writeChar`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeChar'>writeChar</span><span class='b'>(</span>Int char<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeChars]`OutStream.writeChars`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeChars'>writeChars</span><span class='b'>(</span>Str str, Int off := 0, Int len := str.size-off<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.print]`OutStream.print`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='print'>print</span><span class='b'>(</span>Obj? s<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.printLine]`OutStream.printLine`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='printLine'>printLine</span><span class='b'>(</span>Obj? obj := <span class='s'>""</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeProps]`OutStream.writeProps`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeProps'>writeProps</span><span class='b'>(</span>Str:Str props<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeObj]`OutStream.writeObj`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeObj'>writeObj</span><span class='b'>(</span>Obj? obj, <span class='b'>[</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeXml]`OutStream.writeXml`</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  This <span id='writeXml'>writeXml</span><span class='b'>(</span>Str s, Int flags := 0<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// InStream</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the InStream which reads from this buffer.</span>
  <span class='z'>** This method always returns the same instance.</span>
  <span class='z'>** If this buffer is backed by a file, then 'in.close'</span>
  <span class='z'>** will not close the file - you must use `Buf.close`.</span>
  <span class='z'>**</span>
  InStream <span id='in'>in</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.read]`InStream.read`</span>
  <span class='z'>**</span>
  Int? <span id='read'>read</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readBuf]`InStream.readBuf`</span>
  <span class='z'>**</span>
  Int? <span id='readBuf'>readBuf</span><span class='b'>(</span>Buf buf, Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.unread]`InStream.unread`</span>
  <span class='z'>** Memory backed buffers support a stack based pushback model</span>
  <span class='z'>** like IO streams.  File backed buffers will simply rewrite</span>
  <span class='z'>** the last position in the file.  Return this.</span>
  <span class='z'>**</span>
  This <span id='unread'>unread</span><span class='b'>(</span>Int b<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllBuf]`InStream.readAllBuf`</span>
  <span class='z'>**</span>
  Buf <span id='readAllBuf'>readAllBuf</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readBufFully]`InStream.readBufFully`</span>
  <span class='z'>**</span>
  Buf <span id='readBufFully'>readBufFully</span><span class='b'>(</span>Buf? buf, Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.peek]`InStream.peek`</span>
  <span class='z'>**</span>
  Int? <span id='peek'>peek</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readU1]`InStream.readU1`</span>
  <span class='z'>**</span>
  Int <span id='readU1'>readU1</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readS1]`InStream.readS1`</span>
  <span class='z'>**</span>
  Int <span id='readS1'>readS1</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readU2]`InStream.readU2`</span>
  <span class='z'>**</span>
  Int <span id='readU2'>readU2</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readS2]`InStream.readS2`</span>
  <span class='z'>**</span>
  Int <span id='readS2'>readS2</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readU4]`InStream.readU4`</span>
  <span class='z'>**</span>
  Int <span id='readU4'>readU4</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readS4]`InStream.readS4`</span>
  <span class='z'>**</span>
  Int <span id='readS4'>readS4</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readS8]`InStream.readS8`</span>
  <span class='z'>**</span>
  Int <span id='readS8'>readS8</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readF4]`InStream.readF4`</span>
  <span class='z'>**</span>
  Float <span id='readF4'>readF4</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readF8]`InStream.readF8`</span>
  <span class='z'>**</span>
  Float <span id='readF8'>readF8</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readDecimal]`InStream.readDecimal`</span>
  <span class='z'>**</span>
  Decimal <span id='readDecimal'>readDecimal</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readBool]`InStream.readBool`</span>
  <span class='z'>**</span>
  Bool <span id='readBool'>readBool</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readUtf]`InStream.readUtf`</span>
  <span class='z'>**</span>
  Str <span id='readUtf'>readUtf</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readChar]`InStream.readChar`</span>
  <span class='z'>**</span>
  Int? <span id='readChar'>readChar</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.unreadChar]`InStream.unreadChar`</span>
  <span class='z'>** Memory backed buffers support a stack based pushback model</span>
  <span class='z'>** like IO streams.  File backed buffers will simply rewrite</span>
  <span class='z'>** the last position in the file.  Return this.</span>
  <span class='z'>**</span>
  This <span id='unreadChar'>unreadChar</span><span class='b'>(</span>Int b<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.peekChar]`InStream.peekChar`</span>
  <span class='z'>**</span>
  Int? <span id='peekChar'>peekChar</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readChars]`InStream.readChars`</span>
  <span class='z'>**</span>
  Str <span id='readChars'>readChars</span><span class='b'>(</span>Int n<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readLine]`InStream.readLine`</span>
  <span class='z'>**</span>
  Str? <span id='readLine'>readLine</span><span class='b'>(</span>Int? max := 4096<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readStrToken]`InStream.readStrToken`</span>
  <span class='z'>**</span>
  Str? <span id='readStrToken'>readStrToken</span><span class='b'>(</span>Int? max := 4096, |Int ch-&gt;Bool|? c := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllLines]`InStream.readAllLines`</span>
  <span class='z'>**</span>
  Str<span class='b'>[]</span> <span id='readAllLines'>readAllLines</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.eachLine]`InStream.eachLine`</span>
  <span class='z'>**</span>
  Void <span id='eachLine'>eachLine</span><span class='b'>(</span>|Str line| f<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllStr]`InStream.readAllStr`</span>
  <span class='z'>**</span>
  Str <span id='readAllStr'>readAllStr</span><span class='b'>(</span>Bool normalizeNewlines := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readProps]`InStream.readProps`</span>
  <span class='z'>**</span>
  Str:Str <span id='readProps'>readProps</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readObj]`InStream.readObj`</span>
  <span class='z'>**</span>
  Obj? <span id='readObj'>readObj</span><span class='b'>([</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Conversions</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Encode the buffer contents from 0 to size into a</span>
  <span class='z'>** hexadecimal string.  This method is unsupported for</span>
  <span class='z'>** mmap buffers.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.make.print("\r\n").toHex   =&gt; "0d0a"</span>
  <span class='z'>**   Buf.fromHex("0d0a").readAllStr =&gt; "\r\n"</span>
  <span class='z'>**</span>
  Str <span id='toHex'>toHex</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Decode the specified hexadecimal string into its binary</span>
  <span class='z'>** contents.  Any characters which are not included in the</span>
  <span class='z'>** set "0-9, a-f, A-F" are ignored as long as they appear</span>
  <span class='z'>** between bytes (hi and lo nibbles must be contiguous).</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.make.print("\r\n").toHex   =&gt; "0d0a"</span>
  <span class='z'>**   Buf.fromHex("0d0a").readAllStr =&gt; "\r\n"</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Buf <span id='fromHex'>fromHex</span><span class='b'>(</span>Str s<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Encode the buffer contents from 0 to size to a Base64</span>
  <span class='z'>** string as defined by MIME RFC 2045.  No line breaks are</span>
  <span class='z'>** added.  This method is only supported by memory backed</span>
  <span class='z'>** buffers, file backed buffers will throw UnsupportedErr.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.make.print("Fan").toBase64    =&gt; "RmFu"</span>
  <span class='z'>**   Buf.fromBase64("RmFu").readAllStr =&gt; "Fan"</span>
  <span class='z'>**</span>
  Str <span id='toBase64'>toBase64</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Decode the specified Base64 string into its binary contents</span>
  <span class='z'>** as defined by MIME RFC 2045.  Any characters which are not</span>
  <span class='z'>** included in the Base64 character set are safely ignored.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.make.print("Fan").toBase64    =&gt; "RmFu"</span>
  <span class='z'>**   Buf.fromBase64("RmFu").readAllStr =&gt; "Fan"</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Buf <span id='fromBase64'>fromBase64</span><span class='b'>(</span>Str s<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Apply the specified message digest algorthm to this buffer's</span>
  <span class='z'>** contents from 0 to size and return the resulting hash.  Digests</span>
  <span class='z'>** are secure one-way hash functions which input an arbitrary sized</span>
  <span class='z'>** buffer and return a fixed sized buffer.  Common algorithms include:</span>
  <span class='z'>** "MD5", "SHA-1", and "SHA-256"; the full list supported is platform</span>
  <span class='z'>** dependent.  On the Java VM, the algorithm maps to those avaialble</span>
  <span class='z'>** via the 'java.security.MessageDigest' API.  Throw ArgErr if the</span>
  <span class='z'>** algorithm is not available.  This method is unsupported for mmap</span>
  <span class='z'>** buffers.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Buf.make.print("password").print("salt").toDigest("MD5").toHex</span>
  <span class='z'>**    =&gt;  "b305cadbb3bce54f3aa59c64fec00dea"</span>
  <span class='z'>**</span>
  Buf <span id='toDigest'>toDigest</span><span class='b'>(</span>Str algorithm<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Generate an HMAC message authentication as specified by RFC 2104.</span>
  <span class='z'>** This buffer is the data input, 'algorithm' specifies the hash digest,</span>
  <span class='z'>** and 'key' represents the secret key:</span>
  <span class='z'>**   - 'H': specified by algorthim parameter - "MD5" or "SHA1"</span>
  <span class='z'>**   - 'K': secret key specified by key parameter</span>
  <span class='z'>**   - 'B': fixed at 64</span>
  <span class='z'>**   - 'text': this instance</span>
  <span class='z'>**</span>
  <span class='z'>** The HMAC is computed using:</span>
  <span class='z'>**   ipad = the byte 0x36 repeated B times</span>
  <span class='z'>**   opad = the byte 0x5C repeated B times</span>
  <span class='z'>**   H(K XOR opad, H(K XOR ipad, text))</span>
  <span class='z'>**</span>
  <span class='z'>** Throw ArgErr if the algorithm is not available.  This method is</span>
  <span class='z'>** only supported for memory buffers.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   "hi there".toBuf.hmac("MD5", "secret".toBuf)</span>
  <span class='z'>**</span>
  Buf <span id='hmac'>hmac</span><span class='b'>(</span>Str algorithm, Buf key<span class='b'>)</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** MemBuf</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> MemBuf : Buf
<span class='b'>{</span>
  <span class='k'>private</span> <span class='k'>new</span> init<span class='b'>()</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** FileBuf</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> FileBuf : Buf
<span class='b'>{</span>
  <span class='k'>private</span> <span class='k'>new</span> init<span class='b'>()</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** MmapBuf</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>class</span> MmapBuf : Buf
<span class='b'>{</span>
  <span class='k'>private</span> <span class='k'>new</span> init<span class='b'>()</span>
<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Buf.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#capacity'>capacity</a></li>
  <li style='display: block;'><a href='#charset'>charset</a></li>
  <li style='display: block;'><a href='#clear'>clear</a></li>
  <li style='display: block;'><a href='#close'>close</a></li>
  <li style='display: block;'><a href='#dup'>dup</a></li>
  <li style='display: block;'><a href='#eachLine'>eachLine</a></li>
  <li style='display: block;'><a href='#endian'>endian</a></li>
  <li style='display: block;'><a href='#equals'>equals</a></li>
  <li style='display: block;'><a href='#fill'>fill</a></li>
  <li style='display: block;'><a href='#flip'>flip</a></li>
  <li style='display: block;'><a href='#flush'>flush</a></li>
  <li style='display: block;'><a href='#fromBase64'>fromBase64</a></li>
  <li style='display: block;'><a href='#fromHex'>fromHex</a></li>
  <li style='display: block;'><a href='#get'>get</a></li>
  <li style='display: block;'><a href='#getRange'>getRange</a></li>
  <li style='display: block;'><a href='#hmac'>hmac</a></li>
  <li style='display: block;'><a href='#in'>in</a></li>
  <li class='hidden' style='display: block;'><a href='#internalMake'>internalMake</a></li>
  <li style='display: block;'><a href='#isEmpty'>isEmpty</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#more'>more</a></li>
  <li style='display: block;'><a href='#out'>out</a></li>
  <li style='display: block;'><a href='#peek'>peek</a></li>
  <li style='display: block;'><a href='#peekChar'>peekChar</a></li>
  <li style='display: block;'><a href='#pos'>pos</a></li>
  <li style='display: block;'><a href='#print'>print</a></li>
  <li style='display: block;'><a href='#printLine'>printLine</a></li>
  <li style='display: block;'><a href='#random'>random</a></li>
  <li style='display: block;'><a href='#read'>read</a></li>
  <li style='display: block;'><a href='#readAllBuf'>readAllBuf</a></li>
  <li style='display: block;'><a href='#readAllLines'>readAllLines</a></li>
  <li style='display: block;'><a href='#readAllStr'>readAllStr</a></li>
  <li style='display: block;'><a href='#readBool'>readBool</a></li>
  <li style='display: block;'><a href='#readBuf'>readBuf</a></li>
  <li style='display: block;'><a href='#readBufFully'>readBufFully</a></li>
  <li style='display: block;'><a href='#readChar'>readChar</a></li>
  <li style='display: block;'><a href='#readChars'>readChars</a></li>
  <li style='display: block;'><a href='#readDecimal'>readDecimal</a></li>
  <li style='display: block;'><a href='#readF4'>readF4</a></li>
  <li style='display: block;'><a href='#readF8'>readF8</a></li>
  <li style='display: block;'><a href='#readLine'>readLine</a></li>
  <li style='display: block;'><a href='#readObj'>readObj</a></li>
  <li style='display: block;'><a href='#readProps'>readProps</a></li>
  <li style='display: block;'><a href='#readS1'>readS1</a></li>
  <li style='display: block;'><a href='#readS2'>readS2</a></li>
  <li style='display: block;'><a href='#readS4'>readS4</a></li>
  <li style='display: block;'><a href='#readS8'>readS8</a></li>
  <li style='display: block;'><a href='#readStrToken'>readStrToken</a></li>
  <li style='display: block;'><a href='#readU1'>readU1</a></li>
  <li style='display: block;'><a href='#readU2'>readU2</a></li>
  <li style='display: block;'><a href='#readU4'>readU4</a></li>
  <li style='display: block;'><a href='#readUtf'>readUtf</a></li>
  <li style='display: block;'><a href='#remaining'>remaining</a></li>
  <li style='display: block;'><a href='#seek'>seek</a></li>
  <li style='display: block;'><a href='#set'>set</a></li>
  <li style='display: block;'><a href='#size'>size</a></li>
  <li style='display: block;'><a href='#slice'>slice</a></li>
  <li style='display: block;'><a href='#toBase64'>toBase64</a></li>
  <li style='display: block;'><a href='#toDigest'>toDigest</a></li>
  <li style='display: block;'><a href='#toHex'>toHex</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
  <li style='display: block;'><a href='#trim'>trim</a></li>
  <li style='display: block;'><a href='#unread'>unread</a></li>
  <li style='display: block;'><a href='#unreadChar'>unreadChar</a></li>
  <li style='display: block;'><a href='#write'>write</a></li>
  <li style='display: block;'><a href='#writeBool'>writeBool</a></li>
  <li style='display: block;'><a href='#writeBuf'>writeBuf</a></li>
  <li style='display: block;'><a href='#writeChar'>writeChar</a></li>
  <li style='display: block;'><a href='#writeChars'>writeChars</a></li>
  <li style='display: block;'><a href='#writeDecimal'>writeDecimal</a></li>
  <li style='display: block;'><a href='#writeF4'>writeF4</a></li>
  <li style='display: block;'><a href='#writeF8'>writeF8</a></li>
  <li style='display: block;'><a href='#writeI2'>writeI2</a></li>
  <li style='display: block;'><a href='#writeI4'>writeI4</a></li>
  <li style='display: block;'><a href='#writeI8'>writeI8</a></li>
  <li style='display: block;'><a href='#writeObj'>writeObj</a></li>
  <li style='display: block;'><a href='#writeProps'>writeProps</a></li>
  <li style='display: block;'><a href='#writeUtf'>writeUtf</a></li>
  <li style='display: block;'><a href='#writeXml'>writeXml</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
sys 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>

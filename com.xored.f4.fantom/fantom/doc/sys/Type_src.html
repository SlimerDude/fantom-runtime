<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>sys::Type</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>sys</a></li>
  <li>&gt;</li>
  <li><a href='Type.html'>Type</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>const class</h2>
<h1>sys::Type</h1>
<pre><a href='Obj.html'>sys::Obj</a>
  sys::Type</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   4 Jan 06  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** Type defines the contract of an Obj by the slots its supports.</span>
<span class='z'>** Types model the inheritance relationships and provide a mapping</span>
<span class='z'>** for all the slots both inherited and declared.</span>
<span class='z'>**</span>
@Serializable <span class='b'>{</span> simple = <span class='k'>true</span> <span class='b'>}</span>
<span class='k'>const</span> <span class='k'>class</span> Type
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Private constructor.</span>
  <span class='z'>**</span>
  <span class='k'>private</span> <span class='k'>new</span> <span id='privateMake'>privateMake</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Management</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the class Type of the given instance.  Also</span>
  <span class='z'>** see `Obj.typeof` which provides the same functionality.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Type <span id='of'>of</span><span class='b'>(</span>Obj obj<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Find a Type by it's qualified name "pod::Type".  If the type</span>
  <span class='z'>** doesn't exist and checked is false then return null, otherwise</span>
  <span class='z'>** throw UnknownTypeErr.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> Type? <span id='find'>find</span><span class='b'>(</span>Str qname, Bool checked := <span class='k'>true</span><span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Naming</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Parent pod which defines this type.  For parameterized types derived</span>
  <span class='z'>** from List, Map, or Func, this method always returns the sys pod.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.pod         =&gt; sys</span>
  <span class='z'>**   acme::Foo#.pod   =&gt; acme</span>
  <span class='z'>**   acme::Foo[]#.pod =&gt; sys</span>
  <span class='z'>**</span>
  Pod? <span id='pod'>pod</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Simple name of the type such as "Str".  For parameterized types derived</span>
  <span class='z'>** from List, Map, or Func, this method always returns "List", "Map",</span>
  <span class='z'>** or "Func" respectively.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.name         =&gt; "Str"</span>
  <span class='z'>**   acme::Foo#.name   =&gt; "Foo"</span>
  <span class='z'>**   acme::Foo[]#.name =&gt; "List"</span>
  <span class='z'>**</span>
  Str <span id='name'>name</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Qualified name formatted as "pod::name".  For parameterized</span>
  <span class='z'>** types derived from List, Map, or Func, this method always returns</span>
  <span class='z'>** "sys::List", "sys::Map", or "sys::Func" respectively.  If this</span>
  <span class='z'>** a nullable type, the qname does *not* include the "?".</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.qname         =&gt; "sys::Str"</span>
  <span class='z'>**   Str?#.qname        =&gt; "sys::Str"</span>
  <span class='z'>**   acme::Foo#.qname   =&gt; "acme::Foo"</span>
  <span class='z'>**   acme::Foo[]#.qname =&gt; "sys::List"</span>
  <span class='z'>**</span>
  Str <span id='qname'>qname</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the formal signature of this type.  In the case of</span>
  <span class='z'>** non-parameterized types the signature is the same as qname.</span>
  <span class='z'>** For parameterized types derived from List, Map, or Func the</span>
  <span class='z'>** signature uses the following special syntax:</span>
  <span class='z'>**   List =&gt; V[]</span>
  <span class='z'>**   Map  =&gt; [K:V]</span>
  <span class='z'>**   Func =&gt; |A,B...-&gt;R|</span>
  <span class='z'>**</span>
  <span class='z'>** If this is a nullable type, the signature ends with "?" such</span>
  <span class='z'>** as "sys::Int?".</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.signature =&gt; "sys::Str"</span>
  <span class='z'>**   Str?#.signature =&gt; "sys::Str?"</span>
  <span class='z'>**   Int[]#.signature =&gt; "sys::Int[]"</span>
  <span class='z'>**   Int:Str#.signature =&gt; "[sys::Int:sys::Str]"</span>
  <span class='z'>**   Str:Buf[]#.signature =&gt; [sys::Str:sys::Buf[]]</span>
  <span class='z'>**   |Float x-&gt;Bool|#.signature =&gt; "|sys::Float-&gt;sys::Bool|"</span>
  <span class='z'>**   |Float x, Int y|#.signature =&gt; |sys::Float,sys::Int-&gt;sys::Void|</span>
  <span class='z'>**</span>
  Str <span id='signature'>signature</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Inheritance</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** The direct super class of this type (null for Obj).</span>
  <span class='z'>** Return sys::Obj for all mixin types.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Obj#.base        =&gt;  null</span>
  <span class='z'>**   Int#.base        =&gt;  sys::Num</span>
  <span class='z'>**   OutStream#.base  =&gt;  sys::Obj</span>
  <span class='z'>**</span>
  Type? <span id='base'>base</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the mixins directly implemented by this type.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Obj#.mixins        =&gt;  [,]</span>
  <span class='z'>**   Buf#.mixins        =&gt;  [sys::InStream, sys::OutStream]</span>
  <span class='z'>**   OutStream#.mixins  =&gt;  [,]</span>
  <span class='z'>**</span>
  Type<span class='b'>[]</span> <span id='mixins'>mixins</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return a recursive flattened list of all the types this type</span>
  <span class='z'>** inherits from.  The result list always includes this type itself.</span>
  <span class='z'>** The result of this method represents the complete list of types</span>
  <span class='z'>** implemented by this type - instances of this type are assignable</span>
  <span class='z'>** to any type in this list.  All types (including mixins) will</span>
  <span class='z'>** include sys::Obj in this list.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Obj#.inheritance  =&gt;  [sys::Obj]</span>
  <span class='z'>**   Int#.inheritance  =&gt;  [sys::Int, sys::Num, sys::Obj]</span>
  <span class='z'>**</span>
  Type<span class='b'>[]</span> <span id='inheritance'>inheritance</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Does this type implement the specified type.  If true, then</span>
  <span class='z'>** this type is assignable to the specified type (although the</span>
  <span class='z'>** converse is not necessarily true).  This method provides the</span>
  <span class='z'>** same semantics as the 'is' operator, but between two types</span>
  <span class='z'>** rather than an instance and a type.  All types (including</span>
  <span class='z'>** mixin types) fit 'sys::Obj'.</span>
  <span class='z'>**</span>
  <span class='z'>** Example:</span>
  <span class='z'>**   Float#.fits(Float#) =&gt;  true</span>
  <span class='z'>**   Float#.fits(Num#)   =&gt;  true</span>
  <span class='z'>**   Float#.fits(Obj#)   =&gt;  true</span>
  <span class='z'>**   Float#.fits(Str#)   =&gt;  false</span>
  <span class='z'>**   Obj#.fits(Float#)   =&gt;  false</span>
  <span class='z'>**</span>
  Bool <span id='fits'>fits</span><span class='b'>(</span>Type t<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Value Types</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Is this a value type.  Fantom supports three implicit value</span>
  <span class='z'>** types: `Bool`, `Int`, and `Float`.</span>
  <span class='z'>**</span>
  Bool <span id='isVal'>isVal</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Nullable</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Is this a nullable type.  Nullable types can store the 'null'</span>
  <span class='z'>** value, but non-nullables are never null.  Null types are indicated</span>
  <span class='z'>** with a trailing "?".</span>
  <span class='z'>**</span>
  Bool <span id='isNullable'>isNullable</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return this type as a nullable type.  If this type is already</span>
  <span class='z'>** nullable then return this.</span>
  <span class='z'>**</span>
  Type <span id='toNullable'>toNullable</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return this type as a non-nullable type.  If this type is already</span>
  <span class='z'>** non-nullable then return this.</span>
  <span class='z'>**</span>
  Type <span id='toNonNullable'>toNonNullable</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Generics</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** A generic type contains slot signatures which may be parameterized - for</span>
  <span class='z'>** example Map's key and value types are generic as K and V.  Fantom supports</span>
  <span class='z'>** three built-in generic types: List, Map, and Func.   A parameterized</span>
  <span class='z'>** type such as Str[] is not a generic type (all of its generic parameters</span>
  <span class='z'>** have been filled in).  User defined generic types are not supported in Fantom.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.isGeneric   =&gt; false</span>
  <span class='z'>**   List#.isGeneric  =&gt; true</span>
  <span class='z'>**   Str[]#.isGeneric =&gt; false</span>
  <span class='z'>**</span>
  Bool <span id='isGeneric'>isGeneric</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a parameterized type, then return the map of names to</span>
  <span class='z'>** types.  If this is not a parameterized type return an empty map.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.params =&gt; [:]</span>
  <span class='z'>**   Str[]#.params =&gt; ["V":Str, "L":Str[]]</span>
  <span class='z'>**   Int:Slot#.params =&gt; ["K":Int, "V":Slot, "M":Int:Slot]</span>
  <span class='z'>**   |Int x, Float y-&gt;Bool|#.params =&gt; ["A":Int, "B":Float, "R":Bool]</span>
  <span class='z'>**</span>
  Str:Type <span id='params'>params</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** If this is a generic type, then dynamically create a new parameterized</span>
  <span class='z'>** type with the specified name to type map.  If this type is not generic</span>
  <span class='z'>** then throw UnsupportedErr.  Throw ArgErr if params fails to specify</span>
  <span class='z'>** the required parameters:</span>
  <span class='z'>**    List =&gt; V required</span>
  <span class='z'>**    Map  =&gt; K, V required</span>
  <span class='z'>**    Func =&gt; R required, A-H optional</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   List#.parameterize(["V":Bool#]) =&gt; Bool[]</span>
  <span class='z'>**   Map#.parameterize(["K":Str#, "V":Obj#]) =&gt; Str:Obj</span>
  <span class='z'>**</span>
  Type <span id='parameterize'>parameterize</span><span class='b'>(</span>Str:Type params<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for List#.parameterize(["V":this])</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Int#.toListOf =&gt; Int[]</span>
  <span class='z'>**   Str[]#.toListOf =&gt; Str[][]</span>
  <span class='z'>**</span>
  Type <span id='toListOf'>toListOf</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return an immutable empty list of this type.  Since immutable</span>
  <span class='z'>** lists can be used safely everywhere, this allows signficant memory</span>
  <span class='z'>** savings instead allocating new empty lists.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   Str#.emptyList  =&gt;  Str[,]</span>
  <span class='z'>**</span>
  Obj<span class='b'>[]</span> <span id='emptyList'>emptyList</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Flags</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is abstract and cannot be instantiated.  This</span>
  <span class='z'>** method will always return true if the type is a mixin.</span>
  <span class='z'>**</span>
  Bool <span id='isAbstract'>isAbstract</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is a class (as opposed to enum or mixin)</span>
  <span class='z'>**</span>
  Bool <span id='isClass'>isClass</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this is a const class which means instances of this</span>
  <span class='z'>** class are immutable.</span>
  <span class='z'>**</span>
  Bool <span id='isConst'>isConst</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is an Enum type.</span>
  <span class='z'>**</span>
  Bool <span id='isEnum'>isEnum</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is an Facet type.</span>
  <span class='z'>**</span>
  Bool <span id='isFacet'>isFacet</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is marked final which means it may not be subclassed.</span>
  <span class='z'>**</span>
  Bool <span id='isFinal'>isFinal</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type has internal protection scope.</span>
  <span class='z'>**</span>
  Bool <span id='isInternal'>isInternal</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type is a mixin type and cannot be instantiated.</span>
  <span class='z'>**</span>
  Bool <span id='isMixin'>isMixin</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type has public protection scope.</span>
  <span class='z'>**</span>
  Bool <span id='isPublic'>isPublic</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this Type was generated by the compiler.</span>
  <span class='z'>**</span>
  Bool <span id='isSynthetic'>isSynthetic</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Slots</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all defined fields (including inherited fields).</span>
  <span class='z'>**</span>
  Field<span class='b'>[]</span> <span id='fields'>fields</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all defined methods (including inherited methods).</span>
  <span class='z'>**</span>
  Method<span class='b'>[]</span> <span id='methods'>methods</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** List of the all defined slots, both fields and methods (including</span>
  <span class='z'>** inherited slots).</span>
  <span class='z'>**</span>
  Slot<span class='b'>[]</span> <span id='slots'>slots</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for (Field)slot(name, checked)</span>
  <span class='z'>**</span>
  Field? <span id='field'>field</span><span class='b'>(</span>Str name, Bool checked := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for (Method)slot(name, checked)</span>
  <span class='z'>**</span>
  Method? <span id='method'>method</span><span class='b'>(</span>Str name, Bool checked := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Lookup a slot by name.  If the slot doesn't exist and checked</span>
  <span class='z'>** is false then return null, otherwise throw UnknownSlotErr.</span>
  <span class='z'>**</span>
  Slot? <span id='slot'>slot</span><span class='b'>(</span>Str name, Bool checked := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Create a new instance of this Type using the following rules:</span>
  <span class='z'>**   1. Call public constructor 'make' with specified arguments</span>
  <span class='z'>**   2. If no public constructor called 'make' or invalid number of</span>
  <span class='z'>**      of required arguments, then return value of 'defVal' slot (must</span>
  <span class='z'>**      be static field or static method with zero params)</span>
  <span class='z'>**   3. If no public 'defVal' field, then throw Err</span>
  <span class='z'>**</span>
  Obj <span id='make'>make</span><span class='b'>(</span>Obj<span class='b'>[]</span>? args := <span class='k'>null</span><span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Facets</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Get the list of facets defined on this type or return an empty</span>
  <span class='z'>** list if no facets are defined. If looking up a facet by type, then</span>
  <span class='z'>** use the `facet` method which will provide better performance.</span>
  <span class='z'>** See [Facets Doc]`docLang::Facets` for details.</span>
  <span class='z'>**</span>
  Facet<span class='b'>[]</span> <span id='facets'>facets</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get a facet by its type.  If not found on this type then</span>
  <span class='z'>** return null or throw UnknownFacetErr based on check flag.</span>
  <span class='z'>** See [Facets Doc]`docLang::Facets` for details.</span>
  <span class='z'>**</span>
  Facet? <span id='facet'>facet</span><span class='b'>(</span>Type type, Bool checked := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this type has the specified facet defined.</span>
  <span class='z'>**</span>
  Bool <span id='hasFacet'>hasFacet</span><span class='b'>(</span>Type type<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Documentation</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return the raw fandoc for this type or null if not available.</span>
  <span class='z'>** If there is additional documentation meta-data available it is</span>
  <span class='z'>** included an the start of the string as a series of "@name=value"</span>
  <span class='z'>** lines.</span>
  <span class='z'>**</span>
  Str? <span id='doc'>doc</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Conversion</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Always return signature().</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return `signature`.  This method is used to enable 'toLocale' to</span>
  <span class='z'>** be used with duck typing across most built-in types.  Note: we may</span>
  <span class='z'>** change the specification of this method in the future to allow</span>
  <span class='z'>** localized type names.</span>
  <span class='z'>**</span>
  Str <span id='toLocale'>toLocale</span><span class='b'>()</span>

<span class='b'>}</span></pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='Type.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#base'>base</a></li>
  <li style='display: block;'><a href='#doc'>doc</a></li>
  <li style='display: block;'><a href='#emptyList'>emptyList</a></li>
  <li style='display: block;'><a href='#facet'>facet</a></li>
  <li style='display: block;'><a href='#facets'>facets</a></li>
  <li style='display: block;'><a href='#field'>field</a></li>
  <li style='display: block;'><a href='#fields'>fields</a></li>
  <li style='display: block;'><a href='#find'>find</a></li>
  <li style='display: block;'><a href='#fits'>fits</a></li>
  <li style='display: block;'><a href='#hasFacet'>hasFacet</a></li>
  <li style='display: block;'><a href='#inheritance'>inheritance</a></li>
  <li style='display: block;'><a href='#isAbstract'>isAbstract</a></li>
  <li style='display: block;'><a href='#isClass'>isClass</a></li>
  <li style='display: block;'><a href='#isConst'>isConst</a></li>
  <li style='display: block;'><a href='#isEnum'>isEnum</a></li>
  <li style='display: block;'><a href='#isFacet'>isFacet</a></li>
  <li style='display: block;'><a href='#isFinal'>isFinal</a></li>
  <li style='display: block;'><a href='#isGeneric'>isGeneric</a></li>
  <li style='display: block;'><a href='#isInternal'>isInternal</a></li>
  <li style='display: block;'><a href='#isMixin'>isMixin</a></li>
  <li style='display: block;'><a href='#isNullable'>isNullable</a></li>
  <li style='display: block;'><a href='#isPublic'>isPublic</a></li>
  <li style='display: block;'><a href='#isSynthetic'>isSynthetic</a></li>
  <li style='display: block;'><a href='#isVal'>isVal</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#method'>method</a></li>
  <li style='display: block;'><a href='#methods'>methods</a></li>
  <li style='display: block;'><a href='#mixins'>mixins</a></li>
  <li style='display: block;'><a href='#name'>name</a></li>
  <li style='display: block;'><a href='#of'>of</a></li>
  <li style='display: block;'><a href='#parameterize'>parameterize</a></li>
  <li style='display: block;'><a href='#params'>params</a></li>
  <li style='display: block;'><a href='#pod'>pod</a></li>
  <li class='hidden' style='display: block;'><a href='#privateMake'>privateMake</a></li>
  <li style='display: block;'><a href='#qname'>qname</a></li>
  <li style='display: block;'><a href='#signature'>signature</a></li>
  <li style='display: block;'><a href='#slot'>slot</a></li>
  <li style='display: block;'><a href='#slots'>slots</a></li>
  <li style='display: block;'><a href='#toListOf'>toListOf</a></li>
  <li style='display: block;'><a href='#toLocale'>toLocale</a></li>
  <li style='display: block;'><a href='#toNonNullable'>toNonNullable</a></li>
  <li style='display: block;'><a href='#toNullable'>toNullable</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
sys 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>

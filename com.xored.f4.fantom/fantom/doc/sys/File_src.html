<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <title>sys::File</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
  <link rel='stylesheet' type='text/css' href='../doc.css'/>
  <script type='text/javascript' src='../doc.js'></script>
<!--[if lt IE 7]>
<script src='http://ie7-js.googlecode.com/svn/version/2.0(beta3)/IE7.js' type='text/javascript'></script>
<![endif]-->
</head>
<body onload='Login.check();'>
<div class='header'>
<div>
<h1><a href='/'>Fantom</a></h1>
<p id='sidewalkLogin_'>&nbsp;</p>
<form method='get' action='/sidewalk/search/'>
<p>
<input type='text' name='q' size='30' value='Search...' onfocus='if (value=="Search...") value=""' onblur='if (value=="") value="Search..."' />
</p>
</form>
<ul>
<li><a href='/'>Home</a></li>
<li class='active'><a href='../index.html'>Docs</a></li>
<li><a href='/sidewalk/blog/'>Blog</a></li>
<li><a href='/sidewalk/ticket/'>Tickets</a></li>
<li><a href='/sidewalk/topic/'>Discuss</a></li>
</ul></div>
</div>
<div class='subHeader'>
<div>
<ul>
  <li><a href='../index.html'>Doc Home</a></li>
  <li>&gt;</li>
  <li><a href='index.html'>sys</a></li>
  <li>&gt;</li>
  <li><a href='File.html'>File</a></li>
</ul>
</div>
</div>
<div class='content'>
<div>
<div class='fandoc'>
<div class='type'>
<div class='overview'>
<h2>abstract const class</h2>
<h1>sys::File</h1>
<pre><a href='Obj.html'>sys::Obj</a>
  sys::File</pre>
</div>
</div>
<div class='src'>
<pre>
<span class='y'>//</span>
<span class='y'>// Copyright (c) 2006, Brian Frank and Andy Frank</span>
<span class='y'>// Licensed under the Academic Free License version 3.0</span>
<span class='y'>//</span>
<span class='y'>// History:</span>
<span class='y'>//   26 Mar 06  Brian Frank  Creation</span>
<span class='y'>//</span>

<span class='z'>**</span>
<span class='z'>** File is used to represent a Uri path to a file or directory.</span>
<span class='z'>** See [examples]`examples::sys-files`.</span>
<span class='z'>**</span>
<span class='k'>abstract</span> <span class='k'>const</span> <span class='k'>class</span> File
<span class='b'>{</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Constructor</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Make a File for the Uri which represents a file on the local</span>
  <span class='z'>** file system.  If creating a Uri to a directory, then the Uri</span>
  <span class='z'>** must end in a trailing "/" slash or IOErr is thrown - or you</span>
  <span class='z'>** may pass false for checkSlash in which case the trailing slash</span>
  <span class='z'>** is implicitly added.  However if a trailing slash is added, then</span>
  <span class='z'>** the resulting File's uri will not match the uri passed to this method.</span>
  <span class='z'>** If the file doesn't exist, then it is assumed to be to a directory</span>
  <span class='z'>** based on a trailing slash (see `isDir`).  If the Uri has a relative</span>
  <span class='z'>** path, then it is assumed to be relative to the current working</span>
  <span class='z'>** directory.  Throw ArgErr if the Uri has a scheme other than null</span>
  <span class='z'>** or "file:".</span>
  <span class='z'>**</span>
  <span class='k'>static</span> File <span id='make'>make</span><span class='b'>(</span>Uri uri, Bool checkSlash := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Make a File for the specified operating system specific path</span>
  <span class='z'>** on the local file system.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> File <span id='os'>os</span><span class='b'>(</span>Str osPath<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Get the root directories of the operating system's local file system.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> File<span class='b'>[]</span> <span id='osRoots'>osRoots</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Create a temporary file which is guaranteed to be a new, empty</span>
  <span class='z'>** file with a unique name.  The file name will be generated using</span>
  <span class='z'>** the specified prefix and suffix.  If dir is non-null then it is used</span>
  <span class='z'>** as the file's parent directory, otherwise the system's default</span>
  <span class='z'>** temporary directory is used.  If dir is specified it must be a</span>
  <span class='z'>** directory on the local file system.  See `deleteOnExit` if you wish</span>
  <span class='z'>** to have the file automatically deleted on exit.  Throw IOErr on error.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   File.createTemp("x", ".txt") =&gt; `/tmp/x67392.txt`</span>
  <span class='z'>**   File.createTemp.deleteOnExit =&gt; `/tmp/fan5284.tmp`</span>
  <span class='z'>**</span>
  <span class='k'>static</span> File <span id='createTemp'>createTemp</span><span class='b'>(</span>Str prefix := <span class='s'>"fan"</span>, Str suffix := <span class='s'>".tmp"</span>, File? dir := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Protected constructor for subclasses.</span>
  <span class='z'>**</span>
  <span class='k'>protected</span> <span class='k'>new</span> <span id='makeNew'>makeNew</span><span class='b'>(</span>Uri uri<span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Identity</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** File equality is based on the un-normalized Uri used to create the File.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Bool <span id='equals'>equals</span><span class='b'>(</span>Obj? that<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return 'uri.hash'.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Int <span id='hash'>hash</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return 'uri.toStr'.</span>
  <span class='z'>**</span>
  <span class='k'>override</span> Str <span id='toStr'>toStr</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Uri</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return the Uri path used to create this File.</span>
  <span class='z'>** This Uri may be absolute or relative.</span>
  <span class='z'>**</span>
  Uri <span id='uri'>uri</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.isDir]`Uri.isDir`</span>
  <span class='z'>**</span>
  Bool <span id='isDir'>isDir</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.path]`Uri.path`.</span>
  <span class='z'>**</span>
  Str<span class='b'>[]</span> <span id='path'>path</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.pathStr]`Uri.pathStr`.</span>
  <span class='z'>**</span>
  Str <span id='pathStr'>pathStr</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.name]`Uri.name`.</span>
  <span class='z'>**</span>
  Str <span id='name'>name</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.basename]`Uri.basename`.</span>
  <span class='z'>**</span>
  Str <span id='basename'>basename</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.ext]`Uri.ext`.</span>
  <span class='z'>**</span>
  Str? <span id='ext'>ext</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [uri.mimeType]`Uri.mimeType`.</span>
  <span class='z'>**</span>
  MimeType? <span id='mimeType'>mimeType</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Access</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Return if this file exists.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Bool <span id='exists'>exists</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Return the size of the file in bytes otherwise null if a</span>
  <span class='z'>** directory or unknown.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Int? <span id='size'>size</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get time the file was last modified or null if unknown.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> DateTime? <span id='modified'>modified</span>

  <span class='z'>**</span>
  <span class='z'>** Get this File as an operating system specific path on</span>
  <span class='z'>** the local system.  If this File doesn't represent a</span>
  <span class='z'>** path on the local file system then return null.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Str? <span id='osPath'>osPath</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Get the parent directory of this file or null.</span>
  <span class='z'>** Also see `Uri.parent`.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File? <span id='parent'>parent</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** List the files contained by this directory.  This list includes</span>
  <span class='z'>** both child sub-directories and normal files.  If the directory</span>
  <span class='z'>** is empty or this file doesn't represent a directory, then return</span>
  <span class='z'>** an empty list.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File<span class='b'>[]</span> <span id='list'>list</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** List the child sub-directories contained by this directory.  If</span>
  <span class='z'>** the directory doesn't contain any sub-direcotries or this file</span>
  <span class='z'>** doesn't represent a directory, then return an empty list.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File<span class='b'>[]</span> <span id='listDirs'>listDirs</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** List the child files (excludes directories) contained by this</span>
  <span class='z'>** directory.  If the directory doesn't contain any child files</span>
  <span class='z'>** or this file doesn't represent a directory, then return an</span>
  <span class='z'>** empty list.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File<span class='b'>[]</span> <span id='listFiles'>listFiles</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Recursively walk this file/directory top down.  If this</span>
  <span class='z'>** file is not a directory then the callback is invoked exactly</span>
  <span class='z'>** once with this file.  If a directory, then the callback</span>
  <span class='z'>** is invoked with this file, then recursively for each child</span>
  <span class='z'>** file.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> Void <span id='walk'>walk</span><span class='b'>(</span>|File f| c<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Normalize this file path to its canonical representation.</span>
  <span class='z'>** If a file on the local file system, then the uri will</span>
  <span class='z'>** include the "file:" scheme.  Throw IOErr on error.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File <span id='normalize'>normalize</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Make a new File instance by joining this file's Uri</span>
  <span class='z'>** together with the specified path.  If the file maps</span>
  <span class='z'>** to a directory and the resulting Uri doesn't end in</span>
  <span class='z'>** slash then an IOErr is thrown - or pass false for</span>
  <span class='z'>** checkSlash to have the slash implicitly added.</span>
  <span class='z'>**</span>
  <span class='z'>** Examples:</span>
  <span class='z'>**   File(`a/b/`) + `c` =&gt; File(`a/b/c`)</span>
  <span class='z'>**   File(`a/b`) + `c`  =&gt; File(`a/c`)</span>
  <span class='z'>**</span>
  @Operator <span class='k'>abstract</span> File <span id='plus'>plus</span><span class='b'>(</span>Uri path, Bool checkSlash := <span class='k'>true</span><span class='b'>)</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// Management</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Create a file or directory represented by this Uri.  If isDir() is</span>
  <span class='z'>** false then create an empty file, or if the file already exists</span>
  <span class='z'>** overwrite it to empty.  If isDir() is true then create a directory,</span>
  <span class='z'>** or if the directory already exists do nothing.  This method will</span>
  <span class='z'>** automatically create any parent directories.  Throw IOErr on error.</span>
  <span class='z'>** Return this.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File <span id='create'>create</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Create a file under this directory.  Convenience for `create`:</span>
  <span class='z'>**   return (this+name.toUri).create</span>
  <span class='z'>** Throw IOErr is this file is not a directory or if there is a</span>
  <span class='z'>** error creating the new file.  Return the file created.</span>
  <span class='z'>**</span>
  File <span id='createFile'>createFile</span><span class='b'>(</span>Str name<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Create a sub-directory under this directory.  Convenience</span>
  <span class='z'>** for `create`:</span>
  <span class='z'>**   return (this+name/.toUri).create</span>
  <span class='z'>** Throw IOErr is this file is not a directory or if there is a</span>
  <span class='z'>** error creating the new directory.  Return the directory created.</span>
  <span class='z'>**</span>
  File <span id='createDir'>createDir</span><span class='b'>(</span>Str name<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Copy this file or directory to the new specified location.</span>
  <span class='z'>** If this file represents a directory, then it recursively</span>
  <span class='z'>** copies the entire directory tree.</span>
  <span class='z'>**</span>
  <span class='z'>** The options map is used to customize how the copy is performed.</span>
  <span class='z'>** The following summarizes the options:</span>
  <span class='z'>**   - exclude:   Regex or |File f-&gt;Bool|</span>
  <span class='z'>**   - overwrite: Bool or |File f-&gt;Bool|</span>
  <span class='z'>**</span>
  <span class='z'>** If the "exclude" option is a Regex - each source file's Uri string</span>
  <span class='z'>** is is checked for a match to skip.  If a directory is skipped, then</span>
  <span class='z'>** its children are skipped also.  The exclude option can also be a</span>
  <span class='z'>** function of type '|File f-&gt;Bool|' to check each file.  Exclude</span>
  <span class='z'>** processing is performed first before checking for an overwrite.</span>
  <span class='z'>**</span>
  <span class='z'>** If during the copy, an existing file of the same name is found,</span>
  <span class='z'>** then the "overwrite" option should be to 'true' to overwrite or</span>
  <span class='z'>** 'false' to skip.  The overwrite option can also be a function</span>
  <span class='z'>** of type '|File f-&gt;Bool|' which is passed every destination file</span>
  <span class='z'>** to be overwritten.  If the overwrite function throws an exception,</span>
  <span class='z'>** it is raised to the 'copyTo' caller.  If a directory overwrite is</span>
  <span class='z'>** skipped, then it its children are skipped too.  If options are null</span>
  <span class='z'>** or overwrite is unspecified then the copy is immediately terminated</span>
  <span class='z'>** with an IOErr.</span>
  <span class='z'>**</span>
  <span class='z'>** Any IOErr or other error encountered during the file copy immediately</span>
  <span class='z'>** terminates the copy and is raised to the caller, which might leave</span>
  <span class='z'>** the copy in an unfinished state.</span>
  <span class='z'>**</span>
  <span class='z'>** Return the 'to' destination file.</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File <span id='copyTo'>copyTo</span><span class='b'>(</span>File to, <span class='b'>[</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Copy this file under the specified directory and return</span>
  <span class='z'>** the destination file.  This method is a convenience for:</span>
  <span class='z'>**   return this.copyTo(dir + this.name, options)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File <span id='copyInto'>copyInto</span><span class='b'>(</span>File dir, <span class='b'>[</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Move this file to the specified location.  If this file is</span>
  <span class='z'>** a directory, then the entire directory is moved.  If the</span>
  <span class='z'>** target file already exists or the move fails, then an IOErr</span>
  <span class='z'>** is thrown.  Return the 'to' destination file.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File <span id='moveTo'>moveTo</span><span class='b'>(</span>File to<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Move this file under the specified directory and return</span>
  <span class='z'>** the destination file.  This method is a convenience for:</span>
  <span class='z'>**   return this.moveTo(dir + this.name)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File <span id='moveInto'>moveInto</span><span class='b'>(</span>File dir<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Renaming this file within its current directory.</span>
  <span class='z'>** It is a convenience for:</span>
  <span class='z'>**   return this.moveTo(parent + newName)</span>
  <span class='z'>**</span>
  <span class='k'>virtual</span> File <span id='rename'>rename</span><span class='b'>(</span>Str newName<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Delete this file.  If this file represents a directory, then</span>
  <span class='z'>** recursively delete it.  If the file does not exist, then no</span>
  <span class='z'>** action is taken.  Throw IOErr on error.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Void <span id='delete'>delete</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Request that the file or directory represented by this File</span>
  <span class='z'>** be deleted when the virtual machine exits.  Long running applications</span>
  <span class='z'>** should use this method will care since each file marked to delete will</span>
  <span class='z'>** consume resources.  Throw IOErr on error.  Return this.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> File <span id='deleteOnExit'>deleteOnExit</span><span class='b'>()</span>

<span class='y'>//////////////////////////////////////////////////////////////////////////</span>
<span class='y'>// IO</span>
<span class='y'>//////////////////////////////////////////////////////////////////////////</span>

  <span class='z'>**</span>
  <span class='z'>** Open this file for random access.  Modes are:</span>
  <span class='z'>**   - "r": open the file for reading only.  Throws IOErr</span>
  <span class='z'>**     if file does not exist.</span>
  <span class='z'>**   - "rw": open the file for reading and writing; create</span>
  <span class='z'>**     if the file does not exist.</span>
  <span class='z'>**</span>
  <span class='z'>** The Buf instance returned is backed by a random access file</span>
  <span class='z'>** pointer. It provides the same functionality as a memory backed</span>
  <span class='z'>** buffer, except for a couple exceptions such as `Buf.unread`.</span>
  <span class='z'>** The resulting Buf is a raw interface to the random access</span>
  <span class='z'>** file, no buffering is provided at the framework level - so</span>
  <span class='z'>** use methods which only access a few bytes carefully.  However</span>
  <span class='z'>** methods which transfer data with other Bufs and IO streams</span>
  <span class='z'>** will use an internal buffer for efficiency.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Buf <span id='open'>open</span><span class='b'>(</span>Str mode := <span class='s'>"rw"</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Memory map the region of the file specified by 'pos' and 'size'.</span>
  <span class='z'>** The file is paged into virtual memory on demand.  Modes are:</span>
  <span class='z'>**   - "r": map the file for reading only.  Throws IOErr</span>
  <span class='z'>**     if file does not exist.</span>
  <span class='z'>**   - "rw": open the file for reading and writing; create</span>
  <span class='z'>**     if the file does not exist.</span>
  <span class='z'>**   - "p": private read/write mode will not propagate changes</span>
  <span class='z'>**     to other processes which have mapped the file.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> Buf <span id='mmap'>mmap</span><span class='b'>(</span>Str mode := <span class='s'>"rw"</span>, Int pos := 0, Int? size := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Open a new buffered InStream used to read from this file.  A</span>
  <span class='z'>** bufferSize of null or zero will return an unbuffered input stream.</span>
  <span class='z'>** Throw IOErr on error.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> InStream <span id='in'>in</span><span class='b'>(</span>Int? bufferSize := 4096<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Open a new buffered OutStream used to write to this file.  If append is</span>
  <span class='z'>** true, then we open the file to append to the end, otherwise it is</span>
  <span class='z'>** opened as an empty file.  A bufferSize of null or zero will return an</span>
  <span class='z'>** unbuffered input stream.  Throw IOErr on error.</span>
  <span class='z'>**</span>
  <span class='k'>abstract</span> OutStream <span id='out'>out</span><span class='b'>(</span>Bool append := <span class='k'>false</span>, Int? bufferSize := 4096<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllBuf]`File.readAllBuf`.</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Buf <span id='readAllBuf'>readAllBuf</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllLines]`File.readAllLines`.</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Str<span class='b'>[]</span> <span id='readAllLines'>readAllLines</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.eachLine]`File.eachLine`.</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Void <span id='eachLine'>eachLine</span><span class='b'>(</span>|Str line| f<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readAllStr]`File.readAllStr`.</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Str <span id='readAllStr'>readAllStr</span><span class='b'>(</span>Bool normalizeNewlines := <span class='k'>true</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readProps()]`File.readProps`.</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Str:Str <span id='readProps'>readProps</span><span class='b'>()</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeProps()]`File.writeProps`.</span>
  <span class='z'>** The output stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Void <span id='writeProps'>writeProps</span><span class='b'>(</span>Str:Str props<span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [in.readObj]`InStream.readObj`</span>
  <span class='z'>** The input stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Obj? <span id='readObj'>readObj</span><span class='b'>([</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Convenience for [out.writeObj]`OutStream.writeObj`</span>
  <span class='z'>** The output stream is guaranteed to be closed.</span>
  <span class='z'>**</span>
  Void <span id='writeObj'>writeObj</span><span class='b'>(</span>Obj? obj, <span class='b'>[</span>Str:Obj<span class='b'>]</span>? options := <span class='k'>null</span><span class='b'>)</span>

  <span class='z'>**</span>
  <span class='z'>** Return the platform's separator for names within</span>
  <span class='z'>** in a path: backslash on Windows, forward slash on Unix.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> <span class='k'>const</span> Str <span id='sep'>sep</span>

  <span class='z'>**</span>
  <span class='z'>** Return the platform's separator for a list of</span>
  <span class='z'>** paths: semicolon on Windows, colon on Unix.</span>
  <span class='z'>**</span>
  <span class='k'>static</span> <span class='k'>const</span> Str <span id='pathSep'>pathSep</span>

<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** LocalFile</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>const</span> <span class='k'>class</span> LocalFile : File
<span class='b'>{</span>
  <span class='k'>private</span> <span class='k'>new</span> init<span class='b'>()</span>
  <span class='k'>override</span> Bool exists<span class='b'>()</span>
  <span class='k'>override</span> Int? size<span class='b'>()</span>
  <span class='k'>override</span> DateTime? modified
  <span class='k'>override</span> Str? osPath<span class='b'>()</span>
  <span class='k'>override</span> File? parent<span class='b'>()</span>
  <span class='k'>override</span> File<span class='b'>[]</span> list<span class='b'>()</span>
  <span class='k'>override</span> File normalize<span class='b'>()</span>
  <span class='k'>override</span> File plus<span class='b'>(</span>Uri uri, Bool checkSlash := <span class='k'>true</span><span class='b'>)</span>
  <span class='k'>override</span> File create<span class='b'>()</span>
  <span class='k'>override</span> File moveTo<span class='b'>(</span>File to<span class='b'>)</span>
  <span class='k'>override</span> Void delete<span class='b'>()</span>
  <span class='k'>override</span> File deleteOnExit<span class='b'>()</span>
  <span class='k'>override</span> Buf open<span class='b'>(</span>Str mode := <span class='s'>"rw"</span><span class='b'>)</span>
  <span class='k'>override</span> Buf mmap<span class='b'>(</span>Str mode := <span class='s'>"rw"</span>, Int pos := 0, Int? size := <span class='k'>this</span>.size<span class='b'>)</span>
  <span class='k'>override</span> InStream in<span class='b'>(</span>Int? bufferSize := 4096<span class='b'>)</span>
  <span class='k'>override</span> OutStream out<span class='b'>(</span>Bool append := <span class='k'>false</span>, Int? bufferSize := 4096<span class='b'>)</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ZipEntryFile</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>const</span> <span class='k'>class</span> ZipEntryFile : File
<span class='b'>{</span>
  <span class='k'>internal</span> <span class='k'>new</span> init<span class='b'>()</span>
  <span class='k'>override</span> Bool exists<span class='b'>()</span>
  <span class='k'>override</span> Int? size<span class='b'>()</span>
  <span class='k'>override</span> DateTime? modified
  <span class='k'>override</span> Str? osPath<span class='b'>()</span>
  <span class='k'>override</span> File? parent<span class='b'>()</span>
  <span class='k'>override</span> File<span class='b'>[]</span> list<span class='b'>()</span>
  <span class='k'>override</span> File normalize<span class='b'>()</span>
  <span class='k'>override</span> File plus<span class='b'>(</span>Uri uri, Bool checkSlash := <span class='k'>true</span><span class='b'>)</span>
  <span class='k'>override</span> File create<span class='b'>()</span>
  <span class='k'>override</span> File moveTo<span class='b'>(</span>File to<span class='b'>)</span>
  <span class='k'>override</span> Void delete<span class='b'>()</span>
  <span class='k'>override</span> File deleteOnExit<span class='b'>()</span>
  <span class='k'>override</span> Buf open<span class='b'>(</span>Str mode := <span class='s'>"rw"</span><span class='b'>)</span>
  <span class='k'>override</span> Buf mmap<span class='b'>(</span>Str mode := <span class='s'>"rw"</span>, Int pos := 0, Int? size := <span class='k'>this</span>.size<span class='b'>)</span>
  <span class='k'>override</span> InStream in<span class='b'>(</span>Int? bufferSize := 4096<span class='b'>)</span>
  <span class='k'>override</span> OutStream out<span class='b'>(</span>Bool append := <span class='k'>false</span>, Int? bufferSize := 4096<span class='b'>)</span>
<span class='b'>}</span>

<span class='z'>**************************************************************************</span>
<span class='z'>** ClassLoaderFile</span>
<span class='z'>**************************************************************************</span>

<span class='k'>internal</span> <span class='k'>const</span> <span class='k'>class</span> ClassLoaderFile : ZipEntryFile
<span class='b'>{</span>
  <span class='k'>internal</span> <span class='k'>new</span> init<span class='b'>()</span>
<span class='b'>}</span>

</pre>
</div>
</div>
<div class='sidebar'>
<h2>More Info</h2>
<ul class='clean'>
  <li><a href='File.html'>View Fandoc</a></li>
</ul>
<div class='slots'>
<div class='overview'>
<h2>Slots</h2>
<ul class='clean'>
  <li style='display: block;'><a href='#basename'>basename</a></li>
  <li style='display: block;'><a href='#copyInto'>copyInto</a></li>
  <li style='display: block;'><a href='#copyTo'>copyTo</a></li>
  <li style='display: block;'><a href='#create'>create</a></li>
  <li style='display: block;'><a href='#createDir'>createDir</a></li>
  <li style='display: block;'><a href='#createFile'>createFile</a></li>
  <li style='display: block;'><a href='#createTemp'>createTemp</a></li>
  <li style='display: block;'><a href='#delete'>delete</a></li>
  <li style='display: block;'><a href='#deleteOnExit'>deleteOnExit</a></li>
  <li style='display: block;'><a href='#eachLine'>eachLine</a></li>
  <li style='display: block;'><a href='#equals'>equals</a></li>
  <li style='display: block;'><a href='#exists'>exists</a></li>
  <li style='display: block;'><a href='#ext'>ext</a></li>
  <li style='display: block;'><a href='#hash'>hash</a></li>
  <li style='display: block;'><a href='#in'>in</a></li>
  <li style='display: block;'><a href='#isDir'>isDir</a></li>
  <li style='display: block;'><a href='#list'>list</a></li>
  <li style='display: block;'><a href='#listDirs'>listDirs</a></li>
  <li style='display: block;'><a href='#listFiles'>listFiles</a></li>
  <li style='display: block;'><a href='#make'>make</a></li>
  <li style='display: block;'><a href='#makeNew'>makeNew</a></li>
  <li style='display: block;'><a href='#mimeType'>mimeType</a></li>
  <li style='display: block;'><a href='#mmap'>mmap</a></li>
  <li style='display: block;'><a href='#modified'>modified</a></li>
  <li style='display: block;'><a href='#moveInto'>moveInto</a></li>
  <li style='display: block;'><a href='#moveTo'>moveTo</a></li>
  <li style='display: block;'><a href='#name'>name</a></li>
  <li style='display: block;'><a href='#normalize'>normalize</a></li>
  <li style='display: block;'><a href='#open'>open</a></li>
  <li style='display: block;'><a href='#os'>os</a></li>
  <li style='display: block;'><a href='#osPath'>osPath</a></li>
  <li style='display: block;'><a href='#osRoots'>osRoots</a></li>
  <li style='display: block;'><a href='#out'>out</a></li>
  <li style='display: block;'><a href='#parent'>parent</a></li>
  <li style='display: block;'><a href='#path'>path</a></li>
  <li style='display: block;'><a href='#pathSep'>pathSep</a></li>
  <li style='display: block;'><a href='#pathStr'>pathStr</a></li>
  <li style='display: block;'><a href='#plus'>plus</a></li>
  <li style='display: block;'><a href='#readAllBuf'>readAllBuf</a></li>
  <li style='display: block;'><a href='#readAllLines'>readAllLines</a></li>
  <li style='display: block;'><a href='#readAllStr'>readAllStr</a></li>
  <li style='display: block;'><a href='#readObj'>readObj</a></li>
  <li style='display: block;'><a href='#readProps'>readProps</a></li>
  <li style='display: block;'><a href='#rename'>rename</a></li>
  <li style='display: block;'><a href='#sep'>sep</a></li>
  <li style='display: block;'><a href='#size'>size</a></li>
  <li style='display: block;'><a href='#toStr'>toStr</a></li>
  <li style='display: block;'><a href='#uri'>uri</a></li>
  <li style='display: block;'><a href='#walk'>walk</a></li>
  <li style='display: block;'><a href='#writeObj'>writeObj</a></li>
  <li style='display: block;'><a href='#writeProps'>writeProps</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class='footer'>
<div>
<p>
sys 1.0.56
[11-Nov-2010 Thu 10:08:16AM EST]
</p>
</div>
</div>
</body>
</html>
